# MIT License
#
# Copyright (c) 2023-2024 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.

cimport rocm.llvm._util.posixloader as loader
cdef void* _lib_handle = NULL

DLL = b"librocmllvm.so"

cdef int __init() except 1 nogil:
    global DLL
    global _lib_handle
    cdef char* dll = NULL
    if _lib_handle == NULL:
        with gil:
            dll = DLL
        return loader.open_library(&_lib_handle,dll)
    return 0

cdef int __init_symbol(void** result, const char* name) except 1 nogil:
    global _lib_handle
    cdef int init_result = 0
    if _lib_handle == NULL:
        init_result = __init()
        if init_result > 0:
            return init_result
    if result[0] == NULL:
        return loader.load_symbol(result,_lib_handle, name)
    return 0


cdef void* _lto_get_version__funptr = NULL
# 
# Returns a printable string.
# 
# \since prior to LTO_API_VERSION=3
cdef const char * lto_get_version():
    global _lto_get_version__funptr
    if __init_symbol(&_lto_get_version__funptr,"lto_get_version") > 0:
        pass
    return (<const char * (*)() noexcept nogil> _lto_get_version__funptr)()


cdef void* _lto_get_error_message__funptr = NULL
# 
# Returns the last error string or NULL if last operation was successful.
# 
# \since prior to LTO_API_VERSION=3
cdef const char * lto_get_error_message():
    global _lto_get_error_message__funptr
    if __init_symbol(&_lto_get_error_message__funptr,"lto_get_error_message") > 0:
        pass
    return (<const char * (*)() noexcept nogil> _lto_get_error_message__funptr)()


cdef void* _lto_module_is_object_file__funptr = NULL
# 
# Checks if a file is a loadable object file.
# 
# \since prior to LTO_API_VERSION=3
cdef _Bool lto_module_is_object_file(const char * path):
    global _lto_module_is_object_file__funptr
    if __init_symbol(&_lto_module_is_object_file__funptr,"lto_module_is_object_file") > 0:
        pass
    return (<_Bool (*)(const char *) noexcept nogil> _lto_module_is_object_file__funptr)(path)


cdef void* _lto_module_is_object_file_for_target__funptr = NULL
# 
# Checks if a file is a loadable object compiled for requested target.
# 
# \since prior to LTO_API_VERSION=3
cdef _Bool lto_module_is_object_file_for_target(const char * path,const char * target_triple_prefix):
    global _lto_module_is_object_file_for_target__funptr
    if __init_symbol(&_lto_module_is_object_file_for_target__funptr,"lto_module_is_object_file_for_target") > 0:
        pass
    return (<_Bool (*)(const char *,const char *) noexcept nogil> _lto_module_is_object_file_for_target__funptr)(path,target_triple_prefix)


cdef void* _lto_module_has_objc_category__funptr = NULL
# 
# Return true if \p Buffer contains a bitcode file with ObjC code (category
# or class) in it.
# 
# \since LTO_API_VERSION=20
cdef _Bool lto_module_has_objc_category(const void * mem,unsigned long length):
    global _lto_module_has_objc_category__funptr
    if __init_symbol(&_lto_module_has_objc_category__funptr,"lto_module_has_objc_category") > 0:
        pass
    return (<_Bool (*)(const void *,unsigned long) noexcept nogil> _lto_module_has_objc_category__funptr)(mem,length)


cdef void* _lto_module_is_object_file_in_memory__funptr = NULL
# 
# Checks if a buffer is a loadable object file.
# 
# \since prior to LTO_API_VERSION=3
cdef _Bool lto_module_is_object_file_in_memory(const void * mem,unsigned long length):
    global _lto_module_is_object_file_in_memory__funptr
    if __init_symbol(&_lto_module_is_object_file_in_memory__funptr,"lto_module_is_object_file_in_memory") > 0:
        pass
    return (<_Bool (*)(const void *,unsigned long) noexcept nogil> _lto_module_is_object_file_in_memory__funptr)(mem,length)


cdef void* _lto_module_is_object_file_in_memory_for_target__funptr = NULL
# 
# Checks if a buffer is a loadable object compiled for requested target.
# 
# \since prior to LTO_API_VERSION=3
cdef _Bool lto_module_is_object_file_in_memory_for_target(const void * mem,unsigned long length,const char * target_triple_prefix):
    global _lto_module_is_object_file_in_memory_for_target__funptr
    if __init_symbol(&_lto_module_is_object_file_in_memory_for_target__funptr,"lto_module_is_object_file_in_memory_for_target") > 0:
        pass
    return (<_Bool (*)(const void *,unsigned long,const char *) noexcept nogil> _lto_module_is_object_file_in_memory_for_target__funptr)(mem,length,target_triple_prefix)


cdef void* _lto_module_create__funptr = NULL
# 
# Loads an object file from disk.
# Returns NULL on error (check lto_get_error_message() for details).
# 
# \since prior to LTO_API_VERSION=3
cdef lto_module_t lto_module_create(const char * path):
    global _lto_module_create__funptr
    if __init_symbol(&_lto_module_create__funptr,"lto_module_create") > 0:
        pass
    return (<lto_module_t (*)(const char *) noexcept nogil> _lto_module_create__funptr)(path)


cdef void* _lto_module_create_from_memory__funptr = NULL
# 
# Loads an object file from memory.
# Returns NULL on error (check lto_get_error_message() for details).
# 
# \since prior to LTO_API_VERSION=3
cdef lto_module_t lto_module_create_from_memory(const void * mem,unsigned long length):
    global _lto_module_create_from_memory__funptr
    if __init_symbol(&_lto_module_create_from_memory__funptr,"lto_module_create_from_memory") > 0:
        pass
    return (<lto_module_t (*)(const void *,unsigned long) noexcept nogil> _lto_module_create_from_memory__funptr)(mem,length)


cdef void* _lto_module_create_from_memory_with_path__funptr = NULL
# 
# Loads an object file from memory with an extra path argument.
# Returns NULL on error (check lto_get_error_message() for details).
# 
# \since LTO_API_VERSION=9
cdef lto_module_t lto_module_create_from_memory_with_path(const void * mem,unsigned long length,const char * path):
    global _lto_module_create_from_memory_with_path__funptr
    if __init_symbol(&_lto_module_create_from_memory_with_path__funptr,"lto_module_create_from_memory_with_path") > 0:
        pass
    return (<lto_module_t (*)(const void *,unsigned long,const char *) noexcept nogil> _lto_module_create_from_memory_with_path__funptr)(mem,length,path)


cdef void* _lto_module_create_in_local_context__funptr = NULL
# 
# Loads an object file in its own context.
# 
# Loads an object file in its own LLVMContext.  This function call is
# thread-safe.  However, modules created this way should not be merged into an
# lto_code_gen_t using \a lto_codegen_add_module().
# 
# Returns NULL on error (check lto_get_error_message() for details).
# 
# \since LTO_API_VERSION=11
cdef lto_module_t lto_module_create_in_local_context(const void * mem,unsigned long length,const char * path):
    global _lto_module_create_in_local_context__funptr
    if __init_symbol(&_lto_module_create_in_local_context__funptr,"lto_module_create_in_local_context") > 0:
        pass
    return (<lto_module_t (*)(const void *,unsigned long,const char *) noexcept nogil> _lto_module_create_in_local_context__funptr)(mem,length,path)


cdef void* _lto_module_create_in_codegen_context__funptr = NULL
# 
# Loads an object file in the codegen context.
# 
# Loads an object file into the same context as \c cg.  The module is safe to
# add using \a lto_codegen_add_module().
# 
# Returns NULL on error (check lto_get_error_message() for details).
# 
# \since LTO_API_VERSION=11
cdef lto_module_t lto_module_create_in_codegen_context(const void * mem,unsigned long length,const char * path,lto_code_gen_t cg):
    global _lto_module_create_in_codegen_context__funptr
    if __init_symbol(&_lto_module_create_in_codegen_context__funptr,"lto_module_create_in_codegen_context") > 0:
        pass
    return (<lto_module_t (*)(const void *,unsigned long,const char *,lto_code_gen_t) noexcept nogil> _lto_module_create_in_codegen_context__funptr)(mem,length,path,cg)


cdef void* _lto_module_create_from_fd__funptr = NULL
# 
# Loads an object file from disk. The seek point of fd is not preserved.
# Returns NULL on error (check lto_get_error_message() for details).
# 
# \since LTO_API_VERSION=5
cdef lto_module_t lto_module_create_from_fd(int fd,const char * path,unsigned long file_size):
    global _lto_module_create_from_fd__funptr
    if __init_symbol(&_lto_module_create_from_fd__funptr,"lto_module_create_from_fd") > 0:
        pass
    return (<lto_module_t (*)(int,const char *,unsigned long) noexcept nogil> _lto_module_create_from_fd__funptr)(fd,path,file_size)


cdef void* _lto_module_create_from_fd_at_offset__funptr = NULL
# 
# Loads an object file from disk. The seek point of fd is not preserved.
# Returns NULL on error (check lto_get_error_message() for details).
# 
# \since LTO_API_VERSION=5
cdef lto_module_t lto_module_create_from_fd_at_offset(int fd,const char * path,unsigned long file_size,unsigned long map_size,long offset):
    global _lto_module_create_from_fd_at_offset__funptr
    if __init_symbol(&_lto_module_create_from_fd_at_offset__funptr,"lto_module_create_from_fd_at_offset") > 0:
        pass
    return (<lto_module_t (*)(int,const char *,unsigned long,unsigned long,long) noexcept nogil> _lto_module_create_from_fd_at_offset__funptr)(fd,path,file_size,map_size,offset)


cdef void* _lto_module_dispose__funptr = NULL
# 
# Frees all memory internally allocated by the module.
# Upon return the lto_module_t is no longer valid.
# 
# \since prior to LTO_API_VERSION=3
cdef void lto_module_dispose(lto_module_t mod):
    global _lto_module_dispose__funptr
    if __init_symbol(&_lto_module_dispose__funptr,"lto_module_dispose") > 0:
        pass
    (<void (*)(lto_module_t) noexcept nogil> _lto_module_dispose__funptr)(mod)


cdef void* _lto_module_get_target_triple__funptr = NULL
# 
# Returns triple string which the object module was compiled under.
# 
# \since prior to LTO_API_VERSION=3
cdef const char * lto_module_get_target_triple(lto_module_t mod):
    global _lto_module_get_target_triple__funptr
    if __init_symbol(&_lto_module_get_target_triple__funptr,"lto_module_get_target_triple") > 0:
        pass
    return (<const char * (*)(lto_module_t) noexcept nogil> _lto_module_get_target_triple__funptr)(mod)


cdef void* _lto_module_set_target_triple__funptr = NULL
# 
# Sets triple string with which the object will be codegened.
# 
# \since LTO_API_VERSION=4
cdef void lto_module_set_target_triple(lto_module_t mod,const char * triple):
    global _lto_module_set_target_triple__funptr
    if __init_symbol(&_lto_module_set_target_triple__funptr,"lto_module_set_target_triple") > 0:
        pass
    (<void (*)(lto_module_t,const char *) noexcept nogil> _lto_module_set_target_triple__funptr)(mod,triple)


cdef void* _lto_module_get_num_symbols__funptr = NULL
# 
# Returns the number of symbols in the object module.
# 
# \since prior to LTO_API_VERSION=3
cdef unsigned int lto_module_get_num_symbols(lto_module_t mod):
    global _lto_module_get_num_symbols__funptr
    if __init_symbol(&_lto_module_get_num_symbols__funptr,"lto_module_get_num_symbols") > 0:
        pass
    return (<unsigned int (*)(lto_module_t) noexcept nogil> _lto_module_get_num_symbols__funptr)(mod)


cdef void* _lto_module_get_symbol_name__funptr = NULL
# 
# Returns the name of the ith symbol in the object module.
# 
# \since prior to LTO_API_VERSION=3
cdef const char * lto_module_get_symbol_name(lto_module_t mod,unsigned int index):
    global _lto_module_get_symbol_name__funptr
    if __init_symbol(&_lto_module_get_symbol_name__funptr,"lto_module_get_symbol_name") > 0:
        pass
    return (<const char * (*)(lto_module_t,unsigned int) noexcept nogil> _lto_module_get_symbol_name__funptr)(mod,index)


cdef void* _lto_module_get_symbol_attribute__funptr = NULL
# 
# Returns the attributes of the ith symbol in the object module.
# 
# \since prior to LTO_API_VERSION=3
cdef lto_symbol_attributes lto_module_get_symbol_attribute(lto_module_t mod,unsigned int index):
    global _lto_module_get_symbol_attribute__funptr
    if __init_symbol(&_lto_module_get_symbol_attribute__funptr,"lto_module_get_symbol_attribute") > 0:
        pass
    return (<lto_symbol_attributes (*)(lto_module_t,unsigned int) noexcept nogil> _lto_module_get_symbol_attribute__funptr)(mod,index)


cdef void* _lto_module_get_linkeropts__funptr = NULL
# 
# Returns the module's linker options.
# 
# The linker options may consist of multiple flags. It is the linker's
# responsibility to split the flags using a platform-specific mechanism.
# 
# \since LTO_API_VERSION=16
cdef const char * lto_module_get_linkeropts(lto_module_t mod):
    global _lto_module_get_linkeropts__funptr
    if __init_symbol(&_lto_module_get_linkeropts__funptr,"lto_module_get_linkeropts") > 0:
        pass
    return (<const char * (*)(lto_module_t) noexcept nogil> _lto_module_get_linkeropts__funptr)(mod)


cdef void* _lto_module_get_macho_cputype__funptr = NULL
# 
# If targeting mach-o on darwin, this function gets the CPU type and subtype
# that will end up being encoded in the mach-o header. These are the values
# that can be found in mach/machine.h.
# 
# \p out_cputype and \p out_cpusubtype must be non-NULL.
# 
# Returns true on error (check lto_get_error_message() for details).
# 
# \since LTO_API_VERSION=27
cdef _Bool lto_module_get_macho_cputype(lto_module_t mod,unsigned int * out_cputype,unsigned int * out_cpusubtype):
    global _lto_module_get_macho_cputype__funptr
    if __init_symbol(&_lto_module_get_macho_cputype__funptr,"lto_module_get_macho_cputype") > 0:
        pass
    return (<_Bool (*)(lto_module_t,unsigned int *,unsigned int *) noexcept nogil> _lto_module_get_macho_cputype__funptr)(mod,out_cputype,out_cpusubtype)


cdef void* _lto_module_has_ctor_dtor__funptr = NULL
# 
# This function can be used by the linker to check if a given module has
# any constructor or destructor functions.
# 
# Returns true if the module has either the @llvm.global_ctors or the
# @llvm.global_dtors symbol. Otherwise returns false.
# 
# \since LTO_API_VERSION=29
cdef _Bool lto_module_has_ctor_dtor(lto_module_t mod):
    global _lto_module_has_ctor_dtor__funptr
    if __init_symbol(&_lto_module_has_ctor_dtor__funptr,"lto_module_has_ctor_dtor") > 0:
        pass
    return (<_Bool (*)(lto_module_t) noexcept nogil> _lto_module_has_ctor_dtor__funptr)(mod)


cdef void* _lto_codegen_set_diagnostic_handler__funptr = NULL
# 
# Set a diagnostic handler and the related context (void *).
# This is more general than lto_get_error_message, as the diagnostic handler
# can be called at anytime within lto.
# 
# \since LTO_API_VERSION=7
cdef void lto_codegen_set_diagnostic_handler(lto_code_gen_t arg0,lto_diagnostic_handler_t arg1,void * arg2):
    global _lto_codegen_set_diagnostic_handler__funptr
    if __init_symbol(&_lto_codegen_set_diagnostic_handler__funptr,"lto_codegen_set_diagnostic_handler") > 0:
        pass
    (<void (*)(lto_code_gen_t,lto_diagnostic_handler_t,void *) noexcept nogil> _lto_codegen_set_diagnostic_handler__funptr)(arg0,arg1,arg2)


cdef void* _lto_codegen_create__funptr = NULL
# 
# Instantiates a code generator.
# Returns NULL on error (check lto_get_error_message() for details).
# 
# All modules added using \a lto_codegen_add_module() must have been created
# in the same context as the codegen.
# 
# \since prior to LTO_API_VERSION=3
cdef lto_code_gen_t lto_codegen_create():
    global _lto_codegen_create__funptr
    if __init_symbol(&_lto_codegen_create__funptr,"lto_codegen_create") > 0:
        pass
    return (<lto_code_gen_t (*)() noexcept nogil> _lto_codegen_create__funptr)()


cdef void* _lto_codegen_create_in_local_context__funptr = NULL
# 
# Instantiate a code generator in its own context.
# 
# Instantiates a code generator in its own context.  Modules added via \a
# lto_codegen_add_module() must have all been created in the same context,
# using \a lto_module_create_in_codegen_context().
# 
# \since LTO_API_VERSION=11
cdef lto_code_gen_t lto_codegen_create_in_local_context():
    global _lto_codegen_create_in_local_context__funptr
    if __init_symbol(&_lto_codegen_create_in_local_context__funptr,"lto_codegen_create_in_local_context") > 0:
        pass
    return (<lto_code_gen_t (*)() noexcept nogil> _lto_codegen_create_in_local_context__funptr)()


cdef void* _lto_codegen_dispose__funptr = NULL
# 
# Frees all code generator and all memory it internally allocated.
# Upon return the lto_code_gen_t is no longer valid.
# 
# \since prior to LTO_API_VERSION=3
cdef void lto_codegen_dispose(lto_code_gen_t arg0):
    global _lto_codegen_dispose__funptr
    if __init_symbol(&_lto_codegen_dispose__funptr,"lto_codegen_dispose") > 0:
        pass
    (<void (*)(lto_code_gen_t) noexcept nogil> _lto_codegen_dispose__funptr)(arg0)


cdef void* _lto_codegen_add_module__funptr = NULL
# 
# Add an object module to the set of modules for which code will be generated.
# Returns true on error (check lto_get_error_message() for details).
# 
# \c cg and \c mod must both be in the same context.  See \a
# lto_codegen_create_in_local_context() and \a
# lto_module_create_in_codegen_context().
# 
# \since prior to LTO_API_VERSION=3
cdef _Bool lto_codegen_add_module(lto_code_gen_t cg,lto_module_t mod):
    global _lto_codegen_add_module__funptr
    if __init_symbol(&_lto_codegen_add_module__funptr,"lto_codegen_add_module") > 0:
        pass
    return (<_Bool (*)(lto_code_gen_t,lto_module_t) noexcept nogil> _lto_codegen_add_module__funptr)(cg,mod)


cdef void* _lto_codegen_set_module__funptr = NULL
# 
# Sets the object module for code generation. This will transfer the ownership
# of the module to the code generator.
# 
# \c cg and \c mod must both be in the same context.
# 
# \since LTO_API_VERSION=13
cdef void lto_codegen_set_module(lto_code_gen_t cg,lto_module_t mod):
    global _lto_codegen_set_module__funptr
    if __init_symbol(&_lto_codegen_set_module__funptr,"lto_codegen_set_module") > 0:
        pass
    (<void (*)(lto_code_gen_t,lto_module_t) noexcept nogil> _lto_codegen_set_module__funptr)(cg,mod)


cdef void* _lto_codegen_set_debug_model__funptr = NULL
# 
# Sets if debug info should be generated.
# Returns true on error (check lto_get_error_message() for details).
# 
# \since prior to LTO_API_VERSION=3
cdef _Bool lto_codegen_set_debug_model(lto_code_gen_t cg,lto_debug_model arg1):
    global _lto_codegen_set_debug_model__funptr
    if __init_symbol(&_lto_codegen_set_debug_model__funptr,"lto_codegen_set_debug_model") > 0:
        pass
    return (<_Bool (*)(lto_code_gen_t,lto_debug_model) noexcept nogil> _lto_codegen_set_debug_model__funptr)(cg,arg1)


cdef void* _lto_codegen_set_pic_model__funptr = NULL
# 
# Sets which PIC code model to generated.
# Returns true on error (check lto_get_error_message() for details).
# 
# \since prior to LTO_API_VERSION=3
cdef _Bool lto_codegen_set_pic_model(lto_code_gen_t cg,lto_codegen_model arg1):
    global _lto_codegen_set_pic_model__funptr
    if __init_symbol(&_lto_codegen_set_pic_model__funptr,"lto_codegen_set_pic_model") > 0:
        pass
    return (<_Bool (*)(lto_code_gen_t,lto_codegen_model) noexcept nogil> _lto_codegen_set_pic_model__funptr)(cg,arg1)


cdef void* _lto_codegen_set_cpu__funptr = NULL
# 
# Sets the cpu to generate code for.
# 
# \since LTO_API_VERSION=4
cdef void lto_codegen_set_cpu(lto_code_gen_t cg,const char * cpu):
    global _lto_codegen_set_cpu__funptr
    if __init_symbol(&_lto_codegen_set_cpu__funptr,"lto_codegen_set_cpu") > 0:
        pass
    (<void (*)(lto_code_gen_t,const char *) noexcept nogil> _lto_codegen_set_cpu__funptr)(cg,cpu)


cdef void* _lto_codegen_set_assembler_path__funptr = NULL
# 
# Sets the location of the assembler tool to run. If not set, libLTO
# will use gcc to invoke the assembler.
# 
# \since LTO_API_VERSION=3
cdef void lto_codegen_set_assembler_path(lto_code_gen_t cg,const char * path):
    global _lto_codegen_set_assembler_path__funptr
    if __init_symbol(&_lto_codegen_set_assembler_path__funptr,"lto_codegen_set_assembler_path") > 0:
        pass
    (<void (*)(lto_code_gen_t,const char *) noexcept nogil> _lto_codegen_set_assembler_path__funptr)(cg,path)


cdef void* _lto_codegen_set_assembler_args__funptr = NULL
# 
# Sets extra arguments that libLTO should pass to the assembler.
# 
# \since LTO_API_VERSION=4
cdef void lto_codegen_set_assembler_args(lto_code_gen_t cg,const char ** args,int nargs):
    global _lto_codegen_set_assembler_args__funptr
    if __init_symbol(&_lto_codegen_set_assembler_args__funptr,"lto_codegen_set_assembler_args") > 0:
        pass
    (<void (*)(lto_code_gen_t,const char **,int) noexcept nogil> _lto_codegen_set_assembler_args__funptr)(cg,args,nargs)


cdef void* _lto_codegen_add_must_preserve_symbol__funptr = NULL
# 
# Adds to a list of all global symbols that must exist in the final generated
# code. If a function is not listed there, it might be inlined into every usage
# and optimized away.
# 
# \since prior to LTO_API_VERSION=3
cdef void lto_codegen_add_must_preserve_symbol(lto_code_gen_t cg,const char * symbol):
    global _lto_codegen_add_must_preserve_symbol__funptr
    if __init_symbol(&_lto_codegen_add_must_preserve_symbol__funptr,"lto_codegen_add_must_preserve_symbol") > 0:
        pass
    (<void (*)(lto_code_gen_t,const char *) noexcept nogil> _lto_codegen_add_must_preserve_symbol__funptr)(cg,symbol)


cdef void* _lto_codegen_write_merged_modules__funptr = NULL
# 
# Writes a new object file at the specified path that contains the
# merged contents of all modules added so far.
# Returns true on error (check lto_get_error_message() for details).
# 
# \since LTO_API_VERSION=5
cdef _Bool lto_codegen_write_merged_modules(lto_code_gen_t cg,const char * path):
    global _lto_codegen_write_merged_modules__funptr
    if __init_symbol(&_lto_codegen_write_merged_modules__funptr,"lto_codegen_write_merged_modules") > 0:
        pass
    return (<_Bool (*)(lto_code_gen_t,const char *) noexcept nogil> _lto_codegen_write_merged_modules__funptr)(cg,path)


cdef void* _lto_codegen_compile__funptr = NULL
# 
# Generates code for all added modules into one native object file.
# This calls lto_codegen_optimize then lto_codegen_compile_optimized.
# 
# On success returns a pointer to a generated mach-o/ELF buffer and
# length set to the buffer size.  The buffer is owned by the
# lto_code_gen_t and will be freed when lto_codegen_dispose()
# is called, or lto_codegen_compile() is called again.
# On failure, returns NULL (check lto_get_error_message() for details).
# 
# \since prior to LTO_API_VERSION=3
cdef const void * lto_codegen_compile(lto_code_gen_t cg,unsigned long * length):
    global _lto_codegen_compile__funptr
    if __init_symbol(&_lto_codegen_compile__funptr,"lto_codegen_compile") > 0:
        pass
    return (<const void * (*)(lto_code_gen_t,unsigned long *) noexcept nogil> _lto_codegen_compile__funptr)(cg,length)


cdef void* _lto_codegen_compile_to_file__funptr = NULL
# 
# Generates code for all added modules into one native object file.
# This calls lto_codegen_optimize then lto_codegen_compile_optimized (instead
# of returning a generated mach-o/ELF buffer, it writes to a file).
# 
# The name of the file is written to name. Returns true on error.
# 
# \since LTO_API_VERSION=5
cdef _Bool lto_codegen_compile_to_file(lto_code_gen_t cg,const char ** name):
    global _lto_codegen_compile_to_file__funptr
    if __init_symbol(&_lto_codegen_compile_to_file__funptr,"lto_codegen_compile_to_file") > 0:
        pass
    return (<_Bool (*)(lto_code_gen_t,const char **) noexcept nogil> _lto_codegen_compile_to_file__funptr)(cg,name)


cdef void* _lto_codegen_optimize__funptr = NULL
# 
# Runs optimization for the merged module. Returns true on error.
# 
# \since LTO_API_VERSION=12
cdef _Bool lto_codegen_optimize(lto_code_gen_t cg):
    global _lto_codegen_optimize__funptr
    if __init_symbol(&_lto_codegen_optimize__funptr,"lto_codegen_optimize") > 0:
        pass
    return (<_Bool (*)(lto_code_gen_t) noexcept nogil> _lto_codegen_optimize__funptr)(cg)


cdef void* _lto_codegen_compile_optimized__funptr = NULL
# 
# Generates code for the optimized merged module into one native object file.
# It will not run any IR optimizations on the merged module.
# 
# On success returns a pointer to a generated mach-o/ELF buffer and length set
# to the buffer size.  The buffer is owned by the lto_code_gen_t and will be
# freed when lto_codegen_dispose() is called, or
# lto_codegen_compile_optimized() is called again. On failure, returns NULL
# (check lto_get_error_message() for details).
# 
# \since LTO_API_VERSION=12
cdef const void * lto_codegen_compile_optimized(lto_code_gen_t cg,unsigned long * length):
    global _lto_codegen_compile_optimized__funptr
    if __init_symbol(&_lto_codegen_compile_optimized__funptr,"lto_codegen_compile_optimized") > 0:
        pass
    return (<const void * (*)(lto_code_gen_t,unsigned long *) noexcept nogil> _lto_codegen_compile_optimized__funptr)(cg,length)


cdef void* _lto_api_version__funptr = NULL
# 
# Returns the runtime API version.
# 
# \since LTO_API_VERSION=12
cdef unsigned int lto_api_version():
    global _lto_api_version__funptr
    if __init_symbol(&_lto_api_version__funptr,"lto_api_version") > 0:
        pass
    return (<unsigned int (*)() noexcept nogil> _lto_api_version__funptr)()


cdef void* _lto_set_debug_options__funptr = NULL
# 
# Parses options immediately, making them available as early as possible. For
# example during executing codegen::InitTargetOptionsFromCodeGenFlags. Since
# parsing shud only happen once, only one of lto_codegen_debug_options or
# lto_set_debug_options should be called.
# 
# This function takes one or more options separated by spaces.
# Warning: passing file paths through this function may confuse the argument
# parser if the paths contain spaces.
# 
# \since LTO_API_VERSION=28
cdef void lto_set_debug_options(const char *const * options,int number):
    global _lto_set_debug_options__funptr
    if __init_symbol(&_lto_set_debug_options__funptr,"lto_set_debug_options") > 0:
        pass
    (<void (*)(const char *const *,int) noexcept nogil> _lto_set_debug_options__funptr)(options,number)


cdef void* _lto_codegen_debug_options__funptr = NULL
# 
# Sets options to help debug codegen bugs. Since parsing shud only happen once,
# only one of lto_codegen_debug_options or lto_set_debug_options
# should be called.
# 
# This function takes one or more options separated by spaces.
# Warning: passing file paths through this function may confuse the argument
# parser if the paths contain spaces.
# 
# \since prior to LTO_API_VERSION=3
cdef void lto_codegen_debug_options(lto_code_gen_t cg,const char * arg1):
    global _lto_codegen_debug_options__funptr
    if __init_symbol(&_lto_codegen_debug_options__funptr,"lto_codegen_debug_options") > 0:
        pass
    (<void (*)(lto_code_gen_t,const char *) noexcept nogil> _lto_codegen_debug_options__funptr)(cg,arg1)


cdef void* _lto_codegen_debug_options_array__funptr = NULL
# 
# Same as the previous function, but takes every option separately through an
# array.
# 
# \since prior to LTO_API_VERSION=26
cdef void lto_codegen_debug_options_array(lto_code_gen_t cg,const char *const * arg1,int number):
    global _lto_codegen_debug_options_array__funptr
    if __init_symbol(&_lto_codegen_debug_options_array__funptr,"lto_codegen_debug_options_array") > 0:
        pass
    (<void (*)(lto_code_gen_t,const char *const *,int) noexcept nogil> _lto_codegen_debug_options_array__funptr)(cg,arg1,number)


cdef void* _lto_initialize_disassembler__funptr = NULL
# 
# Initializes LLVM disassemblers.
# FIXME: This doesn't really belong here.
# 
# \since LTO_API_VERSION=5
cdef void lto_initialize_disassembler():
    global _lto_initialize_disassembler__funptr
    if __init_symbol(&_lto_initialize_disassembler__funptr,"lto_initialize_disassembler") > 0:
        pass
    (<void (*)() noexcept nogil> _lto_initialize_disassembler__funptr)()


cdef void* _lto_codegen_set_should_internalize__funptr = NULL
# 
# Sets if we should run internalize pass during optimization and code
# generation.
# 
# \since LTO_API_VERSION=14
cdef void lto_codegen_set_should_internalize(lto_code_gen_t cg,_Bool ShouldInternalize):
    global _lto_codegen_set_should_internalize__funptr
    if __init_symbol(&_lto_codegen_set_should_internalize__funptr,"lto_codegen_set_should_internalize") > 0:
        pass
    (<void (*)(lto_code_gen_t,_Bool) noexcept nogil> _lto_codegen_set_should_internalize__funptr)(cg,ShouldInternalize)


cdef void* _lto_codegen_set_should_embed_uselists__funptr = NULL
# 
# Set whether to embed uselists in bitcode.
# 
# Sets whether \a lto_codegen_write_merged_modules() should embed uselists in
# output bitcode.  This should be turned on for all -save-temps output.
# 
# \since LTO_API_VERSION=15
cdef void lto_codegen_set_should_embed_uselists(lto_code_gen_t cg,_Bool ShouldEmbedUselists):
    global _lto_codegen_set_should_embed_uselists__funptr
    if __init_symbol(&_lto_codegen_set_should_embed_uselists__funptr,"lto_codegen_set_should_embed_uselists") > 0:
        pass
    (<void (*)(lto_code_gen_t,_Bool) noexcept nogil> _lto_codegen_set_should_embed_uselists__funptr)(cg,ShouldEmbedUselists)


cdef void* _lto_input_create__funptr = NULL
# 
# Creates an LTO input file from a buffer. The path
# argument is used for diagnotics as this function
# otherwise does not know which file the given buffer
# is associated with.
# 
# \since LTO_API_VERSION=24
cdef lto_input_t lto_input_create(const void * buffer,unsigned long buffer_size,const char * path):
    global _lto_input_create__funptr
    if __init_symbol(&_lto_input_create__funptr,"lto_input_create") > 0:
        pass
    return (<lto_input_t (*)(const void *,unsigned long,const char *) noexcept nogil> _lto_input_create__funptr)(buffer,buffer_size,path)


cdef void* _lto_input_dispose__funptr = NULL
# 
# Frees all memory internally allocated by the LTO input file.
# Upon return the lto_module_t is no longer valid.
# 
# \since LTO_API_VERSION=24
cdef void lto_input_dispose(lto_input_t input):
    global _lto_input_dispose__funptr
    if __init_symbol(&_lto_input_dispose__funptr,"lto_input_dispose") > 0:
        pass
    (<void (*)(lto_input_t) noexcept nogil> _lto_input_dispose__funptr)(input)


cdef void* _lto_input_get_num_dependent_libraries__funptr = NULL
# 
# Returns the number of dependent library specifiers
# for the given LTO input file.
# 
# \since LTO_API_VERSION=24
cdef unsigned int lto_input_get_num_dependent_libraries(lto_input_t input):
    global _lto_input_get_num_dependent_libraries__funptr
    if __init_symbol(&_lto_input_get_num_dependent_libraries__funptr,"lto_input_get_num_dependent_libraries") > 0:
        pass
    return (<unsigned int (*)(lto_input_t) noexcept nogil> _lto_input_get_num_dependent_libraries__funptr)(input)


cdef void* _lto_input_get_dependent_library__funptr = NULL
# 
# Returns the ith dependent library specifier
# for the given LTO input file. The returned
# string is not null-terminated.
# 
# \since LTO_API_VERSION=24
cdef const char * lto_input_get_dependent_library(lto_input_t input,unsigned long index,unsigned long * size):
    global _lto_input_get_dependent_library__funptr
    if __init_symbol(&_lto_input_get_dependent_library__funptr,"lto_input_get_dependent_library") > 0:
        pass
    return (<const char * (*)(lto_input_t,unsigned long,unsigned long *) noexcept nogil> _lto_input_get_dependent_library__funptr)(input,index,size)


cdef void* _lto_runtime_lib_symbols_list__funptr = NULL
# 
# Returns the list of libcall symbols that can be generated by LTO
# that might not be visible from the symbol table of bitcode files.
# 
# \since prior to LTO_API_VERSION=25
cdef const char *const * lto_runtime_lib_symbols_list(unsigned long * size):
    global _lto_runtime_lib_symbols_list__funptr
    if __init_symbol(&_lto_runtime_lib_symbols_list__funptr,"lto_runtime_lib_symbols_list") > 0:
        pass
    return (<const char *const * (*)(unsigned long *) noexcept nogil> _lto_runtime_lib_symbols_list__funptr)(size)


cdef void* _thinlto_create_codegen__funptr = NULL
# 
# Instantiates a ThinLTO code generator.
# Returns NULL on error (check lto_get_error_message() for details).
# 
# 
# The ThinLTOCodeGenerator is not intended to be reuse for multiple
# compilation: the model is that the client adds modules to the generator and
# ask to perform the ThinLTO optimizations / codegen, and finally destroys the
# codegenerator.
# 
# \since LTO_API_VERSION=18
cdef thinlto_code_gen_t thinlto_create_codegen():
    global _thinlto_create_codegen__funptr
    if __init_symbol(&_thinlto_create_codegen__funptr,"thinlto_create_codegen") > 0:
        pass
    return (<thinlto_code_gen_t (*)() noexcept nogil> _thinlto_create_codegen__funptr)()


cdef void* _thinlto_codegen_dispose__funptr = NULL
# 
# Frees the generator and all memory it internally allocated.
# Upon return the thinlto_code_gen_t is no longer valid.
# 
# \since LTO_API_VERSION=18
cdef void thinlto_codegen_dispose(thinlto_code_gen_t cg):
    global _thinlto_codegen_dispose__funptr
    if __init_symbol(&_thinlto_codegen_dispose__funptr,"thinlto_codegen_dispose") > 0:
        pass
    (<void (*)(thinlto_code_gen_t) noexcept nogil> _thinlto_codegen_dispose__funptr)(cg)


cdef void* _thinlto_codegen_add_module__funptr = NULL
# 
# Add a module to a ThinLTO code generator. Identifier has to be unique among
# all the modules in a code generator. The data buffer stays owned by the
# client, and is expected to be available for the entire lifetime of the
# thinlto_code_gen_t it is added to.
# 
# On failure, returns NULL (check lto_get_error_message() for details).
# 
# 
# \since LTO_API_VERSION=18
cdef void thinlto_codegen_add_module(thinlto_code_gen_t cg,const char * identifier,const char * data,int length):
    global _thinlto_codegen_add_module__funptr
    if __init_symbol(&_thinlto_codegen_add_module__funptr,"thinlto_codegen_add_module") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,const char *,const char *,int) noexcept nogil> _thinlto_codegen_add_module__funptr)(cg,identifier,data,length)


cdef void* _thinlto_codegen_process__funptr = NULL
# 
# Optimize and codegen all the modules added to the codegenerator using
# ThinLTO. Resulting objects are accessible using thinlto_module_get_object().
# 
# \since LTO_API_VERSION=18
cdef void thinlto_codegen_process(thinlto_code_gen_t cg):
    global _thinlto_codegen_process__funptr
    if __init_symbol(&_thinlto_codegen_process__funptr,"thinlto_codegen_process") > 0:
        pass
    (<void (*)(thinlto_code_gen_t) noexcept nogil> _thinlto_codegen_process__funptr)(cg)


cdef void* _thinlto_module_get_num_objects__funptr = NULL
# 
# Returns the number of object files produced by the ThinLTO CodeGenerator.
# 
# It usually matches the number of input files, but this is not a guarantee of
# the API and may change in future implementation, so the client should not
# assume it.
# 
# \since LTO_API_VERSION=18
cdef unsigned int thinlto_module_get_num_objects(thinlto_code_gen_t cg):
    global _thinlto_module_get_num_objects__funptr
    if __init_symbol(&_thinlto_module_get_num_objects__funptr,"thinlto_module_get_num_objects") > 0:
        pass
    return (<unsigned int (*)(thinlto_code_gen_t) noexcept nogil> _thinlto_module_get_num_objects__funptr)(cg)


cdef void* _thinlto_module_get_object__funptr = NULL
# 
# Returns a reference to the ith object file produced by the ThinLTO
# CodeGenerator.
# 
# Client should use \p thinlto_module_get_num_objects() to get the number of
# available objects.
# 
# \since LTO_API_VERSION=18
cdef LTOObjectBuffer thinlto_module_get_object(thinlto_code_gen_t cg,unsigned int index):
    global _thinlto_module_get_object__funptr
    if __init_symbol(&_thinlto_module_get_object__funptr,"thinlto_module_get_object") > 0:
        pass
    return (<LTOObjectBuffer (*)(thinlto_code_gen_t,unsigned int) noexcept nogil> _thinlto_module_get_object__funptr)(cg,index)


cdef void* _thinlto_module_get_num_object_files__funptr = NULL
# 
# Returns the number of object files produced by the ThinLTO CodeGenerator.
# 
# It usually matches the number of input files, but this is not a guarantee of
# the API and may change in future implementation, so the client should not
# assume it.
# 
# \since LTO_API_VERSION=21
cdef unsigned int thinlto_module_get_num_object_files(thinlto_code_gen_t cg):
    global _thinlto_module_get_num_object_files__funptr
    if __init_symbol(&_thinlto_module_get_num_object_files__funptr,"thinlto_module_get_num_object_files") > 0:
        pass
    return (<unsigned int (*)(thinlto_code_gen_t) noexcept nogil> _thinlto_module_get_num_object_files__funptr)(cg)


cdef void* _thinlto_module_get_object_file__funptr = NULL
# 
# Returns the path to the ith object file produced by the ThinLTO
# CodeGenerator.
# 
# Client should use \p thinlto_module_get_num_object_files() to get the number
# of available objects.
# 
# \since LTO_API_VERSION=21
cdef const char * thinlto_module_get_object_file(thinlto_code_gen_t cg,unsigned int index):
    global _thinlto_module_get_object_file__funptr
    if __init_symbol(&_thinlto_module_get_object_file__funptr,"thinlto_module_get_object_file") > 0:
        pass
    return (<const char * (*)(thinlto_code_gen_t,unsigned int) noexcept nogil> _thinlto_module_get_object_file__funptr)(cg,index)


cdef void* _thinlto_codegen_set_pic_model__funptr = NULL
# 
# Sets which PIC code model to generate.
# Returns true on error (check lto_get_error_message() for details).
# 
# \since LTO_API_VERSION=18
cdef _Bool thinlto_codegen_set_pic_model(thinlto_code_gen_t cg,lto_codegen_model arg1):
    global _thinlto_codegen_set_pic_model__funptr
    if __init_symbol(&_thinlto_codegen_set_pic_model__funptr,"thinlto_codegen_set_pic_model") > 0:
        pass
    return (<_Bool (*)(thinlto_code_gen_t,lto_codegen_model) noexcept nogil> _thinlto_codegen_set_pic_model__funptr)(cg,arg1)


cdef void* _thinlto_codegen_set_savetemps_dir__funptr = NULL
# 
# Sets the path to a directory to use as a storage for temporary bitcode files.
# The intention is to make the bitcode files available for debugging at various
# stage of the pipeline.
# 
# \since LTO_API_VERSION=18
cdef void thinlto_codegen_set_savetemps_dir(thinlto_code_gen_t cg,const char * save_temps_dir):
    global _thinlto_codegen_set_savetemps_dir__funptr
    if __init_symbol(&_thinlto_codegen_set_savetemps_dir__funptr,"thinlto_codegen_set_savetemps_dir") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,const char *) noexcept nogil> _thinlto_codegen_set_savetemps_dir__funptr)(cg,save_temps_dir)


cdef void* _thinlto_set_generated_objects_dir__funptr = NULL
# 
# Set the path to a directory where to save generated object files. This
# path can be used by a linker to request on-disk files instead of in-memory
# buffers. When set, results are available through
# thinlto_module_get_object_file() instead of thinlto_module_get_object().
# 
# \since LTO_API_VERSION=21
cdef void thinlto_set_generated_objects_dir(thinlto_code_gen_t cg,const char * save_temps_dir):
    global _thinlto_set_generated_objects_dir__funptr
    if __init_symbol(&_thinlto_set_generated_objects_dir__funptr,"thinlto_set_generated_objects_dir") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,const char *) noexcept nogil> _thinlto_set_generated_objects_dir__funptr)(cg,save_temps_dir)


cdef void* _thinlto_codegen_set_cpu__funptr = NULL
# 
# Sets the cpu to generate code for.
# 
# \since LTO_API_VERSION=18
cdef void thinlto_codegen_set_cpu(thinlto_code_gen_t cg,const char * cpu):
    global _thinlto_codegen_set_cpu__funptr
    if __init_symbol(&_thinlto_codegen_set_cpu__funptr,"thinlto_codegen_set_cpu") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,const char *) noexcept nogil> _thinlto_codegen_set_cpu__funptr)(cg,cpu)


cdef void* _thinlto_codegen_disable_codegen__funptr = NULL
# 
# Disable CodeGen, only run the stages till codegen and stop. The output will
# be bitcode.
# 
# \since LTO_API_VERSION=19
cdef void thinlto_codegen_disable_codegen(thinlto_code_gen_t cg,_Bool disable):
    global _thinlto_codegen_disable_codegen__funptr
    if __init_symbol(&_thinlto_codegen_disable_codegen__funptr,"thinlto_codegen_disable_codegen") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,_Bool) noexcept nogil> _thinlto_codegen_disable_codegen__funptr)(cg,disable)


cdef void* _thinlto_codegen_set_codegen_only__funptr = NULL
# 
# Perform CodeGen only: disable all other stages.
# 
# \since LTO_API_VERSION=19
cdef void thinlto_codegen_set_codegen_only(thinlto_code_gen_t cg,_Bool codegen_only):
    global _thinlto_codegen_set_codegen_only__funptr
    if __init_symbol(&_thinlto_codegen_set_codegen_only__funptr,"thinlto_codegen_set_codegen_only") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,_Bool) noexcept nogil> _thinlto_codegen_set_codegen_only__funptr)(cg,codegen_only)


cdef void* _thinlto_debug_options__funptr = NULL
# 
# Parse -mllvm style debug options.
# 
# \since LTO_API_VERSION=18
cdef void thinlto_debug_options(const char *const * options,int number):
    global _thinlto_debug_options__funptr
    if __init_symbol(&_thinlto_debug_options__funptr,"thinlto_debug_options") > 0:
        pass
    (<void (*)(const char *const *,int) noexcept nogil> _thinlto_debug_options__funptr)(options,number)


cdef void* _lto_module_is_thinlto__funptr = NULL
# 
# Test if a module has support for ThinLTO linking.
# 
# \since LTO_API_VERSION=18
cdef _Bool lto_module_is_thinlto(lto_module_t mod):
    global _lto_module_is_thinlto__funptr
    if __init_symbol(&_lto_module_is_thinlto__funptr,"lto_module_is_thinlto") > 0:
        pass
    return (<_Bool (*)(lto_module_t) noexcept nogil> _lto_module_is_thinlto__funptr)(mod)


cdef void* _thinlto_codegen_add_must_preserve_symbol__funptr = NULL
# 
# Adds a symbol to the list of global symbols that must exist in the final
# generated code. If a function is not listed there, it might be inlined into
# every usage and optimized away. For every single module, the functions
# referenced from code outside of the ThinLTO modules need to be added here.
# 
# \since LTO_API_VERSION=18
cdef void thinlto_codegen_add_must_preserve_symbol(thinlto_code_gen_t cg,const char * name,int length):
    global _thinlto_codegen_add_must_preserve_symbol__funptr
    if __init_symbol(&_thinlto_codegen_add_must_preserve_symbol__funptr,"thinlto_codegen_add_must_preserve_symbol") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,const char *,int) noexcept nogil> _thinlto_codegen_add_must_preserve_symbol__funptr)(cg,name,length)


cdef void* _thinlto_codegen_add_cross_referenced_symbol__funptr = NULL
# 
# Adds a symbol to the list of global symbols that are cross-referenced between
# ThinLTO files. If the ThinLTO CodeGenerator can ensure that every
# references from a ThinLTO module to this symbol is optimized away, then
# the symbol can be discarded.
# 
# \since LTO_API_VERSION=18
cdef void thinlto_codegen_add_cross_referenced_symbol(thinlto_code_gen_t cg,const char * name,int length):
    global _thinlto_codegen_add_cross_referenced_symbol__funptr
    if __init_symbol(&_thinlto_codegen_add_cross_referenced_symbol__funptr,"thinlto_codegen_add_cross_referenced_symbol") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,const char *,int) noexcept nogil> _thinlto_codegen_add_cross_referenced_symbol__funptr)(cg,name,length)


cdef void* _thinlto_codegen_set_cache_dir__funptr = NULL
# 
# Sets the path to a directory to use as a cache storage for incremental build.
# Setting this activates caching.
# 
# \since LTO_API_VERSION=18
cdef void thinlto_codegen_set_cache_dir(thinlto_code_gen_t cg,const char * cache_dir):
    global _thinlto_codegen_set_cache_dir__funptr
    if __init_symbol(&_thinlto_codegen_set_cache_dir__funptr,"thinlto_codegen_set_cache_dir") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,const char *) noexcept nogil> _thinlto_codegen_set_cache_dir__funptr)(cg,cache_dir)


cdef void* _thinlto_codegen_set_cache_pruning_interval__funptr = NULL
# 
# Sets the cache pruning interval (in seconds). A negative value disables the
# pruning. An unspecified default value will be applied, and a value of 0 will
# force prunning to occur.
# 
# \since LTO_API_VERSION=18
cdef void thinlto_codegen_set_cache_pruning_interval(thinlto_code_gen_t cg,int interval):
    global _thinlto_codegen_set_cache_pruning_interval__funptr
    if __init_symbol(&_thinlto_codegen_set_cache_pruning_interval__funptr,"thinlto_codegen_set_cache_pruning_interval") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,int) noexcept nogil> _thinlto_codegen_set_cache_pruning_interval__funptr)(cg,interval)


cdef void* _thinlto_codegen_set_final_cache_size_relative_to_available_space__funptr = NULL
# 
# Sets the maximum cache size that can be persistent across build, in terms of
# percentage of the available space on the disk. Set to 100 to indicate
# no limit, 50 to indicate that the cache size will not be left over half the
# available space. A value over 100 will be reduced to 100, a value of 0 will
# be ignored. An unspecified default value will be applied.
# 
# The formula looks like:
#  AvailableSpace = FreeSpace + ExistingCacheSize
#  NewCacheSize = AvailableSpace * P/100
# 
# \since LTO_API_VERSION=18
cdef void thinlto_codegen_set_final_cache_size_relative_to_available_space(thinlto_code_gen_t cg,unsigned int percentage):
    global _thinlto_codegen_set_final_cache_size_relative_to_available_space__funptr
    if __init_symbol(&_thinlto_codegen_set_final_cache_size_relative_to_available_space__funptr,"thinlto_codegen_set_final_cache_size_relative_to_available_space") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,unsigned int) noexcept nogil> _thinlto_codegen_set_final_cache_size_relative_to_available_space__funptr)(cg,percentage)


cdef void* _thinlto_codegen_set_cache_entry_expiration__funptr = NULL
# 
# Sets the expiration (in seconds) for an entry in the cache. An unspecified
# default value will be applied. A value of 0 will be ignored.
# 
# \since LTO_API_VERSION=18
cdef void thinlto_codegen_set_cache_entry_expiration(thinlto_code_gen_t cg,unsigned int expiration):
    global _thinlto_codegen_set_cache_entry_expiration__funptr
    if __init_symbol(&_thinlto_codegen_set_cache_entry_expiration__funptr,"thinlto_codegen_set_cache_entry_expiration") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,unsigned int) noexcept nogil> _thinlto_codegen_set_cache_entry_expiration__funptr)(cg,expiration)


cdef void* _thinlto_codegen_set_cache_size_bytes__funptr = NULL
# 
# Sets the maximum size of the cache directory (in bytes). A value over the
# amount of available space on the disk will be reduced to the amount of
# available space. An unspecified default value will be applied. A value of 0
# will be ignored.
# 
# \since LTO_API_VERSION=22
cdef void thinlto_codegen_set_cache_size_bytes(thinlto_code_gen_t cg,unsigned int max_size_bytes):
    global _thinlto_codegen_set_cache_size_bytes__funptr
    if __init_symbol(&_thinlto_codegen_set_cache_size_bytes__funptr,"thinlto_codegen_set_cache_size_bytes") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,unsigned int) noexcept nogil> _thinlto_codegen_set_cache_size_bytes__funptr)(cg,max_size_bytes)


cdef void* _thinlto_codegen_set_cache_size_megabytes__funptr = NULL
# 
# Same as thinlto_codegen_set_cache_size_bytes, except the maximum size is in
# megabytes (2^20 bytes).
# 
# \since LTO_API_VERSION=23
cdef void thinlto_codegen_set_cache_size_megabytes(thinlto_code_gen_t cg,unsigned int max_size_megabytes):
    global _thinlto_codegen_set_cache_size_megabytes__funptr
    if __init_symbol(&_thinlto_codegen_set_cache_size_megabytes__funptr,"thinlto_codegen_set_cache_size_megabytes") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,unsigned int) noexcept nogil> _thinlto_codegen_set_cache_size_megabytes__funptr)(cg,max_size_megabytes)


cdef void* _thinlto_codegen_set_cache_size_files__funptr = NULL
# 
# Sets the maximum number of files in the cache directory. An unspecified
# default value will be applied. A value of 0 will be ignored.
# 
# \since LTO_API_VERSION=22
cdef void thinlto_codegen_set_cache_size_files(thinlto_code_gen_t cg,unsigned int max_size_files):
    global _thinlto_codegen_set_cache_size_files__funptr
    if __init_symbol(&_thinlto_codegen_set_cache_size_files__funptr,"thinlto_codegen_set_cache_size_files") > 0:
        pass
    (<void (*)(thinlto_code_gen_t,unsigned int) noexcept nogil> _thinlto_codegen_set_cache_size_files__funptr)(cg,max_size_files)
