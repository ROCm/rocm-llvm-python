# MIT License
# 
# Copyright (c) 2023 Advanced Micro Devices, Inc.
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)


"""

import cython
import ctypes
import enum
cdef class LLVMFatalErrorHandler:
    """Python wrapper for C type cerrorhandling.LLVMFatalErrorHandler.
    
    Python wrapper for C type cerrorhandling.LLVMFatalErrorHandler.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMFatalErrorHandler from_ptr(cerrorhandling.LLVMFatalErrorHandler ptr, bint owner=False):
        """Factory function to create ``LLVMFatalErrorHandler`` objects from
        given ``cerrorhandling.LLVMFatalErrorHandler`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMFatalErrorHandler wrapper = LLVMFatalErrorHandler.__new__(LLVMFatalErrorHandler)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMFatalErrorHandler from_pyobj(object pyobj):
        """Derives a LLVMFatalErrorHandler from a Python object.

        Derives a LLVMFatalErrorHandler from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMFatalErrorHandler`` reference, this method
        returns it directly. No new ``LLVMFatalErrorHandler`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMFatalErrorHandler`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMFatalErrorHandler!
        """
        cdef LLVMFatalErrorHandler wrapper = LLVMFatalErrorHandler.__new__(LLVMFatalErrorHandler)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMFatalErrorHandler):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cerrorhandling.LLVMFatalErrorHandler>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cerrorhandling.LLVMFatalErrorHandler>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <cerrorhandling.LLVMFatalErrorHandler>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMFatalErrorHandler object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def LLVMInstallFatalErrorHandler(object Handler):
    r"""(No short description, might be part of a group.)

    Install a fatal error handler. By default, if LLVM detects a fatal error, it
    will call exit(1). This may not be appropriate in many contexts. For example,
    doing exit(1) will bypass many crash reporting/tracing system tools. This
    function allows you to install a callback that will be invoked prior to the
    call to exit(1).

    Args:
        Handler (`~.LLVMFatalErrorHandler`/`~.object`):
            (undocumented)
    """
    cerrorhandling.LLVMInstallFatalErrorHandler(
        LLVMFatalErrorHandler.from_pyobj(Handler)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMResetFatalErrorHandler():
    r"""(No short description, might be part of a group.)

    Reset the fatal error handler. This resets LLVM's fatal error handling
    behavior to the default.
    """
    cerrorhandling.LLVMResetFatalErrorHandler()    # fully specified


@cython.embedsignature(True)
def LLVMEnablePrettyStackTrace():
    r"""(No short description, might be part of a group.)

    Enable LLVM's built-in stack trace code. This intercepts the OS's crash
    signals and prints which component of LLVM you were in at the time if the
    crash.
    """
    cerrorhandling.LLVMEnablePrettyStackTrace()    # fully specified

__all__ = [
    "LLVMFatalErrorHandler",
    "LLVMInstallFatalErrorHandler",
    "LLVMResetFatalErrorHandler",
    "LLVMEnablePrettyStackTrace",
]