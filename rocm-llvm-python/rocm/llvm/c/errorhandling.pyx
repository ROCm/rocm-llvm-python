# MIT License
#
# Copyright (c) 2023-2024 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)


"""

import cython
import ctypes
import enum
cdef class LLVMFatalErrorHandler(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cerrorhandling.LLVMFatalErrorHandler.

    Python wrapper for cdef class cerrorhandling.LLVMFatalErrorHandler.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef cerrorhandling.LLVMFatalErrorHandler getElementPtr(self):
        return <cerrorhandling.LLVMFatalErrorHandler>self._ptr

    @staticmethod
    cdef LLVMFatalErrorHandler fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMFatalErrorHandler`` objects from
        given ``cerrorhandling.LLVMFatalErrorHandler`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMFatalErrorHandler wrapper = LLVMFatalErrorHandler.__new__(LLVMFatalErrorHandler)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMFatalErrorHandler from a Python object.

        Derives a LLVMFatalErrorHandler from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMFatalErrorHandler`` reference, this method
        returns it directly. No new ``LLVMFatalErrorHandler`` is created in this case.
        """
        return LLVMFatalErrorHandler.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMFatalErrorHandler fromPyobj(object pyobj):
        """Creates a LLVMFatalErrorHandler from a Python object.

        Derives a LLVMFatalErrorHandler from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMFatalErrorHandler`` reference, this method
        returns it directly. No new ``LLVMFatalErrorHandler`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMFatalErrorHandler`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMFatalErrorHandler!
        """
        cdef LLVMFatalErrorHandler wrapper

        if isinstance(pyobj,LLVMFatalErrorHandler):
            return pyobj
        else:
            wrapper = LLVMFatalErrorHandler.__new__(LLVMFatalErrorHandler)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMFatalErrorHandler object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def LLVMInstallFatalErrorHandler(object Handler):
    r"""(No short description, might be part of a group.)

    Install a fatal error handler. By default, if LLVM detects a fatal error, it
    will call exit(1). This may not be appropriate in many contexts. For example,
    doing exit(1) will bypass many crash reporting/tracing system tools. This
    function allows you to install a callback that will be invoked prior to the
    call to exit(1).

    Args:
        Handler (`~.LLVMFatalErrorHandler`/`~.object`):
            (undocumented)
    """
    cerrorhandling.LLVMInstallFatalErrorHandler(
        LLVMFatalErrorHandler.fromPyobj(Handler).getElementPtr())


@cython.embedsignature(True)
def LLVMResetFatalErrorHandler():
    r"""(No short description, might be part of a group.)

    Reset the fatal error handler. This resets LLVM's fatal error handling
    behavior to the default.
    """
    cerrorhandling.LLVMResetFatalErrorHandler()


@cython.embedsignature(True)
def LLVMEnablePrettyStackTrace():
    r"""(No short description, might be part of a group.)

    Enable LLVM's built-in stack trace code. This intercepts the OS's crash
    signals and prints which component of LLVM you were in at the time if the
    crash.
    """
    cerrorhandling.LLVMEnablePrettyStackTrace()

__all__ = [
    "LLVMFatalErrorHandler",
    "LLVMInstallFatalErrorHandler",
    "LLVMResetFatalErrorHandler",
    "LLVMEnablePrettyStackTrace",
]