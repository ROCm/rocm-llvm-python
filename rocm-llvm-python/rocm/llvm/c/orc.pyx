# MIT License
#
# Copyright (c) 2023-2024 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    LLVMOrcExecutionSessionRef:
        alias of `~.LLVMOrcOpaqueExecutionSession`

    LLVMOrcSymbolStringPoolRef:
        alias of `~.LLVMOrcOpaqueSymbolStringPool`

    LLVMOrcSymbolStringPoolEntryRef:
        alias of `~.LLVMOrcOpaqueSymbolStringPoolEntry`

    LLVMOrcCSymbolFlagsMapPairs:
        alias of `~.LLVMOrcCSymbolFlagsMapPair`

    LLVMOrcCSymbolMapPairs:
        alias of `~.LLVMOrcCSymbolMapPair`

    LLVMOrcCSymbolAliasMapPairs:
        alias of `~.LLVMOrcCSymbolAliasMapPair`

    LLVMOrcJITDylibRef:
        alias of `~.LLVMOrcOpaqueJITDylib`

    LLVMOrcCDependenceMapPairs:
        alias of `~.LLVMOrcCDependenceMapPair`

    LLVMOrcCJITDylibSearchOrder:
        alias of `~.LLVMOrcCJITDylibSearchOrderElement`

    LLVMOrcCLookupSet:
        alias of `~.LLVMOrcCLookupSetElement`

    LLVMOrcMaterializationUnitRef:
        alias of `~.LLVMOrcOpaqueMaterializationUnit`

    LLVMOrcMaterializationResponsibilityRef:
        alias of `~.LLVMOrcOpaqueMaterializationResponsibility`

    LLVMOrcResourceTrackerRef:
        alias of `~.LLVMOrcOpaqueResourceTracker`

    LLVMOrcDefinitionGeneratorRef:
        alias of `~.LLVMOrcOpaqueDefinitionGenerator`

    LLVMOrcLookupStateRef:
        alias of `~.LLVMOrcOpaqueLookupState`

    LLVMOrcThreadSafeContextRef:
        alias of `~.LLVMOrcOpaqueThreadSafeContext`

    LLVMOrcThreadSafeModuleRef:
        alias of `~.LLVMOrcOpaqueThreadSafeModule`

    LLVMOrcJITTargetMachineBuilderRef:
        alias of `~.LLVMOrcOpaqueJITTargetMachineBuilder`

    LLVMOrcObjectLayerRef:
        alias of `~.LLVMOrcOpaqueObjectLayer`

    LLVMOrcObjectLinkingLayerRef:
        alias of `~.LLVMOrcOpaqueObjectLinkingLayer`

    LLVMOrcIRTransformLayerRef:
        alias of `~.LLVMOrcOpaqueIRTransformLayer`

    LLVMOrcObjectTransformLayerRef:
        alias of `~.LLVMOrcOpaqueObjectTransformLayer`

    LLVMOrcIndirectStubsManagerRef:
        alias of `~.LLVMOrcOpaqueIndirectStubsManager`

    LLVMOrcLazyCallThroughManagerRef:
        alias of `~.LLVMOrcOpaqueLazyCallThroughManager`

    LLVMOrcDumpObjectsRef:
        alias of `~.LLVMOrcOpaqueDumpObjects`

"""

import cython
import ctypes
import enum

from rocm.llvm.c.error import LLVMErrorRef
from rocm.llvm.c.error import LLVMGetErrorTypeId
from rocm.llvm.c.error import LLVMConsumeError
from rocm.llvm.c.error import LLVMGetErrorMessage
from rocm.llvm.c.error import LLVMDisposeErrorMessage
from rocm.llvm.c.error import LLVMGetStringErrorTypeId
from rocm.llvm.c.error import LLVMCreateStringError


from rocm.llvm.c.targetmachine import LLVMTargetMachineOptionsRef
from rocm.llvm.c.targetmachine import LLVMTargetMachineRef
from rocm.llvm.c.targetmachine import LLVMTargetRef
from rocm.llvm.c.targetmachine import LLVMCodeGenOptLevel
from rocm.llvm.c.targetmachine import LLVMRelocMode
from rocm.llvm.c.targetmachine import LLVMCodeModel
from rocm.llvm.c.targetmachine import LLVMCodeGenFileType
from rocm.llvm.c.targetmachine import LLVMGlobalISelAbortMode
from rocm.llvm.c.targetmachine import LLVMGetFirstTarget
from rocm.llvm.c.targetmachine import LLVMGetNextTarget
from rocm.llvm.c.targetmachine import LLVMGetTargetFromName
from rocm.llvm.c.targetmachine import LLVMGetTargetFromTriple
from rocm.llvm.c.targetmachine import LLVMGetTargetName
from rocm.llvm.c.targetmachine import LLVMGetTargetDescription
from rocm.llvm.c.targetmachine import LLVMTargetHasJIT
from rocm.llvm.c.targetmachine import LLVMTargetHasTargetMachine
from rocm.llvm.c.targetmachine import LLVMTargetHasAsmBackend
from rocm.llvm.c.targetmachine import LLVMCreateTargetMachineOptions
from rocm.llvm.c.targetmachine import LLVMDisposeTargetMachineOptions
from rocm.llvm.c.targetmachine import LLVMTargetMachineOptionsSetCPU
from rocm.llvm.c.targetmachine import LLVMTargetMachineOptionsSetFeatures
from rocm.llvm.c.targetmachine import LLVMTargetMachineOptionsSetABI
from rocm.llvm.c.targetmachine import LLVMTargetMachineOptionsSetCodeGenOptLevel
from rocm.llvm.c.targetmachine import LLVMTargetMachineOptionsSetRelocMode
from rocm.llvm.c.targetmachine import LLVMTargetMachineOptionsSetCodeModel
from rocm.llvm.c.targetmachine import LLVMCreateTargetMachineWithOptions
from rocm.llvm.c.targetmachine import LLVMCreateTargetMachine
from rocm.llvm.c.targetmachine import LLVMDisposeTargetMachine
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineTarget
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineTriple
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineCPU
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineFeatureString
from rocm.llvm.c.targetmachine import LLVMCreateTargetDataLayout
from rocm.llvm.c.targetmachine import LLVMSetTargetMachineAsmVerbosity
from rocm.llvm.c.targetmachine import LLVMSetTargetMachineFastISel
from rocm.llvm.c.targetmachine import LLVMSetTargetMachineGlobalISel
from rocm.llvm.c.targetmachine import LLVMSetTargetMachineGlobalISelAbort
from rocm.llvm.c.targetmachine import LLVMSetTargetMachineMachineOutliner
from rocm.llvm.c.targetmachine import LLVMTargetMachineEmitToFile
from rocm.llvm.c.targetmachine import LLVMTargetMachineEmitToMemoryBuffer
from rocm.llvm.c.targetmachine import LLVMGetDefaultTargetTriple
from rocm.llvm.c.targetmachine import LLVMNormalizeTargetTriple
from rocm.llvm.c.targetmachine import LLVMGetHostCPUName
from rocm.llvm.c.targetmachine import LLVMGetHostCPUFeatures
from rocm.llvm.c.targetmachine import LLVMAddAnalysisPasses


from rocm.llvm.c.types import LLVMMemoryBufferRef
from rocm.llvm.c.types import LLVMContextRef
from rocm.llvm.c.types import LLVMModuleRef
from rocm.llvm.c.types import LLVMTypeRef
from rocm.llvm.c.types import LLVMValueRef
from rocm.llvm.c.types import LLVMBasicBlockRef
from rocm.llvm.c.types import LLVMMetadataRef
from rocm.llvm.c.types import LLVMNamedMDNodeRef
from rocm.llvm.c.types import LLVMValueMetadataEntry
from rocm.llvm.c.types import LLVMBuilderRef
from rocm.llvm.c.types import LLVMDIBuilderRef
from rocm.llvm.c.types import LLVMModuleProviderRef
from rocm.llvm.c.types import LLVMPassManagerRef
from rocm.llvm.c.types import LLVMUseRef
from rocm.llvm.c.types import LLVMOperandBundleRef
from rocm.llvm.c.types import LLVMAttributeRef
from rocm.llvm.c.types import LLVMDiagnosticInfoRef
from rocm.llvm.c.types import LLVMComdatRef
from rocm.llvm.c.types import LLVMModuleFlagEntry
from rocm.llvm.c.types import LLVMJITEventListenerRef
from rocm.llvm.c.types import LLVMBinaryRef

class _LLVMJITSymbolGenericFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class LLVMJITSymbolGenericFlags(_LLVMJITSymbolGenericFlags__Base):
    """Represents generic linkage flags for a symbol definition.

    Attributes:
        LLVMJITSymbolGenericFlagsNone:
            (undocumented)
        LLVMJITSymbolGenericFlagsExported:
            (undocumented)
        LLVMJITSymbolGenericFlagsWeak:
            (undocumented)
        LLVMJITSymbolGenericFlagsCallable:
            (undocumented)
        LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly:
            (undocumented)
    """
    LLVMJITSymbolGenericFlagsNone = corc.LLVMJITSymbolGenericFlagsNone
    LLVMJITSymbolGenericFlagsExported = corc.LLVMJITSymbolGenericFlagsExported
    LLVMJITSymbolGenericFlagsWeak = corc.LLVMJITSymbolGenericFlagsWeak
    LLVMJITSymbolGenericFlagsCallable = corc.LLVMJITSymbolGenericFlagsCallable
    LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly = corc.LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class LLVMJITSymbolFlags(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMJITSymbolFlags.

    Python wrapper for cdef class corc.LLVMJITSymbolFlags.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMJITSymbolFlags* getElementPtr(self):
        return <corc.LLVMJITSymbolFlags*>self._ptr

    @staticmethod
    cdef LLVMJITSymbolFlags fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMJITSymbolFlags`` objects from
        given ``corc.LLVMJITSymbolFlags`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMJITSymbolFlags wrapper = LLVMJITSymbolFlags.__new__(LLVMJITSymbolFlags)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMJITSymbolFlags from a Python object.

        Derives a LLVMJITSymbolFlags from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMJITSymbolFlags`` reference, this method
        returns it directly. No new ``LLVMJITSymbolFlags`` is created in this case.
        """
        return LLVMJITSymbolFlags.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMJITSymbolFlags fromPyobj(object pyobj):
        """Creates a LLVMJITSymbolFlags from a Python object.

        Derives a LLVMJITSymbolFlags from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMJITSymbolFlags`` reference, this method
        returns it directly. No new ``LLVMJITSymbolFlags`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMJITSymbolFlags`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMJITSymbolFlags!
        """
        cdef LLVMJITSymbolFlags wrapper

        if isinstance(pyobj,LLVMJITSymbolFlags):
            return pyobj
        else:
            wrapper = LLVMJITSymbolFlags.__new__(LLVMJITSymbolFlags)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(corc.LLVMJITSymbolFlags))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMJITSymbolFlags))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMJITSymbolFlags new():
        """Factory function to create LLVMJITSymbolFlags objects with
        newly allocated corc.LLVMJITSymbolFlags"""
        cdef void* ptr
        LLVMJITSymbolFlags.__allocate(&ptr)
        return LLVMJITSymbolFlags.fromPtr(ptr, owner=True)

    @staticmethod
    cdef LLVMJITSymbolFlags fromValue(corc.LLVMJITSymbolFlags other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMJITSymbolFlags.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMJITSymbolFlags))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(corc.LLVMJITSymbolFlags)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMJITSymbolFlags object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type LLVMJITSymbolFlags.

        Constructor for type LLVMJITSymbolFlags.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMJITSymbolFlags.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_GenericFlags(self, i):
        """Get value ``GenericFlags`` of ``(<corc.LLVMJITSymbolFlags*>self._ptr)[i]``.
        """
        return (<corc.LLVMJITSymbolFlags*>self._ptr)[i].GenericFlags
    def set_GenericFlags(self, i, unsigned char value):
        """Set value ``GenericFlags`` of ``(<corc.LLVMJITSymbolFlags*>self._ptr)[i]``.
        """
        (<corc.LLVMJITSymbolFlags*>self._ptr)[i].GenericFlags = value
    @property
    def GenericFlags(self):
        """(undocumented)"""
        return self.get_GenericFlags(0)
    @GenericFlags.setter
    def GenericFlags(self, unsigned char value):
        self.set_GenericFlags(0,value)

    def get_TargetFlags(self, i):
        """Get value ``TargetFlags`` of ``(<corc.LLVMJITSymbolFlags*>self._ptr)[i]``.
        """
        return (<corc.LLVMJITSymbolFlags*>self._ptr)[i].TargetFlags
    def set_TargetFlags(self, i, unsigned char value):
        """Set value ``TargetFlags`` of ``(<corc.LLVMJITSymbolFlags*>self._ptr)[i]``.
        """
        (<corc.LLVMJITSymbolFlags*>self._ptr)[i].TargetFlags = value
    @property
    def TargetFlags(self):
        """(undocumented)"""
        return self.get_TargetFlags(0)
    @TargetFlags.setter
    def TargetFlags(self, unsigned char value):
        self.set_TargetFlags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["GenericFlags","TargetFlags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class LLVMJITEvaluatedSymbol(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMJITEvaluatedSymbol.

    Python wrapper for cdef class corc.LLVMJITEvaluatedSymbol.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMJITEvaluatedSymbol* getElementPtr(self):
        return <corc.LLVMJITEvaluatedSymbol*>self._ptr

    @staticmethod
    cdef LLVMJITEvaluatedSymbol fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMJITEvaluatedSymbol`` objects from
        given ``corc.LLVMJITEvaluatedSymbol`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMJITEvaluatedSymbol wrapper = LLVMJITEvaluatedSymbol.__new__(LLVMJITEvaluatedSymbol)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMJITEvaluatedSymbol from a Python object.

        Derives a LLVMJITEvaluatedSymbol from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMJITEvaluatedSymbol`` reference, this method
        returns it directly. No new ``LLVMJITEvaluatedSymbol`` is created in this case.
        """
        return LLVMJITEvaluatedSymbol.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMJITEvaluatedSymbol fromPyobj(object pyobj):
        """Creates a LLVMJITEvaluatedSymbol from a Python object.

        Derives a LLVMJITEvaluatedSymbol from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMJITEvaluatedSymbol`` reference, this method
        returns it directly. No new ``LLVMJITEvaluatedSymbol`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMJITEvaluatedSymbol`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMJITEvaluatedSymbol!
        """
        cdef LLVMJITEvaluatedSymbol wrapper

        if isinstance(pyobj,LLVMJITEvaluatedSymbol):
            return pyobj
        else:
            wrapper = LLVMJITEvaluatedSymbol.__new__(LLVMJITEvaluatedSymbol)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(corc.LLVMJITEvaluatedSymbol))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMJITEvaluatedSymbol))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMJITEvaluatedSymbol new():
        """Factory function to create LLVMJITEvaluatedSymbol objects with
        newly allocated corc.LLVMJITEvaluatedSymbol"""
        cdef void* ptr
        LLVMJITEvaluatedSymbol.__allocate(&ptr)
        return LLVMJITEvaluatedSymbol.fromPtr(ptr, owner=True)

    @staticmethod
    cdef LLVMJITEvaluatedSymbol fromValue(corc.LLVMJITEvaluatedSymbol other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMJITEvaluatedSymbol.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMJITEvaluatedSymbol))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(corc.LLVMJITEvaluatedSymbol)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMJITEvaluatedSymbol object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type LLVMJITEvaluatedSymbol.

        Constructor for type LLVMJITEvaluatedSymbol.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMJITEvaluatedSymbol.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_Address(self, i):
        """Get value ``Address`` of ``(<corc.LLVMJITEvaluatedSymbol*>self._ptr)[i]``.
        """
        return (<corc.LLVMJITEvaluatedSymbol*>self._ptr)[i].Address
    def set_Address(self, i, unsigned long value):
        """Set value ``Address`` of ``(<corc.LLVMJITEvaluatedSymbol*>self._ptr)[i]``.
        """
        (<corc.LLVMJITEvaluatedSymbol*>self._ptr)[i].Address = value
    @property
    def Address(self):
        """(undocumented)"""
        return self.get_Address(0)
    @Address.setter
    def Address(self, unsigned long value):
        self.set_Address(0,value)

    def get_Flags(self, i):
        """Get value of ``Flags`` of ``(<corc.LLVMJITEvaluatedSymbol*>self._ptr)[i]``.
        """
        return LLVMJITSymbolFlags.fromPtr(&(<corc.LLVMJITEvaluatedSymbol*>self._ptr)[i].Flags)
    @property
    def Flags(self):
        """(undocumented)"""
        return self.get_Flags(0)

    @staticmethod
    def PROPERTIES():
        return ["Address","Flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class LLVMOrcOpaqueExecutionSession(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueExecutionSession.

    Python wrapper for cdef class corc.LLVMOrcOpaqueExecutionSession.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueExecutionSession* getElementPtr(self):
        return <corc.LLVMOrcOpaqueExecutionSession*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueExecutionSession fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueExecutionSession`` objects from
        given ``corc.LLVMOrcOpaqueExecutionSession`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueExecutionSession wrapper = LLVMOrcOpaqueExecutionSession.__new__(LLVMOrcOpaqueExecutionSession)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueExecutionSession from a Python object.

        Derives a LLVMOrcOpaqueExecutionSession from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueExecutionSession`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueExecutionSession`` is created in this case.
        """
        return LLVMOrcOpaqueExecutionSession.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueExecutionSession fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueExecutionSession from a Python object.

        Derives a LLVMOrcOpaqueExecutionSession from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueExecutionSession`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueExecutionSession`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueExecutionSession`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueExecutionSession!
        """
        cdef LLVMOrcOpaqueExecutionSession wrapper

        if isinstance(pyobj,LLVMOrcOpaqueExecutionSession):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueExecutionSession.__new__(LLVMOrcOpaqueExecutionSession)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueExecutionSession object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcExecutionSessionRef = LLVMOrcOpaqueExecutionSession

cdef class LLVMOrcErrorReporterFunction(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcErrorReporterFunction.

    Python wrapper for cdef class corc.LLVMOrcErrorReporterFunction.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcErrorReporterFunction getElementPtr(self):
        return <corc.LLVMOrcErrorReporterFunction>self._ptr

    @staticmethod
    cdef LLVMOrcErrorReporterFunction fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcErrorReporterFunction`` objects from
        given ``corc.LLVMOrcErrorReporterFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcErrorReporterFunction wrapper = LLVMOrcErrorReporterFunction.__new__(LLVMOrcErrorReporterFunction)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcErrorReporterFunction from a Python object.

        Derives a LLVMOrcErrorReporterFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcErrorReporterFunction`` reference, this method
        returns it directly. No new ``LLVMOrcErrorReporterFunction`` is created in this case.
        """
        return LLVMOrcErrorReporterFunction.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcErrorReporterFunction fromPyobj(object pyobj):
        """Creates a LLVMOrcErrorReporterFunction from a Python object.

        Derives a LLVMOrcErrorReporterFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcErrorReporterFunction`` reference, this method
        returns it directly. No new ``LLVMOrcErrorReporterFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcErrorReporterFunction`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcErrorReporterFunction!
        """
        cdef LLVMOrcErrorReporterFunction wrapper

        if isinstance(pyobj,LLVMOrcErrorReporterFunction):
            return pyobj
        else:
            wrapper = LLVMOrcErrorReporterFunction.__new__(LLVMOrcErrorReporterFunction)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcErrorReporterFunction object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcOpaqueSymbolStringPool(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueSymbolStringPool.

    Python wrapper for cdef class corc.LLVMOrcOpaqueSymbolStringPool.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueSymbolStringPool* getElementPtr(self):
        return <corc.LLVMOrcOpaqueSymbolStringPool*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueSymbolStringPool fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueSymbolStringPool`` objects from
        given ``corc.LLVMOrcOpaqueSymbolStringPool`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueSymbolStringPool wrapper = LLVMOrcOpaqueSymbolStringPool.__new__(LLVMOrcOpaqueSymbolStringPool)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueSymbolStringPool from a Python object.

        Derives a LLVMOrcOpaqueSymbolStringPool from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueSymbolStringPool`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueSymbolStringPool`` is created in this case.
        """
        return LLVMOrcOpaqueSymbolStringPool.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueSymbolStringPool fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueSymbolStringPool from a Python object.

        Derives a LLVMOrcOpaqueSymbolStringPool from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueSymbolStringPool`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueSymbolStringPool`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueSymbolStringPool`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueSymbolStringPool!
        """
        cdef LLVMOrcOpaqueSymbolStringPool wrapper

        if isinstance(pyobj,LLVMOrcOpaqueSymbolStringPool):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueSymbolStringPool.__new__(LLVMOrcOpaqueSymbolStringPool)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueSymbolStringPool object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcSymbolStringPoolRef = LLVMOrcOpaqueSymbolStringPool

cdef class LLVMOrcOpaqueSymbolStringPoolEntry(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueSymbolStringPoolEntry.

    Python wrapper for cdef class corc.LLVMOrcOpaqueSymbolStringPoolEntry.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueSymbolStringPoolEntry* getElementPtr(self):
        return <corc.LLVMOrcOpaqueSymbolStringPoolEntry*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueSymbolStringPoolEntry fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueSymbolStringPoolEntry`` objects from
        given ``corc.LLVMOrcOpaqueSymbolStringPoolEntry`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueSymbolStringPoolEntry wrapper = LLVMOrcOpaqueSymbolStringPoolEntry.__new__(LLVMOrcOpaqueSymbolStringPoolEntry)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueSymbolStringPoolEntry from a Python object.

        Derives a LLVMOrcOpaqueSymbolStringPoolEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueSymbolStringPoolEntry`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueSymbolStringPoolEntry`` is created in this case.
        """
        return LLVMOrcOpaqueSymbolStringPoolEntry.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueSymbolStringPoolEntry fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueSymbolStringPoolEntry from a Python object.

        Derives a LLVMOrcOpaqueSymbolStringPoolEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueSymbolStringPoolEntry`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueSymbolStringPoolEntry`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueSymbolStringPoolEntry`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueSymbolStringPoolEntry!
        """
        cdef LLVMOrcOpaqueSymbolStringPoolEntry wrapper

        if isinstance(pyobj,LLVMOrcOpaqueSymbolStringPoolEntry):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueSymbolStringPoolEntry.__new__(LLVMOrcOpaqueSymbolStringPoolEntry)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueSymbolStringPoolEntry object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcSymbolStringPoolEntryRef = LLVMOrcOpaqueSymbolStringPoolEntry

cdef class LLVMOrcCSymbolFlagsMapPair(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcCSymbolFlagsMapPair.

    Python wrapper for cdef class corc.LLVMOrcCSymbolFlagsMapPair.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcCSymbolFlagsMapPair* getElementPtr(self):
        return <corc.LLVMOrcCSymbolFlagsMapPair*>self._ptr

    @staticmethod
    cdef LLVMOrcCSymbolFlagsMapPair fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCSymbolFlagsMapPair`` objects from
        given ``corc.LLVMOrcCSymbolFlagsMapPair`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCSymbolFlagsMapPair wrapper = LLVMOrcCSymbolFlagsMapPair.__new__(LLVMOrcCSymbolFlagsMapPair)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcCSymbolFlagsMapPair from a Python object.

        Derives a LLVMOrcCSymbolFlagsMapPair from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolFlagsMapPair`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolFlagsMapPair`` is created in this case.
        """
        return LLVMOrcCSymbolFlagsMapPair.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcCSymbolFlagsMapPair fromPyobj(object pyobj):
        """Creates a LLVMOrcCSymbolFlagsMapPair from a Python object.

        Derives a LLVMOrcCSymbolFlagsMapPair from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolFlagsMapPair`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolFlagsMapPair`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcCSymbolFlagsMapPair`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCSymbolFlagsMapPair!
        """
        cdef LLVMOrcCSymbolFlagsMapPair wrapper

        if isinstance(pyobj,LLVMOrcCSymbolFlagsMapPair):
            return pyobj
        else:
            wrapper = LLVMOrcCSymbolFlagsMapPair.__new__(LLVMOrcCSymbolFlagsMapPair)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(corc.LLVMOrcCSymbolFlagsMapPair))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCSymbolFlagsMapPair))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCSymbolFlagsMapPair new():
        """Factory function to create LLVMOrcCSymbolFlagsMapPair objects with
        newly allocated corc.LLVMOrcCSymbolFlagsMapPair"""
        cdef void* ptr
        LLVMOrcCSymbolFlagsMapPair.__allocate(&ptr)
        return LLVMOrcCSymbolFlagsMapPair.fromPtr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCSymbolFlagsMapPair fromValue(corc.LLVMOrcCSymbolFlagsMapPair other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCSymbolFlagsMapPair.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCSymbolFlagsMapPair))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCSymbolFlagsMapPair)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcCSymbolFlagsMapPair object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCSymbolFlagsMapPair.

        Constructor for type LLVMOrcCSymbolFlagsMapPair.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCSymbolFlagsMapPair.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_Flags(self, i):
        """Get value of ``Flags`` of ``(<corc.LLVMOrcCSymbolFlagsMapPair*>self._ptr)[i]``.
        """
        return LLVMJITSymbolFlags.fromPtr(&(<corc.LLVMOrcCSymbolFlagsMapPair*>self._ptr)[i].Flags)
    @property
    def Flags(self):
        """(undocumented)"""
        return self.get_Flags(0)

    @staticmethod
    def PROPERTIES():
        return ["Flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcCSymbolFlagsMapPairs = LLVMOrcCSymbolFlagsMapPair

cdef class LLVMOrcCSymbolMapPair(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcCSymbolMapPair.

    Python wrapper for cdef class corc.LLVMOrcCSymbolMapPair.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcCSymbolMapPair* getElementPtr(self):
        return <corc.LLVMOrcCSymbolMapPair*>self._ptr

    @staticmethod
    cdef LLVMOrcCSymbolMapPair fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCSymbolMapPair`` objects from
        given ``corc.LLVMOrcCSymbolMapPair`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCSymbolMapPair wrapper = LLVMOrcCSymbolMapPair.__new__(LLVMOrcCSymbolMapPair)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcCSymbolMapPair from a Python object.

        Derives a LLVMOrcCSymbolMapPair from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolMapPair`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolMapPair`` is created in this case.
        """
        return LLVMOrcCSymbolMapPair.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcCSymbolMapPair fromPyobj(object pyobj):
        """Creates a LLVMOrcCSymbolMapPair from a Python object.

        Derives a LLVMOrcCSymbolMapPair from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolMapPair`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolMapPair`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcCSymbolMapPair`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCSymbolMapPair!
        """
        cdef LLVMOrcCSymbolMapPair wrapper

        if isinstance(pyobj,LLVMOrcCSymbolMapPair):
            return pyobj
        else:
            wrapper = LLVMOrcCSymbolMapPair.__new__(LLVMOrcCSymbolMapPair)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(corc.LLVMOrcCSymbolMapPair))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCSymbolMapPair))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCSymbolMapPair new():
        """Factory function to create LLVMOrcCSymbolMapPair objects with
        newly allocated corc.LLVMOrcCSymbolMapPair"""
        cdef void* ptr
        LLVMOrcCSymbolMapPair.__allocate(&ptr)
        return LLVMOrcCSymbolMapPair.fromPtr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCSymbolMapPair fromValue(corc.LLVMOrcCSymbolMapPair other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCSymbolMapPair.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCSymbolMapPair))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCSymbolMapPair)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcCSymbolMapPair object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCSymbolMapPair.

        Constructor for type LLVMOrcCSymbolMapPair.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCSymbolMapPair.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_Sym(self, i):
        """Get value of ``Sym`` of ``(<corc.LLVMOrcCSymbolMapPair*>self._ptr)[i]``.
        """
        return LLVMJITEvaluatedSymbol.fromPtr(&(<corc.LLVMOrcCSymbolMapPair*>self._ptr)[i].Sym)
    @property
    def Sym(self):
        """(undocumented)"""
        return self.get_Sym(0)

    @staticmethod
    def PROPERTIES():
        return ["Sym"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcCSymbolMapPairs = LLVMOrcCSymbolMapPair

cdef class LLVMOrcCSymbolAliasMapEntry(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcCSymbolAliasMapEntry.

    Python wrapper for cdef class corc.LLVMOrcCSymbolAliasMapEntry.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcCSymbolAliasMapEntry* getElementPtr(self):
        return <corc.LLVMOrcCSymbolAliasMapEntry*>self._ptr

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapEntry fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCSymbolAliasMapEntry`` objects from
        given ``corc.LLVMOrcCSymbolAliasMapEntry`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCSymbolAliasMapEntry wrapper = LLVMOrcCSymbolAliasMapEntry.__new__(LLVMOrcCSymbolAliasMapEntry)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcCSymbolAliasMapEntry from a Python object.

        Derives a LLVMOrcCSymbolAliasMapEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolAliasMapEntry`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolAliasMapEntry`` is created in this case.
        """
        return LLVMOrcCSymbolAliasMapEntry.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapEntry fromPyobj(object pyobj):
        """Creates a LLVMOrcCSymbolAliasMapEntry from a Python object.

        Derives a LLVMOrcCSymbolAliasMapEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolAliasMapEntry`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolAliasMapEntry`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcCSymbolAliasMapEntry`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCSymbolAliasMapEntry!
        """
        cdef LLVMOrcCSymbolAliasMapEntry wrapper

        if isinstance(pyobj,LLVMOrcCSymbolAliasMapEntry):
            return pyobj
        else:
            wrapper = LLVMOrcCSymbolAliasMapEntry.__new__(LLVMOrcCSymbolAliasMapEntry)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(corc.LLVMOrcCSymbolAliasMapEntry))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCSymbolAliasMapEntry))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapEntry new():
        """Factory function to create LLVMOrcCSymbolAliasMapEntry objects with
        newly allocated corc.LLVMOrcCSymbolAliasMapEntry"""
        cdef void* ptr
        LLVMOrcCSymbolAliasMapEntry.__allocate(&ptr)
        return LLVMOrcCSymbolAliasMapEntry.fromPtr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapEntry fromValue(corc.LLVMOrcCSymbolAliasMapEntry other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCSymbolAliasMapEntry.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCSymbolAliasMapEntry))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCSymbolAliasMapEntry)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcCSymbolAliasMapEntry object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCSymbolAliasMapEntry.

        Constructor for type LLVMOrcCSymbolAliasMapEntry.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCSymbolAliasMapEntry.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_Flags(self, i):
        """Get value of ``Flags`` of ``(<corc.LLVMOrcCSymbolAliasMapEntry*>self._ptr)[i]``.
        """
        return LLVMJITSymbolFlags.fromPtr(&(<corc.LLVMOrcCSymbolAliasMapEntry*>self._ptr)[i].Flags)
    @property
    def Flags(self):
        """(undocumented)"""
        return self.get_Flags(0)

    @staticmethod
    def PROPERTIES():
        return ["Flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class LLVMOrcCSymbolAliasMapPair(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcCSymbolAliasMapPair.

    Python wrapper for cdef class corc.LLVMOrcCSymbolAliasMapPair.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcCSymbolAliasMapPair* getElementPtr(self):
        return <corc.LLVMOrcCSymbolAliasMapPair*>self._ptr

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapPair fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCSymbolAliasMapPair`` objects from
        given ``corc.LLVMOrcCSymbolAliasMapPair`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCSymbolAliasMapPair wrapper = LLVMOrcCSymbolAliasMapPair.__new__(LLVMOrcCSymbolAliasMapPair)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcCSymbolAliasMapPair from a Python object.

        Derives a LLVMOrcCSymbolAliasMapPair from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolAliasMapPair`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolAliasMapPair`` is created in this case.
        """
        return LLVMOrcCSymbolAliasMapPair.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapPair fromPyobj(object pyobj):
        """Creates a LLVMOrcCSymbolAliasMapPair from a Python object.

        Derives a LLVMOrcCSymbolAliasMapPair from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolAliasMapPair`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolAliasMapPair`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcCSymbolAliasMapPair`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCSymbolAliasMapPair!
        """
        cdef LLVMOrcCSymbolAliasMapPair wrapper

        if isinstance(pyobj,LLVMOrcCSymbolAliasMapPair):
            return pyobj
        else:
            wrapper = LLVMOrcCSymbolAliasMapPair.__new__(LLVMOrcCSymbolAliasMapPair)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(corc.LLVMOrcCSymbolAliasMapPair))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCSymbolAliasMapPair))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapPair new():
        """Factory function to create LLVMOrcCSymbolAliasMapPair objects with
        newly allocated corc.LLVMOrcCSymbolAliasMapPair"""
        cdef void* ptr
        LLVMOrcCSymbolAliasMapPair.__allocate(&ptr)
        return LLVMOrcCSymbolAliasMapPair.fromPtr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapPair fromValue(corc.LLVMOrcCSymbolAliasMapPair other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCSymbolAliasMapPair.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCSymbolAliasMapPair))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCSymbolAliasMapPair)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcCSymbolAliasMapPair object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCSymbolAliasMapPair.

        Constructor for type LLVMOrcCSymbolAliasMapPair.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCSymbolAliasMapPair.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_Entry(self, i):
        """Get value of ``Entry`` of ``(<corc.LLVMOrcCSymbolAliasMapPair*>self._ptr)[i]``.
        """
        return LLVMOrcCSymbolAliasMapEntry.fromPtr(&(<corc.LLVMOrcCSymbolAliasMapPair*>self._ptr)[i].Entry)
    @property
    def Entry(self):
        """(undocumented)"""
        return self.get_Entry(0)

    @staticmethod
    def PROPERTIES():
        return ["Entry"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcCSymbolAliasMapPairs = LLVMOrcCSymbolAliasMapPair

cdef class LLVMOrcOpaqueJITDylib(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueJITDylib.

    Python wrapper for cdef class corc.LLVMOrcOpaqueJITDylib.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueJITDylib* getElementPtr(self):
        return <corc.LLVMOrcOpaqueJITDylib*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueJITDylib fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueJITDylib`` objects from
        given ``corc.LLVMOrcOpaqueJITDylib`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueJITDylib wrapper = LLVMOrcOpaqueJITDylib.__new__(LLVMOrcOpaqueJITDylib)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueJITDylib from a Python object.

        Derives a LLVMOrcOpaqueJITDylib from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueJITDylib`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueJITDylib`` is created in this case.
        """
        return LLVMOrcOpaqueJITDylib.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueJITDylib fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueJITDylib from a Python object.

        Derives a LLVMOrcOpaqueJITDylib from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueJITDylib`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueJITDylib`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueJITDylib`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueJITDylib!
        """
        cdef LLVMOrcOpaqueJITDylib wrapper

        if isinstance(pyobj,LLVMOrcOpaqueJITDylib):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueJITDylib.__new__(LLVMOrcOpaqueJITDylib)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueJITDylib object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcJITDylibRef = LLVMOrcOpaqueJITDylib

cdef class LLVMOrcCSymbolsList(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcCSymbolsList.

    Python wrapper for cdef class corc.LLVMOrcCSymbolsList.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcCSymbolsList* getElementPtr(self):
        return <corc.LLVMOrcCSymbolsList*>self._ptr

    @staticmethod
    cdef LLVMOrcCSymbolsList fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCSymbolsList`` objects from
        given ``corc.LLVMOrcCSymbolsList`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCSymbolsList wrapper = LLVMOrcCSymbolsList.__new__(LLVMOrcCSymbolsList)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcCSymbolsList from a Python object.

        Derives a LLVMOrcCSymbolsList from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolsList`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolsList`` is created in this case.
        """
        return LLVMOrcCSymbolsList.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcCSymbolsList fromPyobj(object pyobj):
        """Creates a LLVMOrcCSymbolsList from a Python object.

        Derives a LLVMOrcCSymbolsList from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolsList`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolsList`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcCSymbolsList`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCSymbolsList!
        """
        cdef LLVMOrcCSymbolsList wrapper

        if isinstance(pyobj,LLVMOrcCSymbolsList):
            return pyobj
        else:
            wrapper = LLVMOrcCSymbolsList.__new__(LLVMOrcCSymbolsList)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(corc.LLVMOrcCSymbolsList))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCSymbolsList))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCSymbolsList new():
        """Factory function to create LLVMOrcCSymbolsList objects with
        newly allocated corc.LLVMOrcCSymbolsList"""
        cdef void* ptr
        LLVMOrcCSymbolsList.__allocate(&ptr)
        return LLVMOrcCSymbolsList.fromPtr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCSymbolsList fromValue(corc.LLVMOrcCSymbolsList other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCSymbolsList.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCSymbolsList))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCSymbolsList)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcCSymbolsList object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCSymbolsList.

        Constructor for type LLVMOrcCSymbolsList.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCSymbolsList.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_Length(self, i):
        """Get value ``Length`` of ``(<corc.LLVMOrcCSymbolsList*>self._ptr)[i]``.
        """
        return (<corc.LLVMOrcCSymbolsList*>self._ptr)[i].Length
    def set_Length(self, i, unsigned long value):
        """Set value ``Length`` of ``(<corc.LLVMOrcCSymbolsList*>self._ptr)[i]``.
        """
        (<corc.LLVMOrcCSymbolsList*>self._ptr)[i].Length = value
    @property
    def Length(self):
        """(undocumented)"""
        return self.get_Length(0)
    @Length.setter
    def Length(self, unsigned long value):
        self.set_Length(0,value)

    @staticmethod
    def PROPERTIES():
        return ["Length"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class LLVMOrcCDependenceMapPair(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcCDependenceMapPair.

    Python wrapper for cdef class corc.LLVMOrcCDependenceMapPair.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcCDependenceMapPair* getElementPtr(self):
        return <corc.LLVMOrcCDependenceMapPair*>self._ptr

    @staticmethod
    cdef LLVMOrcCDependenceMapPair fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCDependenceMapPair`` objects from
        given ``corc.LLVMOrcCDependenceMapPair`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCDependenceMapPair wrapper = LLVMOrcCDependenceMapPair.__new__(LLVMOrcCDependenceMapPair)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcCDependenceMapPair from a Python object.

        Derives a LLVMOrcCDependenceMapPair from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCDependenceMapPair`` reference, this method
        returns it directly. No new ``LLVMOrcCDependenceMapPair`` is created in this case.
        """
        return LLVMOrcCDependenceMapPair.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcCDependenceMapPair fromPyobj(object pyobj):
        """Creates a LLVMOrcCDependenceMapPair from a Python object.

        Derives a LLVMOrcCDependenceMapPair from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCDependenceMapPair`` reference, this method
        returns it directly. No new ``LLVMOrcCDependenceMapPair`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcCDependenceMapPair`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCDependenceMapPair!
        """
        cdef LLVMOrcCDependenceMapPair wrapper

        if isinstance(pyobj,LLVMOrcCDependenceMapPair):
            return pyobj
        else:
            wrapper = LLVMOrcCDependenceMapPair.__new__(LLVMOrcCDependenceMapPair)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(corc.LLVMOrcCDependenceMapPair))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCDependenceMapPair))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCDependenceMapPair new():
        """Factory function to create LLVMOrcCDependenceMapPair objects with
        newly allocated corc.LLVMOrcCDependenceMapPair"""
        cdef void* ptr
        LLVMOrcCDependenceMapPair.__allocate(&ptr)
        return LLVMOrcCDependenceMapPair.fromPtr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCDependenceMapPair fromValue(corc.LLVMOrcCDependenceMapPair other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCDependenceMapPair.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCDependenceMapPair))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCDependenceMapPair)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcCDependenceMapPair object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCDependenceMapPair.

        Constructor for type LLVMOrcCDependenceMapPair.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCDependenceMapPair.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_Names(self, i):
        """Get value of ``Names`` of ``(<corc.LLVMOrcCDependenceMapPair*>self._ptr)[i]``.
        """
        return LLVMOrcCSymbolsList.fromPtr(&(<corc.LLVMOrcCDependenceMapPair*>self._ptr)[i].Names)
    @property
    def Names(self):
        """(undocumented)"""
        return self.get_Names(0)

    @staticmethod
    def PROPERTIES():
        return ["Names"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcCDependenceMapPairs = LLVMOrcCDependenceMapPair

class _LLVMOrcLookupKind__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class LLVMOrcLookupKind(_LLVMOrcLookupKind__Base):
    """Lookup kind. This can be used by definition generators when deciding whether to produce a definition for a requested symbol.

    Attributes:
        LLVMOrcLookupKindStatic:
            (undocumented)
        LLVMOrcLookupKindDLSym:
            (undocumented)
    """
    LLVMOrcLookupKindStatic = corc.LLVMOrcLookupKindStatic
    LLVMOrcLookupKindDLSym = corc.LLVMOrcLookupKindDLSym
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _LLVMOrcJITDylibLookupFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class LLVMOrcJITDylibLookupFlags(_LLVMOrcJITDylibLookupFlags__Base):
    """JITDylib lookup flags. This can be used by definition generators when deciding whether to produce a definition for a requested symbol.

    Attributes:
        LLVMOrcJITDylibLookupFlagsMatchExportedSymbolsOnly:
            (undocumented)
        LLVMOrcJITDylibLookupFlagsMatchAllSymbols:
            (undocumented)
    """
    LLVMOrcJITDylibLookupFlagsMatchExportedSymbolsOnly = corc.LLVMOrcJITDylibLookupFlagsMatchExportedSymbolsOnly
    LLVMOrcJITDylibLookupFlagsMatchAllSymbols = corc.LLVMOrcJITDylibLookupFlagsMatchAllSymbols
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class LLVMOrcCJITDylibSearchOrderElement(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcCJITDylibSearchOrderElement.

    Python wrapper for cdef class corc.LLVMOrcCJITDylibSearchOrderElement.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcCJITDylibSearchOrderElement* getElementPtr(self):
        return <corc.LLVMOrcCJITDylibSearchOrderElement*>self._ptr

    @staticmethod
    cdef LLVMOrcCJITDylibSearchOrderElement fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCJITDylibSearchOrderElement`` objects from
        given ``corc.LLVMOrcCJITDylibSearchOrderElement`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCJITDylibSearchOrderElement wrapper = LLVMOrcCJITDylibSearchOrderElement.__new__(LLVMOrcCJITDylibSearchOrderElement)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcCJITDylibSearchOrderElement from a Python object.

        Derives a LLVMOrcCJITDylibSearchOrderElement from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCJITDylibSearchOrderElement`` reference, this method
        returns it directly. No new ``LLVMOrcCJITDylibSearchOrderElement`` is created in this case.
        """
        return LLVMOrcCJITDylibSearchOrderElement.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcCJITDylibSearchOrderElement fromPyobj(object pyobj):
        """Creates a LLVMOrcCJITDylibSearchOrderElement from a Python object.

        Derives a LLVMOrcCJITDylibSearchOrderElement from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCJITDylibSearchOrderElement`` reference, this method
        returns it directly. No new ``LLVMOrcCJITDylibSearchOrderElement`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcCJITDylibSearchOrderElement`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCJITDylibSearchOrderElement!
        """
        cdef LLVMOrcCJITDylibSearchOrderElement wrapper

        if isinstance(pyobj,LLVMOrcCJITDylibSearchOrderElement):
            return pyobj
        else:
            wrapper = LLVMOrcCJITDylibSearchOrderElement.__new__(LLVMOrcCJITDylibSearchOrderElement)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(corc.LLVMOrcCJITDylibSearchOrderElement))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCJITDylibSearchOrderElement))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCJITDylibSearchOrderElement new():
        """Factory function to create LLVMOrcCJITDylibSearchOrderElement objects with
        newly allocated corc.LLVMOrcCJITDylibSearchOrderElement"""
        cdef void* ptr
        LLVMOrcCJITDylibSearchOrderElement.__allocate(&ptr)
        return LLVMOrcCJITDylibSearchOrderElement.fromPtr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCJITDylibSearchOrderElement fromValue(corc.LLVMOrcCJITDylibSearchOrderElement other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCJITDylibSearchOrderElement.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCJITDylibSearchOrderElement))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCJITDylibSearchOrderElement)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcCJITDylibSearchOrderElement object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCJITDylibSearchOrderElement.

        Constructor for type LLVMOrcCJITDylibSearchOrderElement.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCJITDylibSearchOrderElement.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_JDLookupFlags(self, i):
        """Get value of ``JDLookupFlags`` of ``(<corc.LLVMOrcCJITDylibSearchOrderElement*>self._ptr)[i]``.
        """
        return LLVMOrcJITDylibLookupFlags((<corc.LLVMOrcCJITDylibSearchOrderElement*>self._ptr)[i].JDLookupFlags)
    def set_JDLookupFlags(self, i, value):
        """Set value ``JDLookupFlags`` of ``(<corc.LLVMOrcCJITDylibSearchOrderElement*>self._ptr)[i]``.
        """
        if not isinstance(value, LLVMOrcJITDylibLookupFlags):
            raise TypeError("'value' must be of type 'LLVMOrcJITDylibLookupFlags'")
        (<corc.LLVMOrcCJITDylibSearchOrderElement*>self._ptr)[i].JDLookupFlags = value.value
    @property
    def JDLookupFlags(self):
        """(undocumented)"""
        return self.get_JDLookupFlags(0)
    @JDLookupFlags.setter
    def JDLookupFlags(self, value):
        self.set_JDLookupFlags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["JDLookupFlags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcCJITDylibSearchOrder = LLVMOrcCJITDylibSearchOrderElement

class _LLVMOrcSymbolLookupFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class LLVMOrcSymbolLookupFlags(_LLVMOrcSymbolLookupFlags__Base):
    """Symbol lookup flags for lookup sets. This should be kept in sync with llvm::orc::SymbolLookupFlags.

    Attributes:
        LLVMOrcSymbolLookupFlagsRequiredSymbol:
            (undocumented)
        LLVMOrcSymbolLookupFlagsWeaklyReferencedSymbol:
            (undocumented)
    """
    LLVMOrcSymbolLookupFlagsRequiredSymbol = corc.LLVMOrcSymbolLookupFlagsRequiredSymbol
    LLVMOrcSymbolLookupFlagsWeaklyReferencedSymbol = corc.LLVMOrcSymbolLookupFlagsWeaklyReferencedSymbol
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class LLVMOrcCLookupSetElement(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcCLookupSetElement.

    Python wrapper for cdef class corc.LLVMOrcCLookupSetElement.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcCLookupSetElement* getElementPtr(self):
        return <corc.LLVMOrcCLookupSetElement*>self._ptr

    @staticmethod
    cdef LLVMOrcCLookupSetElement fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCLookupSetElement`` objects from
        given ``corc.LLVMOrcCLookupSetElement`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCLookupSetElement wrapper = LLVMOrcCLookupSetElement.__new__(LLVMOrcCLookupSetElement)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcCLookupSetElement from a Python object.

        Derives a LLVMOrcCLookupSetElement from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCLookupSetElement`` reference, this method
        returns it directly. No new ``LLVMOrcCLookupSetElement`` is created in this case.
        """
        return LLVMOrcCLookupSetElement.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcCLookupSetElement fromPyobj(object pyobj):
        """Creates a LLVMOrcCLookupSetElement from a Python object.

        Derives a LLVMOrcCLookupSetElement from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCLookupSetElement`` reference, this method
        returns it directly. No new ``LLVMOrcCLookupSetElement`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcCLookupSetElement`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCLookupSetElement!
        """
        cdef LLVMOrcCLookupSetElement wrapper

        if isinstance(pyobj,LLVMOrcCLookupSetElement):
            return pyobj
        else:
            wrapper = LLVMOrcCLookupSetElement.__new__(LLVMOrcCLookupSetElement)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(corc.LLVMOrcCLookupSetElement))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCLookupSetElement))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCLookupSetElement new():
        """Factory function to create LLVMOrcCLookupSetElement objects with
        newly allocated corc.LLVMOrcCLookupSetElement"""
        cdef void* ptr
        LLVMOrcCLookupSetElement.__allocate(&ptr)
        return LLVMOrcCLookupSetElement.fromPtr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCLookupSetElement fromValue(corc.LLVMOrcCLookupSetElement other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCLookupSetElement.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCLookupSetElement))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCLookupSetElement)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcCLookupSetElement object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCLookupSetElement.

        Constructor for type LLVMOrcCLookupSetElement.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCLookupSetElement.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_LookupFlags(self, i):
        """Get value of ``LookupFlags`` of ``(<corc.LLVMOrcCLookupSetElement*>self._ptr)[i]``.
        """
        return LLVMOrcSymbolLookupFlags((<corc.LLVMOrcCLookupSetElement*>self._ptr)[i].LookupFlags)
    def set_LookupFlags(self, i, value):
        """Set value ``LookupFlags`` of ``(<corc.LLVMOrcCLookupSetElement*>self._ptr)[i]``.
        """
        if not isinstance(value, LLVMOrcSymbolLookupFlags):
            raise TypeError("'value' must be of type 'LLVMOrcSymbolLookupFlags'")
        (<corc.LLVMOrcCLookupSetElement*>self._ptr)[i].LookupFlags = value.value
    @property
    def LookupFlags(self):
        """(undocumented)"""
        return self.get_LookupFlags(0)
    @LookupFlags.setter
    def LookupFlags(self, value):
        self.set_LookupFlags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["LookupFlags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcCLookupSet = LLVMOrcCLookupSetElement

cdef class LLVMOrcOpaqueMaterializationUnit(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueMaterializationUnit.

    Python wrapper for cdef class corc.LLVMOrcOpaqueMaterializationUnit.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueMaterializationUnit* getElementPtr(self):
        return <corc.LLVMOrcOpaqueMaterializationUnit*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueMaterializationUnit fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueMaterializationUnit`` objects from
        given ``corc.LLVMOrcOpaqueMaterializationUnit`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueMaterializationUnit wrapper = LLVMOrcOpaqueMaterializationUnit.__new__(LLVMOrcOpaqueMaterializationUnit)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueMaterializationUnit from a Python object.

        Derives a LLVMOrcOpaqueMaterializationUnit from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueMaterializationUnit`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueMaterializationUnit`` is created in this case.
        """
        return LLVMOrcOpaqueMaterializationUnit.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueMaterializationUnit fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueMaterializationUnit from a Python object.

        Derives a LLVMOrcOpaqueMaterializationUnit from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueMaterializationUnit`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueMaterializationUnit`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueMaterializationUnit`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueMaterializationUnit!
        """
        cdef LLVMOrcOpaqueMaterializationUnit wrapper

        if isinstance(pyobj,LLVMOrcOpaqueMaterializationUnit):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueMaterializationUnit.__new__(LLVMOrcOpaqueMaterializationUnit)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueMaterializationUnit object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcMaterializationUnitRef = LLVMOrcOpaqueMaterializationUnit

cdef class LLVMOrcOpaqueMaterializationResponsibility(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueMaterializationResponsibility.

    Python wrapper for cdef class corc.LLVMOrcOpaqueMaterializationResponsibility.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueMaterializationResponsibility* getElementPtr(self):
        return <corc.LLVMOrcOpaqueMaterializationResponsibility*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueMaterializationResponsibility fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueMaterializationResponsibility`` objects from
        given ``corc.LLVMOrcOpaqueMaterializationResponsibility`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueMaterializationResponsibility wrapper = LLVMOrcOpaqueMaterializationResponsibility.__new__(LLVMOrcOpaqueMaterializationResponsibility)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueMaterializationResponsibility from a Python object.

        Derives a LLVMOrcOpaqueMaterializationResponsibility from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueMaterializationResponsibility`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueMaterializationResponsibility`` is created in this case.
        """
        return LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueMaterializationResponsibility fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueMaterializationResponsibility from a Python object.

        Derives a LLVMOrcOpaqueMaterializationResponsibility from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueMaterializationResponsibility`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueMaterializationResponsibility`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueMaterializationResponsibility`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueMaterializationResponsibility!
        """
        cdef LLVMOrcOpaqueMaterializationResponsibility wrapper

        if isinstance(pyobj,LLVMOrcOpaqueMaterializationResponsibility):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueMaterializationResponsibility.__new__(LLVMOrcOpaqueMaterializationResponsibility)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueMaterializationResponsibility object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcMaterializationResponsibilityRef = LLVMOrcOpaqueMaterializationResponsibility

cdef class LLVMOrcMaterializationUnitMaterializeFunction(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcMaterializationUnitMaterializeFunction.

    Python wrapper for cdef class corc.LLVMOrcMaterializationUnitMaterializeFunction.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcMaterializationUnitMaterializeFunction getElementPtr(self):
        return <corc.LLVMOrcMaterializationUnitMaterializeFunction>self._ptr

    @staticmethod
    cdef LLVMOrcMaterializationUnitMaterializeFunction fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcMaterializationUnitMaterializeFunction`` objects from
        given ``corc.LLVMOrcMaterializationUnitMaterializeFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcMaterializationUnitMaterializeFunction wrapper = LLVMOrcMaterializationUnitMaterializeFunction.__new__(LLVMOrcMaterializationUnitMaterializeFunction)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcMaterializationUnitMaterializeFunction from a Python object.

        Derives a LLVMOrcMaterializationUnitMaterializeFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcMaterializationUnitMaterializeFunction`` reference, this method
        returns it directly. No new ``LLVMOrcMaterializationUnitMaterializeFunction`` is created in this case.
        """
        return LLVMOrcMaterializationUnitMaterializeFunction.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcMaterializationUnitMaterializeFunction fromPyobj(object pyobj):
        """Creates a LLVMOrcMaterializationUnitMaterializeFunction from a Python object.

        Derives a LLVMOrcMaterializationUnitMaterializeFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcMaterializationUnitMaterializeFunction`` reference, this method
        returns it directly. No new ``LLVMOrcMaterializationUnitMaterializeFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcMaterializationUnitMaterializeFunction`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcMaterializationUnitMaterializeFunction!
        """
        cdef LLVMOrcMaterializationUnitMaterializeFunction wrapper

        if isinstance(pyobj,LLVMOrcMaterializationUnitMaterializeFunction):
            return pyobj
        else:
            wrapper = LLVMOrcMaterializationUnitMaterializeFunction.__new__(LLVMOrcMaterializationUnitMaterializeFunction)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcMaterializationUnitMaterializeFunction object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcMaterializationUnitDiscardFunction(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcMaterializationUnitDiscardFunction.

    Python wrapper for cdef class corc.LLVMOrcMaterializationUnitDiscardFunction.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcMaterializationUnitDiscardFunction getElementPtr(self):
        return <corc.LLVMOrcMaterializationUnitDiscardFunction>self._ptr

    @staticmethod
    cdef LLVMOrcMaterializationUnitDiscardFunction fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcMaterializationUnitDiscardFunction`` objects from
        given ``corc.LLVMOrcMaterializationUnitDiscardFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcMaterializationUnitDiscardFunction wrapper = LLVMOrcMaterializationUnitDiscardFunction.__new__(LLVMOrcMaterializationUnitDiscardFunction)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcMaterializationUnitDiscardFunction from a Python object.

        Derives a LLVMOrcMaterializationUnitDiscardFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcMaterializationUnitDiscardFunction`` reference, this method
        returns it directly. No new ``LLVMOrcMaterializationUnitDiscardFunction`` is created in this case.
        """
        return LLVMOrcMaterializationUnitDiscardFunction.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcMaterializationUnitDiscardFunction fromPyobj(object pyobj):
        """Creates a LLVMOrcMaterializationUnitDiscardFunction from a Python object.

        Derives a LLVMOrcMaterializationUnitDiscardFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcMaterializationUnitDiscardFunction`` reference, this method
        returns it directly. No new ``LLVMOrcMaterializationUnitDiscardFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcMaterializationUnitDiscardFunction`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcMaterializationUnitDiscardFunction!
        """
        cdef LLVMOrcMaterializationUnitDiscardFunction wrapper

        if isinstance(pyobj,LLVMOrcMaterializationUnitDiscardFunction):
            return pyobj
        else:
            wrapper = LLVMOrcMaterializationUnitDiscardFunction.__new__(LLVMOrcMaterializationUnitDiscardFunction)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcMaterializationUnitDiscardFunction object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcMaterializationUnitDestroyFunction(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcMaterializationUnitDestroyFunction.

    Python wrapper for cdef class corc.LLVMOrcMaterializationUnitDestroyFunction.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcMaterializationUnitDestroyFunction getElementPtr(self):
        return <corc.LLVMOrcMaterializationUnitDestroyFunction>self._ptr

    @staticmethod
    cdef LLVMOrcMaterializationUnitDestroyFunction fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcMaterializationUnitDestroyFunction`` objects from
        given ``corc.LLVMOrcMaterializationUnitDestroyFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcMaterializationUnitDestroyFunction wrapper = LLVMOrcMaterializationUnitDestroyFunction.__new__(LLVMOrcMaterializationUnitDestroyFunction)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcMaterializationUnitDestroyFunction from a Python object.

        Derives a LLVMOrcMaterializationUnitDestroyFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcMaterializationUnitDestroyFunction`` reference, this method
        returns it directly. No new ``LLVMOrcMaterializationUnitDestroyFunction`` is created in this case.
        """
        return LLVMOrcMaterializationUnitDestroyFunction.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcMaterializationUnitDestroyFunction fromPyobj(object pyobj):
        """Creates a LLVMOrcMaterializationUnitDestroyFunction from a Python object.

        Derives a LLVMOrcMaterializationUnitDestroyFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcMaterializationUnitDestroyFunction`` reference, this method
        returns it directly. No new ``LLVMOrcMaterializationUnitDestroyFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcMaterializationUnitDestroyFunction`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcMaterializationUnitDestroyFunction!
        """
        cdef LLVMOrcMaterializationUnitDestroyFunction wrapper

        if isinstance(pyobj,LLVMOrcMaterializationUnitDestroyFunction):
            return pyobj
        else:
            wrapper = LLVMOrcMaterializationUnitDestroyFunction.__new__(LLVMOrcMaterializationUnitDestroyFunction)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcMaterializationUnitDestroyFunction object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcOpaqueResourceTracker(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueResourceTracker.

    Python wrapper for cdef class corc.LLVMOrcOpaqueResourceTracker.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueResourceTracker* getElementPtr(self):
        return <corc.LLVMOrcOpaqueResourceTracker*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueResourceTracker fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueResourceTracker`` objects from
        given ``corc.LLVMOrcOpaqueResourceTracker`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueResourceTracker wrapper = LLVMOrcOpaqueResourceTracker.__new__(LLVMOrcOpaqueResourceTracker)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueResourceTracker from a Python object.

        Derives a LLVMOrcOpaqueResourceTracker from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueResourceTracker`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueResourceTracker`` is created in this case.
        """
        return LLVMOrcOpaqueResourceTracker.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueResourceTracker fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueResourceTracker from a Python object.

        Derives a LLVMOrcOpaqueResourceTracker from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueResourceTracker`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueResourceTracker`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueResourceTracker`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueResourceTracker!
        """
        cdef LLVMOrcOpaqueResourceTracker wrapper

        if isinstance(pyobj,LLVMOrcOpaqueResourceTracker):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueResourceTracker.__new__(LLVMOrcOpaqueResourceTracker)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueResourceTracker object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcResourceTrackerRef = LLVMOrcOpaqueResourceTracker

cdef class LLVMOrcOpaqueDefinitionGenerator(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueDefinitionGenerator.

    Python wrapper for cdef class corc.LLVMOrcOpaqueDefinitionGenerator.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueDefinitionGenerator* getElementPtr(self):
        return <corc.LLVMOrcOpaqueDefinitionGenerator*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueDefinitionGenerator fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueDefinitionGenerator`` objects from
        given ``corc.LLVMOrcOpaqueDefinitionGenerator`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueDefinitionGenerator wrapper = LLVMOrcOpaqueDefinitionGenerator.__new__(LLVMOrcOpaqueDefinitionGenerator)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueDefinitionGenerator from a Python object.

        Derives a LLVMOrcOpaqueDefinitionGenerator from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueDefinitionGenerator`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueDefinitionGenerator`` is created in this case.
        """
        return LLVMOrcOpaqueDefinitionGenerator.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueDefinitionGenerator fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueDefinitionGenerator from a Python object.

        Derives a LLVMOrcOpaqueDefinitionGenerator from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueDefinitionGenerator`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueDefinitionGenerator`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueDefinitionGenerator`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueDefinitionGenerator!
        """
        cdef LLVMOrcOpaqueDefinitionGenerator wrapper

        if isinstance(pyobj,LLVMOrcOpaqueDefinitionGenerator):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueDefinitionGenerator.__new__(LLVMOrcOpaqueDefinitionGenerator)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueDefinitionGenerator object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcDefinitionGeneratorRef = LLVMOrcOpaqueDefinitionGenerator

cdef class LLVMOrcOpaqueLookupState(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueLookupState.

    Python wrapper for cdef class corc.LLVMOrcOpaqueLookupState.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueLookupState* getElementPtr(self):
        return <corc.LLVMOrcOpaqueLookupState*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueLookupState fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueLookupState`` objects from
        given ``corc.LLVMOrcOpaqueLookupState`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueLookupState wrapper = LLVMOrcOpaqueLookupState.__new__(LLVMOrcOpaqueLookupState)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueLookupState from a Python object.

        Derives a LLVMOrcOpaqueLookupState from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueLookupState`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueLookupState`` is created in this case.
        """
        return LLVMOrcOpaqueLookupState.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueLookupState fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueLookupState from a Python object.

        Derives a LLVMOrcOpaqueLookupState from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueLookupState`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueLookupState`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueLookupState`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueLookupState!
        """
        cdef LLVMOrcOpaqueLookupState wrapper

        if isinstance(pyobj,LLVMOrcOpaqueLookupState):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueLookupState.__new__(LLVMOrcOpaqueLookupState)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueLookupState object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcLookupStateRef = LLVMOrcOpaqueLookupState

cdef class LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction.

    Python wrapper for cdef class corc.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction getElementPtr(self):
        return <corc.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction>self._ptr

    @staticmethod
    cdef LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`` objects from
        given ``corc.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction wrapper = LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction.__new__(LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction from a Python object.

        Derives a LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`` reference, this method
        returns it directly. No new ``LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`` is created in this case.
        """
        return LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction fromPyobj(object pyobj):
        """Creates a LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction from a Python object.

        Derives a LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`` reference, this method
        returns it directly. No new ``LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction!
        """
        cdef LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction wrapper

        if isinstance(pyobj,LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction):
            return pyobj
        else:
            wrapper = LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction.__new__(LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcDisposeCAPIDefinitionGeneratorFunction(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcDisposeCAPIDefinitionGeneratorFunction.

    Python wrapper for cdef class corc.LLVMOrcDisposeCAPIDefinitionGeneratorFunction.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcDisposeCAPIDefinitionGeneratorFunction getElementPtr(self):
        return <corc.LLVMOrcDisposeCAPIDefinitionGeneratorFunction>self._ptr

    @staticmethod
    cdef LLVMOrcDisposeCAPIDefinitionGeneratorFunction fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcDisposeCAPIDefinitionGeneratorFunction`` objects from
        given ``corc.LLVMOrcDisposeCAPIDefinitionGeneratorFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcDisposeCAPIDefinitionGeneratorFunction wrapper = LLVMOrcDisposeCAPIDefinitionGeneratorFunction.__new__(LLVMOrcDisposeCAPIDefinitionGeneratorFunction)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcDisposeCAPIDefinitionGeneratorFunction from a Python object.

        Derives a LLVMOrcDisposeCAPIDefinitionGeneratorFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcDisposeCAPIDefinitionGeneratorFunction`` reference, this method
        returns it directly. No new ``LLVMOrcDisposeCAPIDefinitionGeneratorFunction`` is created in this case.
        """
        return LLVMOrcDisposeCAPIDefinitionGeneratorFunction.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcDisposeCAPIDefinitionGeneratorFunction fromPyobj(object pyobj):
        """Creates a LLVMOrcDisposeCAPIDefinitionGeneratorFunction from a Python object.

        Derives a LLVMOrcDisposeCAPIDefinitionGeneratorFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcDisposeCAPIDefinitionGeneratorFunction`` reference, this method
        returns it directly. No new ``LLVMOrcDisposeCAPIDefinitionGeneratorFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcDisposeCAPIDefinitionGeneratorFunction`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcDisposeCAPIDefinitionGeneratorFunction!
        """
        cdef LLVMOrcDisposeCAPIDefinitionGeneratorFunction wrapper

        if isinstance(pyobj,LLVMOrcDisposeCAPIDefinitionGeneratorFunction):
            return pyobj
        else:
            wrapper = LLVMOrcDisposeCAPIDefinitionGeneratorFunction.__new__(LLVMOrcDisposeCAPIDefinitionGeneratorFunction)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcDisposeCAPIDefinitionGeneratorFunction object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcSymbolPredicate(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcSymbolPredicate.

    Python wrapper for cdef class corc.LLVMOrcSymbolPredicate.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcSymbolPredicate getElementPtr(self):
        return <corc.LLVMOrcSymbolPredicate>self._ptr

    @staticmethod
    cdef LLVMOrcSymbolPredicate fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcSymbolPredicate`` objects from
        given ``corc.LLVMOrcSymbolPredicate`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcSymbolPredicate wrapper = LLVMOrcSymbolPredicate.__new__(LLVMOrcSymbolPredicate)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcSymbolPredicate from a Python object.

        Derives a LLVMOrcSymbolPredicate from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcSymbolPredicate`` reference, this method
        returns it directly. No new ``LLVMOrcSymbolPredicate`` is created in this case.
        """
        return LLVMOrcSymbolPredicate.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcSymbolPredicate fromPyobj(object pyobj):
        """Creates a LLVMOrcSymbolPredicate from a Python object.

        Derives a LLVMOrcSymbolPredicate from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcSymbolPredicate`` reference, this method
        returns it directly. No new ``LLVMOrcSymbolPredicate`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcSymbolPredicate`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcSymbolPredicate!
        """
        cdef LLVMOrcSymbolPredicate wrapper

        if isinstance(pyobj,LLVMOrcSymbolPredicate):
            return pyobj
        else:
            wrapper = LLVMOrcSymbolPredicate.__new__(LLVMOrcSymbolPredicate)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcSymbolPredicate object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcOpaqueThreadSafeContext(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueThreadSafeContext.

    Python wrapper for cdef class corc.LLVMOrcOpaqueThreadSafeContext.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueThreadSafeContext* getElementPtr(self):
        return <corc.LLVMOrcOpaqueThreadSafeContext*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueThreadSafeContext fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueThreadSafeContext`` objects from
        given ``corc.LLVMOrcOpaqueThreadSafeContext`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueThreadSafeContext wrapper = LLVMOrcOpaqueThreadSafeContext.__new__(LLVMOrcOpaqueThreadSafeContext)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueThreadSafeContext from a Python object.

        Derives a LLVMOrcOpaqueThreadSafeContext from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueThreadSafeContext`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueThreadSafeContext`` is created in this case.
        """
        return LLVMOrcOpaqueThreadSafeContext.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueThreadSafeContext fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueThreadSafeContext from a Python object.

        Derives a LLVMOrcOpaqueThreadSafeContext from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueThreadSafeContext`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueThreadSafeContext`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueThreadSafeContext`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueThreadSafeContext!
        """
        cdef LLVMOrcOpaqueThreadSafeContext wrapper

        if isinstance(pyobj,LLVMOrcOpaqueThreadSafeContext):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueThreadSafeContext.__new__(LLVMOrcOpaqueThreadSafeContext)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueThreadSafeContext object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcThreadSafeContextRef = LLVMOrcOpaqueThreadSafeContext

cdef class LLVMOrcOpaqueThreadSafeModule(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueThreadSafeModule.

    Python wrapper for cdef class corc.LLVMOrcOpaqueThreadSafeModule.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueThreadSafeModule* getElementPtr(self):
        return <corc.LLVMOrcOpaqueThreadSafeModule*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueThreadSafeModule fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueThreadSafeModule`` objects from
        given ``corc.LLVMOrcOpaqueThreadSafeModule`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueThreadSafeModule wrapper = LLVMOrcOpaqueThreadSafeModule.__new__(LLVMOrcOpaqueThreadSafeModule)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueThreadSafeModule from a Python object.

        Derives a LLVMOrcOpaqueThreadSafeModule from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueThreadSafeModule`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueThreadSafeModule`` is created in this case.
        """
        return LLVMOrcOpaqueThreadSafeModule.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueThreadSafeModule fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueThreadSafeModule from a Python object.

        Derives a LLVMOrcOpaqueThreadSafeModule from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueThreadSafeModule`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueThreadSafeModule`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueThreadSafeModule`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueThreadSafeModule!
        """
        cdef LLVMOrcOpaqueThreadSafeModule wrapper

        if isinstance(pyobj,LLVMOrcOpaqueThreadSafeModule):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueThreadSafeModule.__new__(LLVMOrcOpaqueThreadSafeModule)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueThreadSafeModule object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcThreadSafeModuleRef = LLVMOrcOpaqueThreadSafeModule

cdef class LLVMOrcGenericIRModuleOperationFunction(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcGenericIRModuleOperationFunction.

    Python wrapper for cdef class corc.LLVMOrcGenericIRModuleOperationFunction.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcGenericIRModuleOperationFunction getElementPtr(self):
        return <corc.LLVMOrcGenericIRModuleOperationFunction>self._ptr

    @staticmethod
    cdef LLVMOrcGenericIRModuleOperationFunction fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcGenericIRModuleOperationFunction`` objects from
        given ``corc.LLVMOrcGenericIRModuleOperationFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcGenericIRModuleOperationFunction wrapper = LLVMOrcGenericIRModuleOperationFunction.__new__(LLVMOrcGenericIRModuleOperationFunction)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcGenericIRModuleOperationFunction from a Python object.

        Derives a LLVMOrcGenericIRModuleOperationFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcGenericIRModuleOperationFunction`` reference, this method
        returns it directly. No new ``LLVMOrcGenericIRModuleOperationFunction`` is created in this case.
        """
        return LLVMOrcGenericIRModuleOperationFunction.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcGenericIRModuleOperationFunction fromPyobj(object pyobj):
        """Creates a LLVMOrcGenericIRModuleOperationFunction from a Python object.

        Derives a LLVMOrcGenericIRModuleOperationFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcGenericIRModuleOperationFunction`` reference, this method
        returns it directly. No new ``LLVMOrcGenericIRModuleOperationFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcGenericIRModuleOperationFunction`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcGenericIRModuleOperationFunction!
        """
        cdef LLVMOrcGenericIRModuleOperationFunction wrapper

        if isinstance(pyobj,LLVMOrcGenericIRModuleOperationFunction):
            return pyobj
        else:
            wrapper = LLVMOrcGenericIRModuleOperationFunction.__new__(LLVMOrcGenericIRModuleOperationFunction)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcGenericIRModuleOperationFunction object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcOpaqueJITTargetMachineBuilder(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueJITTargetMachineBuilder.

    Python wrapper for cdef class corc.LLVMOrcOpaqueJITTargetMachineBuilder.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueJITTargetMachineBuilder* getElementPtr(self):
        return <corc.LLVMOrcOpaqueJITTargetMachineBuilder*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueJITTargetMachineBuilder fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueJITTargetMachineBuilder`` objects from
        given ``corc.LLVMOrcOpaqueJITTargetMachineBuilder`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueJITTargetMachineBuilder wrapper = LLVMOrcOpaqueJITTargetMachineBuilder.__new__(LLVMOrcOpaqueJITTargetMachineBuilder)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueJITTargetMachineBuilder from a Python object.

        Derives a LLVMOrcOpaqueJITTargetMachineBuilder from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueJITTargetMachineBuilder`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueJITTargetMachineBuilder`` is created in this case.
        """
        return LLVMOrcOpaqueJITTargetMachineBuilder.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueJITTargetMachineBuilder fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueJITTargetMachineBuilder from a Python object.

        Derives a LLVMOrcOpaqueJITTargetMachineBuilder from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueJITTargetMachineBuilder`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueJITTargetMachineBuilder`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueJITTargetMachineBuilder`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueJITTargetMachineBuilder!
        """
        cdef LLVMOrcOpaqueJITTargetMachineBuilder wrapper

        if isinstance(pyobj,LLVMOrcOpaqueJITTargetMachineBuilder):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueJITTargetMachineBuilder.__new__(LLVMOrcOpaqueJITTargetMachineBuilder)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueJITTargetMachineBuilder object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcJITTargetMachineBuilderRef = LLVMOrcOpaqueJITTargetMachineBuilder

cdef class LLVMOrcOpaqueObjectLayer(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueObjectLayer.

    Python wrapper for cdef class corc.LLVMOrcOpaqueObjectLayer.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueObjectLayer* getElementPtr(self):
        return <corc.LLVMOrcOpaqueObjectLayer*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueObjectLayer fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueObjectLayer`` objects from
        given ``corc.LLVMOrcOpaqueObjectLayer`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueObjectLayer wrapper = LLVMOrcOpaqueObjectLayer.__new__(LLVMOrcOpaqueObjectLayer)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueObjectLayer from a Python object.

        Derives a LLVMOrcOpaqueObjectLayer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueObjectLayer`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueObjectLayer`` is created in this case.
        """
        return LLVMOrcOpaqueObjectLayer.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueObjectLayer fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueObjectLayer from a Python object.

        Derives a LLVMOrcOpaqueObjectLayer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueObjectLayer`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueObjectLayer`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueObjectLayer`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueObjectLayer!
        """
        cdef LLVMOrcOpaqueObjectLayer wrapper

        if isinstance(pyobj,LLVMOrcOpaqueObjectLayer):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueObjectLayer.__new__(LLVMOrcOpaqueObjectLayer)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueObjectLayer object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcObjectLayerRef = LLVMOrcOpaqueObjectLayer

cdef class LLVMOrcOpaqueObjectLinkingLayer(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueObjectLinkingLayer.

    Python wrapper for cdef class corc.LLVMOrcOpaqueObjectLinkingLayer.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueObjectLinkingLayer* getElementPtr(self):
        return <corc.LLVMOrcOpaqueObjectLinkingLayer*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueObjectLinkingLayer fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueObjectLinkingLayer`` objects from
        given ``corc.LLVMOrcOpaqueObjectLinkingLayer`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueObjectLinkingLayer wrapper = LLVMOrcOpaqueObjectLinkingLayer.__new__(LLVMOrcOpaqueObjectLinkingLayer)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueObjectLinkingLayer from a Python object.

        Derives a LLVMOrcOpaqueObjectLinkingLayer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueObjectLinkingLayer`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueObjectLinkingLayer`` is created in this case.
        """
        return LLVMOrcOpaqueObjectLinkingLayer.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueObjectLinkingLayer fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueObjectLinkingLayer from a Python object.

        Derives a LLVMOrcOpaqueObjectLinkingLayer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueObjectLinkingLayer`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueObjectLinkingLayer`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueObjectLinkingLayer`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueObjectLinkingLayer!
        """
        cdef LLVMOrcOpaqueObjectLinkingLayer wrapper

        if isinstance(pyobj,LLVMOrcOpaqueObjectLinkingLayer):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueObjectLinkingLayer.__new__(LLVMOrcOpaqueObjectLinkingLayer)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueObjectLinkingLayer object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcObjectLinkingLayerRef = LLVMOrcOpaqueObjectLinkingLayer

cdef class LLVMOrcOpaqueIRTransformLayer(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueIRTransformLayer.

    Python wrapper for cdef class corc.LLVMOrcOpaqueIRTransformLayer.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueIRTransformLayer* getElementPtr(self):
        return <corc.LLVMOrcOpaqueIRTransformLayer*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueIRTransformLayer fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueIRTransformLayer`` objects from
        given ``corc.LLVMOrcOpaqueIRTransformLayer`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueIRTransformLayer wrapper = LLVMOrcOpaqueIRTransformLayer.__new__(LLVMOrcOpaqueIRTransformLayer)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueIRTransformLayer from a Python object.

        Derives a LLVMOrcOpaqueIRTransformLayer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueIRTransformLayer`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueIRTransformLayer`` is created in this case.
        """
        return LLVMOrcOpaqueIRTransformLayer.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueIRTransformLayer fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueIRTransformLayer from a Python object.

        Derives a LLVMOrcOpaqueIRTransformLayer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueIRTransformLayer`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueIRTransformLayer`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueIRTransformLayer`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueIRTransformLayer!
        """
        cdef LLVMOrcOpaqueIRTransformLayer wrapper

        if isinstance(pyobj,LLVMOrcOpaqueIRTransformLayer):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueIRTransformLayer.__new__(LLVMOrcOpaqueIRTransformLayer)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueIRTransformLayer object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcIRTransformLayerRef = LLVMOrcOpaqueIRTransformLayer

cdef class LLVMOrcIRTransformLayerTransformFunction(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcIRTransformLayerTransformFunction.

    Python wrapper for cdef class corc.LLVMOrcIRTransformLayerTransformFunction.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcIRTransformLayerTransformFunction getElementPtr(self):
        return <corc.LLVMOrcIRTransformLayerTransformFunction>self._ptr

    @staticmethod
    cdef LLVMOrcIRTransformLayerTransformFunction fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcIRTransformLayerTransformFunction`` objects from
        given ``corc.LLVMOrcIRTransformLayerTransformFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcIRTransformLayerTransformFunction wrapper = LLVMOrcIRTransformLayerTransformFunction.__new__(LLVMOrcIRTransformLayerTransformFunction)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcIRTransformLayerTransformFunction from a Python object.

        Derives a LLVMOrcIRTransformLayerTransformFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcIRTransformLayerTransformFunction`` reference, this method
        returns it directly. No new ``LLVMOrcIRTransformLayerTransformFunction`` is created in this case.
        """
        return LLVMOrcIRTransformLayerTransformFunction.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcIRTransformLayerTransformFunction fromPyobj(object pyobj):
        """Creates a LLVMOrcIRTransformLayerTransformFunction from a Python object.

        Derives a LLVMOrcIRTransformLayerTransformFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcIRTransformLayerTransformFunction`` reference, this method
        returns it directly. No new ``LLVMOrcIRTransformLayerTransformFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcIRTransformLayerTransformFunction`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcIRTransformLayerTransformFunction!
        """
        cdef LLVMOrcIRTransformLayerTransformFunction wrapper

        if isinstance(pyobj,LLVMOrcIRTransformLayerTransformFunction):
            return pyobj
        else:
            wrapper = LLVMOrcIRTransformLayerTransformFunction.__new__(LLVMOrcIRTransformLayerTransformFunction)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcIRTransformLayerTransformFunction object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcOpaqueObjectTransformLayer(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueObjectTransformLayer.

    Python wrapper for cdef class corc.LLVMOrcOpaqueObjectTransformLayer.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueObjectTransformLayer* getElementPtr(self):
        return <corc.LLVMOrcOpaqueObjectTransformLayer*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueObjectTransformLayer fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueObjectTransformLayer`` objects from
        given ``corc.LLVMOrcOpaqueObjectTransformLayer`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueObjectTransformLayer wrapper = LLVMOrcOpaqueObjectTransformLayer.__new__(LLVMOrcOpaqueObjectTransformLayer)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueObjectTransformLayer from a Python object.

        Derives a LLVMOrcOpaqueObjectTransformLayer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueObjectTransformLayer`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueObjectTransformLayer`` is created in this case.
        """
        return LLVMOrcOpaqueObjectTransformLayer.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueObjectTransformLayer fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueObjectTransformLayer from a Python object.

        Derives a LLVMOrcOpaqueObjectTransformLayer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueObjectTransformLayer`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueObjectTransformLayer`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueObjectTransformLayer`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueObjectTransformLayer!
        """
        cdef LLVMOrcOpaqueObjectTransformLayer wrapper

        if isinstance(pyobj,LLVMOrcOpaqueObjectTransformLayer):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueObjectTransformLayer.__new__(LLVMOrcOpaqueObjectTransformLayer)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueObjectTransformLayer object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcObjectTransformLayerRef = LLVMOrcOpaqueObjectTransformLayer

cdef class LLVMOrcObjectTransformLayerTransformFunction(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcObjectTransformLayerTransformFunction.

    Python wrapper for cdef class corc.LLVMOrcObjectTransformLayerTransformFunction.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcObjectTransformLayerTransformFunction getElementPtr(self):
        return <corc.LLVMOrcObjectTransformLayerTransformFunction>self._ptr

    @staticmethod
    cdef LLVMOrcObjectTransformLayerTransformFunction fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcObjectTransformLayerTransformFunction`` objects from
        given ``corc.LLVMOrcObjectTransformLayerTransformFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcObjectTransformLayerTransformFunction wrapper = LLVMOrcObjectTransformLayerTransformFunction.__new__(LLVMOrcObjectTransformLayerTransformFunction)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcObjectTransformLayerTransformFunction from a Python object.

        Derives a LLVMOrcObjectTransformLayerTransformFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcObjectTransformLayerTransformFunction`` reference, this method
        returns it directly. No new ``LLVMOrcObjectTransformLayerTransformFunction`` is created in this case.
        """
        return LLVMOrcObjectTransformLayerTransformFunction.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcObjectTransformLayerTransformFunction fromPyobj(object pyobj):
        """Creates a LLVMOrcObjectTransformLayerTransformFunction from a Python object.

        Derives a LLVMOrcObjectTransformLayerTransformFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcObjectTransformLayerTransformFunction`` reference, this method
        returns it directly. No new ``LLVMOrcObjectTransformLayerTransformFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcObjectTransformLayerTransformFunction`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcObjectTransformLayerTransformFunction!
        """
        cdef LLVMOrcObjectTransformLayerTransformFunction wrapper

        if isinstance(pyobj,LLVMOrcObjectTransformLayerTransformFunction):
            return pyobj
        else:
            wrapper = LLVMOrcObjectTransformLayerTransformFunction.__new__(LLVMOrcObjectTransformLayerTransformFunction)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcObjectTransformLayerTransformFunction object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcOpaqueIndirectStubsManager(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueIndirectStubsManager.

    Python wrapper for cdef class corc.LLVMOrcOpaqueIndirectStubsManager.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueIndirectStubsManager* getElementPtr(self):
        return <corc.LLVMOrcOpaqueIndirectStubsManager*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueIndirectStubsManager fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueIndirectStubsManager`` objects from
        given ``corc.LLVMOrcOpaqueIndirectStubsManager`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueIndirectStubsManager wrapper = LLVMOrcOpaqueIndirectStubsManager.__new__(LLVMOrcOpaqueIndirectStubsManager)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueIndirectStubsManager from a Python object.

        Derives a LLVMOrcOpaqueIndirectStubsManager from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueIndirectStubsManager`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueIndirectStubsManager`` is created in this case.
        """
        return LLVMOrcOpaqueIndirectStubsManager.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueIndirectStubsManager fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueIndirectStubsManager from a Python object.

        Derives a LLVMOrcOpaqueIndirectStubsManager from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueIndirectStubsManager`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueIndirectStubsManager`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueIndirectStubsManager`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueIndirectStubsManager!
        """
        cdef LLVMOrcOpaqueIndirectStubsManager wrapper

        if isinstance(pyobj,LLVMOrcOpaqueIndirectStubsManager):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueIndirectStubsManager.__new__(LLVMOrcOpaqueIndirectStubsManager)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueIndirectStubsManager object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcIndirectStubsManagerRef = LLVMOrcOpaqueIndirectStubsManager

cdef class LLVMOrcOpaqueLazyCallThroughManager(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueLazyCallThroughManager.

    Python wrapper for cdef class corc.LLVMOrcOpaqueLazyCallThroughManager.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueLazyCallThroughManager* getElementPtr(self):
        return <corc.LLVMOrcOpaqueLazyCallThroughManager*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueLazyCallThroughManager fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueLazyCallThroughManager`` objects from
        given ``corc.LLVMOrcOpaqueLazyCallThroughManager`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueLazyCallThroughManager wrapper = LLVMOrcOpaqueLazyCallThroughManager.__new__(LLVMOrcOpaqueLazyCallThroughManager)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueLazyCallThroughManager from a Python object.

        Derives a LLVMOrcOpaqueLazyCallThroughManager from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueLazyCallThroughManager`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueLazyCallThroughManager`` is created in this case.
        """
        return LLVMOrcOpaqueLazyCallThroughManager.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueLazyCallThroughManager fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueLazyCallThroughManager from a Python object.

        Derives a LLVMOrcOpaqueLazyCallThroughManager from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueLazyCallThroughManager`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueLazyCallThroughManager`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueLazyCallThroughManager`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueLazyCallThroughManager!
        """
        cdef LLVMOrcOpaqueLazyCallThroughManager wrapper

        if isinstance(pyobj,LLVMOrcOpaqueLazyCallThroughManager):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueLazyCallThroughManager.__new__(LLVMOrcOpaqueLazyCallThroughManager)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueLazyCallThroughManager object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcLazyCallThroughManagerRef = LLVMOrcOpaqueLazyCallThroughManager

cdef class LLVMOrcOpaqueDumpObjects(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcOpaqueDumpObjects.

    Python wrapper for cdef class corc.LLVMOrcOpaqueDumpObjects.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcOpaqueDumpObjects* getElementPtr(self):
        return <corc.LLVMOrcOpaqueDumpObjects*>self._ptr

    @staticmethod
    cdef LLVMOrcOpaqueDumpObjects fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueDumpObjects`` objects from
        given ``corc.LLVMOrcOpaqueDumpObjects`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueDumpObjects wrapper = LLVMOrcOpaqueDumpObjects.__new__(LLVMOrcOpaqueDumpObjects)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcOpaqueDumpObjects from a Python object.

        Derives a LLVMOrcOpaqueDumpObjects from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueDumpObjects`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueDumpObjects`` is created in this case.
        """
        return LLVMOrcOpaqueDumpObjects.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcOpaqueDumpObjects fromPyobj(object pyobj):
        """Creates a LLVMOrcOpaqueDumpObjects from a Python object.

        Derives a LLVMOrcOpaqueDumpObjects from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueDumpObjects`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueDumpObjects`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcOpaqueDumpObjects`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueDumpObjects!
        """
        cdef LLVMOrcOpaqueDumpObjects wrapper

        if isinstance(pyobj,LLVMOrcOpaqueDumpObjects):
            return pyobj
        else:
            wrapper = LLVMOrcOpaqueDumpObjects.__new__(LLVMOrcOpaqueDumpObjects)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcOpaqueDumpObjects object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcDumpObjectsRef = LLVMOrcOpaqueDumpObjects

@cython.embedsignature(True)
def LLVMOrcExecutionSessionSetErrorReporter(object ES, object ReportError, object Ctx):
    r"""(No short description, might be part of a group.)

    Attach a custom error reporter function to the ExecutionSession.

    The error reporter will be called to deliver failure notices that can not be
    directly reported to a caller. For example, failure to resolve symbols in
    the JIT linker is typically reported via the error reporter (callers
    requesting definitions from the JIT will typically be delivered a
    FailureToMaterialize error instead).

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        ReportError (`~.LLVMOrcErrorReporterFunction`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcExecutionSessionSetErrorReporter(
        LLVMOrcOpaqueExecutionSession.fromPyobj(ES).getElementPtr(),
        LLVMOrcErrorReporterFunction.fromPyobj(ReportError).getElementPtr(),
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(Ctx)._ptr)


@cython.embedsignature(True)
def LLVMOrcExecutionSessionGetSymbolStringPool(object ES):
    r"""(No short description, might be part of a group.)

    Return a reference to the SymbolStringPool for an ExecutionSession.

    Ownership of the pool remains with the ExecutionSession: The caller is
    not required to free the pool.

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)
    """
    _LLVMOrcExecutionSessionGetSymbolStringPool__retval = LLVMOrcOpaqueSymbolStringPool.fromPtr(corc.LLVMOrcExecutionSessionGetSymbolStringPool(
        LLVMOrcOpaqueExecutionSession.fromPyobj(ES).getElementPtr()))
    return None if _LLVMOrcExecutionSessionGetSymbolStringPool__retval._ptr == NULL else _LLVMOrcExecutionSessionGetSymbolStringPool__retval


@cython.embedsignature(True)
def LLVMOrcSymbolStringPoolClearDeadEntries(object SSP):
    r"""(No short description, might be part of a group.)

    Clear all unreferenced symbol string pool entries.

    This can be called at any time to release unused entries in the
    ExecutionSession's string pool. Since it locks the pool (preventing
    interning of any new strings) it is recommended that it only be called
    infrequently, ideally when the caller has reason to believe that some
    entries will have become unreferenced, e.g. after removing a module or
    closing a JITDylib.

    Args:
        SSP (`~.LLVMOrcOpaqueSymbolStringPool`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcSymbolStringPoolClearDeadEntries(
        LLVMOrcOpaqueSymbolStringPool.fromPyobj(SSP).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcExecutionSessionIntern(object ES, object Name):
    r"""(No short description, might be part of a group.)

    Intern a string in the ExecutionSession's SymbolStringPool and return a
    reference to it. This increments the ref-count of the pool entry, and the
    returned value should be released once the client is done with it by
    calling LLVMOrcReleaseSymbolStringPoolEntry.

    Since strings are uniqued within the SymbolStringPool
    LLVMOrcSymbolStringPoolEntryRefs can be compared by value to test string
    equality.

    Note that this function does not perform linker-mangling on the string.

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        Name (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    _LLVMOrcExecutionSessionIntern__retval = LLVMOrcOpaqueSymbolStringPoolEntry.fromPtr(corc.LLVMOrcExecutionSessionIntern(
        LLVMOrcOpaqueExecutionSession.fromPyobj(ES).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(Name)._ptr))
    return None if _LLVMOrcExecutionSessionIntern__retval._ptr == NULL else _LLVMOrcExecutionSessionIntern__retval


cdef class LLVMOrcExecutionSessionLookupHandleResultFunction(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class corc.LLVMOrcExecutionSessionLookupHandleResultFunction.

    Python wrapper for cdef class corc.LLVMOrcExecutionSessionLookupHandleResultFunction.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef corc.LLVMOrcExecutionSessionLookupHandleResultFunction getElementPtr(self):
        return <corc.LLVMOrcExecutionSessionLookupHandleResultFunction>self._ptr

    @staticmethod
    cdef LLVMOrcExecutionSessionLookupHandleResultFunction fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcExecutionSessionLookupHandleResultFunction`` objects from
        given ``corc.LLVMOrcExecutionSessionLookupHandleResultFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcExecutionSessionLookupHandleResultFunction wrapper = LLVMOrcExecutionSessionLookupHandleResultFunction.__new__(LLVMOrcExecutionSessionLookupHandleResultFunction)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOrcExecutionSessionLookupHandleResultFunction from a Python object.

        Derives a LLVMOrcExecutionSessionLookupHandleResultFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcExecutionSessionLookupHandleResultFunction`` reference, this method
        returns it directly. No new ``LLVMOrcExecutionSessionLookupHandleResultFunction`` is created in this case.
        """
        return LLVMOrcExecutionSessionLookupHandleResultFunction.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOrcExecutionSessionLookupHandleResultFunction fromPyobj(object pyobj):
        """Creates a LLVMOrcExecutionSessionLookupHandleResultFunction from a Python object.

        Derives a LLVMOrcExecutionSessionLookupHandleResultFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcExecutionSessionLookupHandleResultFunction`` reference, this method
        returns it directly. No new ``LLVMOrcExecutionSessionLookupHandleResultFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOrcExecutionSessionLookupHandleResultFunction`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcExecutionSessionLookupHandleResultFunction!
        """
        cdef LLVMOrcExecutionSessionLookupHandleResultFunction wrapper

        if isinstance(pyobj,LLVMOrcExecutionSessionLookupHandleResultFunction):
            return pyobj
        else:
            wrapper = LLVMOrcExecutionSessionLookupHandleResultFunction.__new__(LLVMOrcExecutionSessionLookupHandleResultFunction)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOrcExecutionSessionLookupHandleResultFunction object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def LLVMOrcExecutionSessionLookup(object ES, object K, object SearchOrder, unsigned long SearchOrderSize, object Symbols, unsigned long SymbolsSize, object HandleResult, object Ctx):
    r"""(No short description, might be part of a group.)

    Look up symbols in an execution session.

    This is a wrapper around the general ExecutionSession`~.lookup` function.

    The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags)
    pairs that describe the search order. The JITDylibs will be searched in the
    given order to try to find the symbols in the Symbols argument.

    The Symbols argument should contain a null-terminated array of
    (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be
    searched for. This function takes ownership of the elements of the Symbols
    array. The Name fields of the Symbols elements are taken to have been
    retained by the client for this function. The client should *not* release the
    Name fields, but are still responsible for destroying the array itself.

    The HandleResult function will be called once all searched for symbols have
    been found, or an error occurs. The HandleResult function will be passed an
    LLVMErrorRef indicating success or failure, and (on success) a
    null-terminated LLVMOrcCSymbolMapPairs array containing the function result,
    and the Ctx value passed to the lookup function.

    The client is fully responsible for managing the lifetime of the Ctx object.
    A common idiom is to allocate the context prior to the lookup and deallocate
    it in the handler.

    THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        K (`~.LLVMOrcLookupKind`):
            (undocumented)

        SearchOrder (`~.LLVMOrcCJITDylibSearchOrderElement`/`~.object`):
            (undocumented)

        SearchOrderSize (`~.int`):
            (undocumented)

        Symbols (`~.LLVMOrcCLookupSetElement`/`~.object`):
            (undocumented)

        SymbolsSize (`~.int`):
            (undocumented)

        HandleResult (`~.LLVMOrcExecutionSessionLookupHandleResultFunction`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(K,_LLVMOrcLookupKind__Base):
        raise TypeError("argument 'K' must be of type '_LLVMOrcLookupKind__Base'")
    corc.LLVMOrcExecutionSessionLookup(
        LLVMOrcOpaqueExecutionSession.fromPyobj(ES).getElementPtr(),K.value,
        LLVMOrcCJITDylibSearchOrderElement.fromPyobj(SearchOrder).getElementPtr(),SearchOrderSize,
        LLVMOrcCLookupSetElement.fromPyobj(Symbols).getElementPtr(),SymbolsSize,
        LLVMOrcExecutionSessionLookupHandleResultFunction.fromPyobj(HandleResult).getElementPtr(),
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(Ctx)._ptr)


@cython.embedsignature(True)
def LLVMOrcRetainSymbolStringPoolEntry(object S):
    r"""(No short description, might be part of a group.)

    Increments the ref-count for a SymbolStringPool entry.

    Args:
        S (`~.LLVMOrcOpaqueSymbolStringPoolEntry`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcRetainSymbolStringPoolEntry(
        LLVMOrcOpaqueSymbolStringPoolEntry.fromPyobj(S).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcReleaseSymbolStringPoolEntry(object S):
    r"""(No short description, might be part of a group.)

    Reduces the ref-count for of a SymbolStringPool entry.

    Args:
        S (`~.LLVMOrcOpaqueSymbolStringPoolEntry`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcReleaseSymbolStringPoolEntry(
        LLVMOrcOpaqueSymbolStringPoolEntry.fromPyobj(S).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcSymbolStringPoolEntryStr(object S):
    r"""(No short description, might be part of a group.)

    Return the c-string for the given symbol. This string will remain valid until
    the entry is freed (once all LLVMOrcSymbolStringPoolEntryRefs have been
    released).

    Args:
        S (`~.LLVMOrcOpaqueSymbolStringPoolEntry`/`~.object`):
            (undocumented)
    """
    _LLVMOrcSymbolStringPoolEntryStr__retval = rocm.llvm._util.types.CStr.fromPtr(<void*>corc.LLVMOrcSymbolStringPoolEntryStr(
        LLVMOrcOpaqueSymbolStringPoolEntry.fromPyobj(S).getElementPtr()))
    return None if _LLVMOrcSymbolStringPoolEntryStr__retval._ptr == NULL else _LLVMOrcSymbolStringPoolEntryStr__retval


@cython.embedsignature(True)
def LLVMOrcReleaseResourceTracker(object RT):
    r"""(No short description, might be part of a group.)

    Reduces the ref-count of a ResourceTracker.

    Args:
        RT (`~.LLVMOrcOpaqueResourceTracker`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcReleaseResourceTracker(
        LLVMOrcOpaqueResourceTracker.fromPyobj(RT).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcResourceTrackerTransferTo(object SrcRT, object DstRT):
    r"""(No short description, might be part of a group.)

    Transfers tracking of all resources associated with resource tracker SrcRT
    to resource tracker DstRT.

    Args:
        SrcRT (`~.LLVMOrcOpaqueResourceTracker`/`~.object`):
            (undocumented)

        DstRT (`~.LLVMOrcOpaqueResourceTracker`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcResourceTrackerTransferTo(
        LLVMOrcOpaqueResourceTracker.fromPyobj(SrcRT).getElementPtr(),
        LLVMOrcOpaqueResourceTracker.fromPyobj(DstRT).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcResourceTrackerRemove(object RT):
    r"""(No short description, might be part of a group.)

    Remove all resources associated with the given tracker. See
    ResourceTracker`~.remove`().

    Args:
        RT (`~.LLVMOrcOpaqueResourceTracker`/`~.object`):
            (undocumented)
    """
    _LLVMOrcResourceTrackerRemove__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcResourceTrackerRemove(
        LLVMOrcOpaqueResourceTracker.fromPyobj(RT).getElementPtr()))
    return None if _LLVMOrcResourceTrackerRemove__retval._ptr == NULL else _LLVMOrcResourceTrackerRemove__retval


@cython.embedsignature(True)
def LLVMOrcDisposeDefinitionGenerator(object DG):
    r"""(No short description, might be part of a group.)

    Dispose of a JITDylib`~.DefinitionGenerator`. This should only be called if
    ownership has not been passed to a JITDylib (e.g. because some error
    prevented the client from calling LLVMOrcJITDylibAddGenerator).

    Args:
        DG (`~.LLVMOrcOpaqueDefinitionGenerator`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeDefinitionGenerator(
        LLVMOrcOpaqueDefinitionGenerator.fromPyobj(DG).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcDisposeMaterializationUnit(object MU):
    r"""(No short description, might be part of a group.)

    Dispose of a MaterializationUnit.

    Args:
        MU (`~.LLVMOrcOpaqueMaterializationUnit`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeMaterializationUnit(
        LLVMOrcOpaqueMaterializationUnit.fromPyobj(MU).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcCreateCustomMaterializationUnit(object Name, object Ctx, object Syms, unsigned long NumSyms, object InitSym, object Materialize, object Discard, object Destroy):
    r"""(No short description, might be part of a group.)

    Create a custom MaterializationUnit.

    Name is a name for this MaterializationUnit to be used for identification
    and logging purposes (e.g. if this MaterializationUnit produces an
    object buffer then the name of that buffer will be derived from this name).

    The Syms list contains the names and linkages of the symbols provided by this
    unit. This function takes ownership of the elements of the Syms array. The
    Name fields of the array elements are taken to have been retained for this
    function. The client should *not* release the elements of the array, but is
    still responsible for destroying the array itself.

    The InitSym argument indicates whether or not this MaterializationUnit
    contains static initializers. If three are no static initializers (the common
    case) then this argument should be null. If there are static initializers
    then InitSym should be set to a unique name that also appears in the Syms
    list with the LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly flag
    set. This function takes ownership of the InitSym, which should have been
    retained twice on behalf of this function: once for the Syms entry and once
    for InitSym. If clients wish to use the InitSym value after this function
    returns they must retain it once more for themselves.

    If any of the symbols in the Syms list is looked up then the Materialize
    function will be called.

    If any of the symbols in the Syms list is overridden then the Discard
    function will be called.

    The caller owns the underling MaterializationUnit and is responsible for
    either passing it to a JITDylib (via LLVMOrcJITDylibDefine) or disposing
    of it by calling LLVMOrcDisposeMaterializationUnit.

    Args:
        Name (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        Syms (`~.LLVMOrcCSymbolFlagsMapPair`/`~.object`):
            (undocumented)

        NumSyms (`~.int`):
            (undocumented)

        InitSym (`~.LLVMOrcOpaqueSymbolStringPoolEntry`/`~.object`):
            (undocumented)

        Materialize (`~.LLVMOrcMaterializationUnitMaterializeFunction`/`~.object`):
            (undocumented)

        Discard (`~.LLVMOrcMaterializationUnitDiscardFunction`/`~.object`):
            (undocumented)

        Destroy (`~.LLVMOrcMaterializationUnitDestroyFunction`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateCustomMaterializationUnit__retval = LLVMOrcOpaqueMaterializationUnit.fromPtr(corc.LLVMOrcCreateCustomMaterializationUnit(
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(Name)._ptr,
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(Ctx)._ptr,
        LLVMOrcCSymbolFlagsMapPair.fromPyobj(Syms).getElementPtr(),NumSyms,
        LLVMOrcOpaqueSymbolStringPoolEntry.fromPyobj(InitSym).getElementPtr(),
        LLVMOrcMaterializationUnitMaterializeFunction.fromPyobj(Materialize).getElementPtr(),
        LLVMOrcMaterializationUnitDiscardFunction.fromPyobj(Discard).getElementPtr(),
        LLVMOrcMaterializationUnitDestroyFunction.fromPyobj(Destroy).getElementPtr()))
    return None if _LLVMOrcCreateCustomMaterializationUnit__retval._ptr == NULL else _LLVMOrcCreateCustomMaterializationUnit__retval


@cython.embedsignature(True)
def LLVMOrcAbsoluteSymbols(object Syms, unsigned long NumPairs):
    r"""(No short description, might be part of a group.)

    Create a MaterializationUnit to define the given symbols as pointing to
    the corresponding raw addresses.

    This function takes ownership of the elements of the Syms array. The Name
    fields of the array elements are taken to have been retained for this
    function. This allows the following pattern...

      size_t NumPairs;
      LLVMOrcCSymbolMapPairs Sym;
      -- Build Syms array --
      LLVMOrcMaterializationUnitRef MU =
          LLVMOrcAbsoluteSymbols(Syms, NumPairs);

    ... without requiring cleanup of the elements of the Sym array afterwards.

    The client is still responsible for deleting the Sym array itself.

    If a client wishes to reuse elements of the Sym array after this call they
    must explicitly retain each of the elements for themselves.

    Args:
        Syms (`~.LLVMOrcCSymbolMapPair`/`~.object`):
            (undocumented)

        NumPairs (`~.int`):
            (undocumented)
    """
    _LLVMOrcAbsoluteSymbols__retval = LLVMOrcOpaqueMaterializationUnit.fromPtr(corc.LLVMOrcAbsoluteSymbols(
        LLVMOrcCSymbolMapPair.fromPyobj(Syms).getElementPtr(),NumPairs))
    return None if _LLVMOrcAbsoluteSymbols__retval._ptr == NULL else _LLVMOrcAbsoluteSymbols__retval


@cython.embedsignature(True)
def LLVMOrcLazyReexports(object LCTM, object ISM, object SourceRef, object CallableAliases, unsigned long NumPairs):
    r"""(No short description, might be part of a group.)

    Create a MaterializationUnit to define lazy re-expots. These are callable
    entry points that call through to the given symbols.

    This function takes ownership of the CallableAliases array. The Name
    fields of the array elements are taken to have been retained for this
    function. This allows the following pattern...

      size_t NumPairs;
      LLVMOrcCSymbolAliasMapPairs CallableAliases;
      -- Build CallableAliases array --
      LLVMOrcMaterializationUnitRef MU =
         LLVMOrcLazyReexports(LCTM, ISM, JD, CallableAliases, NumPairs);

    ... without requiring cleanup of the elements of the CallableAliases array afterwards.

    The client is still responsible for deleting the CallableAliases array itself.

    If a client wishes to reuse elements of the CallableAliases array after this call they
    must explicitly retain each of the elements for themselves.

    Args:
        LCTM (`~.LLVMOrcOpaqueLazyCallThroughManager`/`~.object`):
            (undocumented)

        ISM (`~.LLVMOrcOpaqueIndirectStubsManager`/`~.object`):
            (undocumented)

        SourceRef (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)

        CallableAliases (`~.LLVMOrcCSymbolAliasMapPair`/`~.object`):
            (undocumented)

        NumPairs (`~.int`):
            (undocumented)
    """
    _LLVMOrcLazyReexports__retval = LLVMOrcOpaqueMaterializationUnit.fromPtr(corc.LLVMOrcLazyReexports(
        LLVMOrcOpaqueLazyCallThroughManager.fromPyobj(LCTM).getElementPtr(),
        LLVMOrcOpaqueIndirectStubsManager.fromPyobj(ISM).getElementPtr(),
        LLVMOrcOpaqueJITDylib.fromPyobj(SourceRef).getElementPtr(),
        LLVMOrcCSymbolAliasMapPair.fromPyobj(CallableAliases).getElementPtr(),NumPairs))
    return None if _LLVMOrcLazyReexports__retval._ptr == NULL else _LLVMOrcLazyReexports__retval


@cython.embedsignature(True)
def LLVMOrcDisposeMaterializationResponsibility(object MR):
    r"""(No short description, might be part of a group.)

    Disposes of the passed MaterializationResponsibility object.

    This should only be done after the symbols covered by the object have either
    been resolved and emitted (via
    LLVMOrcMaterializationResponsibilityNotifyResolved and
    LLVMOrcMaterializationResponsibilityNotifyEmitted) or failed (via
    LLVMOrcMaterializationResponsibilityFailMaterialization).

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeMaterializationResponsibility(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityGetTargetDylib(object MR):
    r"""(No short description, might be part of a group.)

    Returns the target JITDylib that these symbols are being materialized into.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityGetTargetDylib__retval = LLVMOrcOpaqueJITDylib.fromPtr(corc.LLVMOrcMaterializationResponsibilityGetTargetDylib(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr()))
    return None if _LLVMOrcMaterializationResponsibilityGetTargetDylib__retval._ptr == NULL else _LLVMOrcMaterializationResponsibilityGetTargetDylib__retval


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityGetExecutionSession(object MR):
    r"""(No short description, might be part of a group.)

    Returns the ExecutionSession for this MaterializationResponsibility.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityGetExecutionSession__retval = LLVMOrcOpaqueExecutionSession.fromPtr(corc.LLVMOrcMaterializationResponsibilityGetExecutionSession(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr()))
    return None if _LLVMOrcMaterializationResponsibilityGetExecutionSession__retval._ptr == NULL else _LLVMOrcMaterializationResponsibilityGetExecutionSession__retval


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityGetSymbols(object MR, object NumPairs):
    r"""(No short description, might be part of a group.)

    Returns the symbol flags map for this responsibility instance.

    The length of the array is returned in NumPairs and the caller is responsible
    for the returned memory and needs to call LLVMOrcDisposeCSymbolFlagsMap.

    To use the returned symbols beyond the livetime of the
    MaterializationResponsibility requires the caller to retain the symbols
    explicitly.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        NumPairs (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityGetSymbols__retval = LLVMOrcCSymbolFlagsMapPair.fromPtr(corc.LLVMOrcMaterializationResponsibilityGetSymbols(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr(),
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(NumPairs)._ptr))
    return None if _LLVMOrcMaterializationResponsibilityGetSymbols__retval._ptr == NULL else _LLVMOrcMaterializationResponsibilityGetSymbols__retval


@cython.embedsignature(True)
def LLVMOrcDisposeCSymbolFlagsMap(object Pairs):
    r"""(No short description, might be part of a group.)

    Disposes of the passed LLVMOrcCSymbolFlagsMap.

    Does not release the entries themselves.

    Args:
        Pairs (`~.LLVMOrcCSymbolFlagsMapPair`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeCSymbolFlagsMap(
        LLVMOrcCSymbolFlagsMapPair.fromPyobj(Pairs).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityGetInitializerSymbol(object MR):
    r"""(No short description, might be part of a group.)

    Returns the initialization pseudo-symbol, if any. This symbol will also
    be present in the SymbolFlagsMap for this MaterializationResponsibility
    object.

    The returned symbol is not retained over any mutating operation of the
    MaterializationResponsbility or beyond the lifetime thereof.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityGetInitializerSymbol__retval = LLVMOrcOpaqueSymbolStringPoolEntry.fromPtr(corc.LLVMOrcMaterializationResponsibilityGetInitializerSymbol(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr()))
    return None if _LLVMOrcMaterializationResponsibilityGetInitializerSymbol__retval._ptr == NULL else _LLVMOrcMaterializationResponsibilityGetInitializerSymbol__retval


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityGetRequestedSymbols(object MR, object NumSymbols):
    r"""(No short description, might be part of a group.)

    Returns the names of any symbols covered by this
    MaterializationResponsibility object that have queries pending. This
    information can be used to return responsibility for unrequested symbols
    back to the JITDylib via the delegate method.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        NumSymbols (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityGetRequestedSymbols__retval = rocm.llvm._util.types.Pointer.fromPtr(<void*>corc.LLVMOrcMaterializationResponsibilityGetRequestedSymbols(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr(),
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(NumSymbols)._ptr))
    return None if _LLVMOrcMaterializationResponsibilityGetRequestedSymbols__retval._ptr == NULL else _LLVMOrcMaterializationResponsibilityGetRequestedSymbols__retval


@cython.embedsignature(True)
def LLVMOrcDisposeSymbols(object Symbols):
    r"""(No short description, might be part of a group.)

    Disposes of the passed LLVMOrcSymbolStringPoolEntryRef* .

    Does not release the symbols themselves.

    Args:
        Symbols (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeSymbols(
        <corc.LLVMOrcSymbolStringPoolEntryRef*>rocm.llvm._util.types.Pointer.fromPyobj(Symbols)._ptr)


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityNotifyResolved(object MR, object Symbols, unsigned long NumPairs):
    r"""(No short description, might be part of a group.)

    Notifies the target JITDylib that the given symbols have been resolved.
    This will update the given symbols' addresses in the JITDylib, and notify
    any pending queries on the given symbols of their resolution. The given
    symbols must be ones covered by this MaterializationResponsibility
    instance. Individual calls to this method may resolve a subset of the
    symbols, but all symbols must have been resolved prior to calling emit.

    This method will return an error if any symbols being resolved have been
    moved to the error state due to the failure of a dependency. If this
    method returns an error then clients should log it and call
    LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies
    have been registered for the symbols covered by this
    MaterializationResponsibility then this method is guaranteed to return
    LLVMErrorSuccess.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        Symbols (`~.LLVMOrcCSymbolMapPair`/`~.object`):
            (undocumented)

        NumPairs (`~.int`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityNotifyResolved__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcMaterializationResponsibilityNotifyResolved(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr(),
        LLVMOrcCSymbolMapPair.fromPyobj(Symbols).getElementPtr(),NumPairs))
    return None if _LLVMOrcMaterializationResponsibilityNotifyResolved__retval._ptr == NULL else _LLVMOrcMaterializationResponsibilityNotifyResolved__retval


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityNotifyEmitted(object MR):
    r"""(No short description, might be part of a group.)

    Notifies the target JITDylib (and any pending queries on that JITDylib)
    that all symbols covered by this MaterializationResponsibility instance
    have been emitted.

    This method will return an error if any symbols being resolved have been
    moved to the error state due to the failure of a dependency. If this
    method returns an error then clients should log it and call
    LLVMOrcMaterializationResponsibilityFailMaterialization.
    If no dependencies have been registered for the symbols covered by this
    MaterializationResponsibility then this method is guaranteed to return
    LLVMErrorSuccess.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityNotifyEmitted__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcMaterializationResponsibilityNotifyEmitted(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr()))
    return None if _LLVMOrcMaterializationResponsibilityNotifyEmitted__retval._ptr == NULL else _LLVMOrcMaterializationResponsibilityNotifyEmitted__retval


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityDefineMaterializing(object MR, object Pairs, unsigned long NumPairs):
    r"""(No short description, might be part of a group.)

    Attempt to claim responsibility for new definitions. This method can be
    used to claim responsibility for symbols that are added to a
    materialization unit during the compilation process (e.g. literal pool
    symbols). Symbol linkage rules are the same as for symbols that are
    defined up front: duplicate strong definitions will result in errors.
    Duplicate weak definitions will be discarded (in which case they will
    not be added to this responsibility instance).

    This method can be used by materialization units that want to add
    additional symbols at materialization time (e.g. stubs, compile
    callbacks, metadata)

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        Pairs (`~.LLVMOrcCSymbolFlagsMapPair`/`~.object`):
            (undocumented)

        NumPairs (`~.int`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityDefineMaterializing__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcMaterializationResponsibilityDefineMaterializing(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr(),
        LLVMOrcCSymbolFlagsMapPair.fromPyobj(Pairs).getElementPtr(),NumPairs))
    return None if _LLVMOrcMaterializationResponsibilityDefineMaterializing__retval._ptr == NULL else _LLVMOrcMaterializationResponsibilityDefineMaterializing__retval


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityFailMaterialization(object MR):
    r"""(No short description, might be part of a group.)

    Notify all not-yet-emitted covered by this MaterializationResponsibility
    instance that an error has occurred.
    This will remove all symbols covered by this MaterializationResponsibility
    from the target JITDylib, and send an error to any queries waiting on
    these symbols.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcMaterializationResponsibilityFailMaterialization(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityReplace(object MR, object MU):
    r"""(No short description, might be part of a group.)

    Transfers responsibility to the given MaterializationUnit for all
    symbols defined by that MaterializationUnit. This allows
    materializers to break up work based on run-time information (e.g.
    by introspecting which symbols have actually been looked up and
    materializing only those).

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        MU (`~.LLVMOrcOpaqueMaterializationUnit`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityReplace__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcMaterializationResponsibilityReplace(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr(),
        LLVMOrcOpaqueMaterializationUnit.fromPyobj(MU).getElementPtr()))
    return None if _LLVMOrcMaterializationResponsibilityReplace__retval._ptr == NULL else _LLVMOrcMaterializationResponsibilityReplace__retval


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityDelegate(object MR, object Symbols, unsigned long NumSymbols, object Result):
    r"""(No short description, might be part of a group.)

    Delegates responsibility for the given symbols to the returned
    materialization responsibility. Useful for breaking up work between
    threads, or different kinds of materialization processes.

    The caller retains responsibility of the the passed
    MaterializationResponsibility.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        Symbols (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        NumSymbols (`~.int`):
            (undocumented)

        Result (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityDelegate__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcMaterializationResponsibilityDelegate(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr(),
        <corc.LLVMOrcSymbolStringPoolEntryRef*>rocm.llvm._util.types.Pointer.fromPyobj(Symbols)._ptr,NumSymbols,
        <corc.LLVMOrcMaterializationResponsibilityRef*>rocm.llvm._util.types.Pointer.fromPyobj(Result)._ptr))
    return None if _LLVMOrcMaterializationResponsibilityDelegate__retval._ptr == NULL else _LLVMOrcMaterializationResponsibilityDelegate__retval


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityAddDependencies(object MR, object Name, object Dependencies, unsigned long NumPairs):
    r"""(No short description, might be part of a group.)

    Adds dependencies to a symbol that the MaterializationResponsibility is
    responsible for.

    This function takes ownership of Dependencies struct. The Names
    array have been retained for this function. This allows the following
    pattern...

      LLVMOrcSymbolStringPoolEntryRef Names[] = {...};
      LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}
      LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,
    1);

    ... without requiring cleanup of the elements of the Names array afterwards.

    The client is still responsible for deleting the Dependencies.Names array
    itself.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        Name (`~.LLVMOrcOpaqueSymbolStringPoolEntry`/`~.object`):
            (undocumented)

        Dependencies (`~.LLVMOrcCDependenceMapPair`/`~.object`):
            (undocumented)

        NumPairs (`~.int`):
            (undocumented)
    """
    corc.LLVMOrcMaterializationResponsibilityAddDependencies(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr(),
        LLVMOrcOpaqueSymbolStringPoolEntry.fromPyobj(Name).getElementPtr(),
        LLVMOrcCDependenceMapPair.fromPyobj(Dependencies).getElementPtr(),NumPairs)


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityAddDependenciesForAll(object MR, object Dependencies, unsigned long NumPairs):
    r"""(No short description, might be part of a group.)

    Adds dependencies to all symbols that the MaterializationResponsibility is
    responsible for. See LLVMOrcMaterializationResponsibilityAddDependencies for
    notes about memory responsibility.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        Dependencies (`~.LLVMOrcCDependenceMapPair`/`~.object`):
            (undocumented)

        NumPairs (`~.int`):
            (undocumented)
    """
    corc.LLVMOrcMaterializationResponsibilityAddDependenciesForAll(
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr(),
        LLVMOrcCDependenceMapPair.fromPyobj(Dependencies).getElementPtr(),NumPairs)


@cython.embedsignature(True)
def LLVMOrcExecutionSessionCreateBareJITDylib(object ES, object Name):
    r"""(No short description, might be part of a group.)

    Create a "bare" JITDylib.

    The client is responsible for ensuring that the JITDylib's name is unique,
    e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.

    This call does not install any library code or symbols into the newly
    created JITDylib. The client is responsible for all configuration.

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        Name (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    _LLVMOrcExecutionSessionCreateBareJITDylib__retval = LLVMOrcOpaqueJITDylib.fromPtr(corc.LLVMOrcExecutionSessionCreateBareJITDylib(
        LLVMOrcOpaqueExecutionSession.fromPyobj(ES).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(Name)._ptr))
    return None if _LLVMOrcExecutionSessionCreateBareJITDylib__retval._ptr == NULL else _LLVMOrcExecutionSessionCreateBareJITDylib__retval


@cython.embedsignature(True)
def LLVMOrcExecutionSessionCreateJITDylib(object ES, object Result, object Name):
    r"""(No short description, might be part of a group.)

    Create a JITDylib.

    The client is responsible for ensuring that the JITDylib's name is unique,
    e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.

    If a Platform is attached to the ExecutionSession then
    Platform`~.setupJITDylib` will be called to install standard platform symbols
    (e.g. standard library interposes). If no Platform is installed then this
    call is equivalent to LLVMExecutionSessionRefCreateBareJITDylib and will
    always return success.

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        Result (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        Name (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    _LLVMOrcExecutionSessionCreateJITDylib__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcExecutionSessionCreateJITDylib(
        LLVMOrcOpaqueExecutionSession.fromPyobj(ES).getElementPtr(),
        <corc.LLVMOrcJITDylibRef*>rocm.llvm._util.types.Pointer.fromPyobj(Result)._ptr,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(Name)._ptr))
    return None if _LLVMOrcExecutionSessionCreateJITDylib__retval._ptr == NULL else _LLVMOrcExecutionSessionCreateJITDylib__retval


@cython.embedsignature(True)
def LLVMOrcExecutionSessionGetJITDylibByName(object ES, object Name):
    r"""(No short description, might be part of a group.)

    Returns the JITDylib with the given name, or NULL if no such JITDylib
    exists.

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        Name (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    _LLVMOrcExecutionSessionGetJITDylibByName__retval = LLVMOrcOpaqueJITDylib.fromPtr(corc.LLVMOrcExecutionSessionGetJITDylibByName(
        LLVMOrcOpaqueExecutionSession.fromPyobj(ES).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(Name)._ptr))
    return None if _LLVMOrcExecutionSessionGetJITDylibByName__retval._ptr == NULL else _LLVMOrcExecutionSessionGetJITDylibByName__retval


@cython.embedsignature(True)
def LLVMOrcJITDylibCreateResourceTracker(object JD):
    r"""(No short description, might be part of a group.)

    Return a reference to a newly created resource tracker associated with JD.
    The tracker is returned with an initial ref-count of 1, and must be released
    with LLVMOrcReleaseResourceTracker when no longer needed.

    Args:
        JD (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITDylibCreateResourceTracker__retval = LLVMOrcOpaqueResourceTracker.fromPtr(corc.LLVMOrcJITDylibCreateResourceTracker(
        LLVMOrcOpaqueJITDylib.fromPyobj(JD).getElementPtr()))
    return None if _LLVMOrcJITDylibCreateResourceTracker__retval._ptr == NULL else _LLVMOrcJITDylibCreateResourceTracker__retval


@cython.embedsignature(True)
def LLVMOrcJITDylibGetDefaultResourceTracker(object JD):
    r"""(No short description, might be part of a group.)

    Return a reference to the default resource tracker for the given JITDylib.
    This operation will increase the retain count of the tracker: Clients should
    call LLVMOrcReleaseResourceTracker when the result is no longer needed.

    Args:
        JD (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITDylibGetDefaultResourceTracker__retval = LLVMOrcOpaqueResourceTracker.fromPtr(corc.LLVMOrcJITDylibGetDefaultResourceTracker(
        LLVMOrcOpaqueJITDylib.fromPyobj(JD).getElementPtr()))
    return None if _LLVMOrcJITDylibGetDefaultResourceTracker__retval._ptr == NULL else _LLVMOrcJITDylibGetDefaultResourceTracker__retval


@cython.embedsignature(True)
def LLVMOrcJITDylibDefine(object JD, object MU):
    r"""(No short description, might be part of a group.)

    Add the given MaterializationUnit to the given JITDylib.

    If this operation succeeds then JITDylib JD will take ownership of MU.
    If the operation fails then ownership remains with the caller who should
    call LLVMOrcDisposeMaterializationUnit to destroy it.

    Args:
        JD (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)

        MU (`~.LLVMOrcOpaqueMaterializationUnit`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITDylibDefine__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcJITDylibDefine(
        LLVMOrcOpaqueJITDylib.fromPyobj(JD).getElementPtr(),
        LLVMOrcOpaqueMaterializationUnit.fromPyobj(MU).getElementPtr()))
    return None if _LLVMOrcJITDylibDefine__retval._ptr == NULL else _LLVMOrcJITDylibDefine__retval


@cython.embedsignature(True)
def LLVMOrcJITDylibClear(object JD):
    r"""(No short description, might be part of a group.)

    Calls remove on all trackers associated with this JITDylib, see
    JITDylib`~.clear`().

    Args:
        JD (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITDylibClear__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcJITDylibClear(
        LLVMOrcOpaqueJITDylib.fromPyobj(JD).getElementPtr()))
    return None if _LLVMOrcJITDylibClear__retval._ptr == NULL else _LLVMOrcJITDylibClear__retval


@cython.embedsignature(True)
def LLVMOrcJITDylibAddGenerator(object JD, object DG):
    r"""(No short description, might be part of a group.)

    Add a DefinitionGenerator to the given JITDylib.

    The JITDylib will take ownership of the given generator: The client is no
    longer responsible for managing its memory.

    Args:
        JD (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)

        DG (`~.LLVMOrcOpaqueDefinitionGenerator`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcJITDylibAddGenerator(
        LLVMOrcOpaqueJITDylib.fromPyobj(JD).getElementPtr(),
        LLVMOrcOpaqueDefinitionGenerator.fromPyobj(DG).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcCreateCustomCAPIDefinitionGenerator(object F, object Ctx, object Dispose):
    r"""(No short description, might be part of a group.)

    Create a custom generator.

    The F argument will be used to implement the DefinitionGenerator's
    tryToGenerate method (see
    LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction).

    Ctx is a context object that will be passed to F. This argument is
    permitted to be null.

    Dispose is the disposal function for Ctx. This argument is permitted to be
    null (in which case the client is responsible for the lifetime of Ctx).

    Args:
        F (`~.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        Dispose (`~.LLVMOrcDisposeCAPIDefinitionGeneratorFunction`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateCustomCAPIDefinitionGenerator__retval = LLVMOrcOpaqueDefinitionGenerator.fromPtr(corc.LLVMOrcCreateCustomCAPIDefinitionGenerator(
        LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction.fromPyobj(F).getElementPtr(),
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(Ctx)._ptr,
        LLVMOrcDisposeCAPIDefinitionGeneratorFunction.fromPyobj(Dispose).getElementPtr()))
    return None if _LLVMOrcCreateCustomCAPIDefinitionGenerator__retval._ptr == NULL else _LLVMOrcCreateCustomCAPIDefinitionGenerator__retval


@cython.embedsignature(True)
def LLVMOrcLookupStateContinueLookup(object S, object Err):
    r"""(No short description, might be part of a group.)

    Continue a lookup that was suspended in a generator (see
    LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction).

    Args:
        S (`~.LLVMOrcOpaqueLookupState`/`~.object`):
            (undocumented)

        Err (`~.LLVMOpaqueError`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcLookupStateContinueLookup(
        LLVMOrcOpaqueLookupState.fromPyobj(S).getElementPtr(),
        LLVMOpaqueError.fromPyobj(Err).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess(object Result, char GlobalPrefx, object Filter, object FilterCtx):
    r"""(No short description, might be part of a group.)

    Get a DynamicLibrarySearchGenerator that will reflect process symbols into
    the JITDylib. On success the resulting generator is owned by the client.
    Ownership is typically transferred by adding the instance to a JITDylib
    using LLVMOrcJITDylibAddGenerator,

    The GlobalPrefix argument specifies the character that appears on the front
    of linker-mangled symbols for the target platform (e.g. '_' on MachO).
    If non-null, this character will be stripped from the start of all symbol
    strings before passing the remaining substring to dlsym.

    The optional Filter and Ctx arguments can be used to supply a symbol name
    filter: Only symbols for which the filter returns true will be visible to
    JIT'd code. If the Filter argument is null then all process symbols will
    be visible to JIT'd code. Note that the symbol name passed to the Filter
    function is the full mangled symbol: The client is responsible for stripping
    the global prefix if present.

    Args:
        Result (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        GlobalPrefx (`~.int`):
            (undocumented)

        Filter (`~.LLVMOrcSymbolPredicate`/`~.object`):
            (undocumented)

        FilterCtx (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess(
        <corc.LLVMOrcDefinitionGeneratorRef*>rocm.llvm._util.types.Pointer.fromPyobj(Result)._ptr,GlobalPrefx,
        LLVMOrcSymbolPredicate.fromPyobj(Filter).getElementPtr(),
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(FilterCtx)._ptr))
    return None if _LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess__retval._ptr == NULL else _LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess__retval


@cython.embedsignature(True)
def LLVMOrcCreateDynamicLibrarySearchGeneratorForPath(object Result, object FileName, char GlobalPrefix, object Filter, object FilterCtx):
    r"""(No short description, might be part of a group.)

    Get a LLVMOrcCreateDynamicLibararySearchGeneratorForPath that will reflect
    library symbols into the JITDylib. On success the resulting generator is
    owned by the client. Ownership is typically transferred by adding the
    instance to a JITDylib using LLVMOrcJITDylibAddGenerator,

    The GlobalPrefix argument specifies the character that appears on the front
    of linker-mangled symbols for the target platform (e.g. '_' on MachO).
    If non-null, this character will be stripped from the start of all symbol
    strings before passing the remaining substring to dlsym.

    The optional Filter and Ctx arguments can be used to supply a symbol name
    filter: Only symbols for which the filter returns true will be visible to
    JIT'd code. If the Filter argument is null then all library symbols will
    be visible to JIT'd code. Note that the symbol name passed to the Filter
    function is the full mangled symbol: The client is responsible for stripping
    the global prefix if present.

    THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!

    Args:
        Result (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        FileName (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        GlobalPrefix (`~.int`):
            (undocumented)

        Filter (`~.LLVMOrcSymbolPredicate`/`~.object`):
            (undocumented)

        FilterCtx (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateDynamicLibrarySearchGeneratorForPath__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcCreateDynamicLibrarySearchGeneratorForPath(
        <corc.LLVMOrcDefinitionGeneratorRef*>rocm.llvm._util.types.Pointer.fromPyobj(Result)._ptr,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(FileName)._ptr,GlobalPrefix,
        LLVMOrcSymbolPredicate.fromPyobj(Filter).getElementPtr(),
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(FilterCtx)._ptr))
    return None if _LLVMOrcCreateDynamicLibrarySearchGeneratorForPath__retval._ptr == NULL else _LLVMOrcCreateDynamicLibrarySearchGeneratorForPath__retval


@cython.embedsignature(True)
def LLVMOrcCreateStaticLibrarySearchGeneratorForPath(object Result, object ObjLayer, object FileName, object TargetTriple):
    r"""(No short description, might be part of a group.)

    Get a LLVMOrcCreateStaticLibrarySearchGeneratorForPath that will reflect
    static library symbols into the JITDylib. On success the resulting
    generator is owned by the client. Ownership is typically transferred by
    adding the instance to a JITDylib using LLVMOrcJITDylibAddGenerator,

    Call with the optional TargetTriple argument will succeed if the file at
    the given path is a static library or a MachO universal binary containing a
    static library that is compatible with the given triple. Otherwise it will
    return an error.

    THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!

    Args:
        Result (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        ObjLayer (`~.LLVMOrcOpaqueObjectLayer`/`~.object`):
            (undocumented)

        FileName (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        TargetTriple (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateStaticLibrarySearchGeneratorForPath__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcCreateStaticLibrarySearchGeneratorForPath(
        <corc.LLVMOrcDefinitionGeneratorRef*>rocm.llvm._util.types.Pointer.fromPyobj(Result)._ptr,
        LLVMOrcOpaqueObjectLayer.fromPyobj(ObjLayer).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(FileName)._ptr,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(TargetTriple)._ptr))
    return None if _LLVMOrcCreateStaticLibrarySearchGeneratorForPath__retval._ptr == NULL else _LLVMOrcCreateStaticLibrarySearchGeneratorForPath__retval


@cython.embedsignature(True)
def LLVMOrcCreateNewThreadSafeContext():
    r"""(No short description, might be part of a group.)

    Create a ThreadSafeContext containing a new LLVMContext.

    Ownership of the underlying ThreadSafeContext data is shared: Clients
    can and should dispose of their ThreadSafeContext as soon as they no longer
    need to refer to it directly. Other references (e.g. from ThreadSafeModules)
    will keep the data alive as long as it is needed.
    """
    _LLVMOrcCreateNewThreadSafeContext__retval = LLVMOrcOpaqueThreadSafeContext.fromPtr(corc.LLVMOrcCreateNewThreadSafeContext())
    return None if _LLVMOrcCreateNewThreadSafeContext__retval._ptr == NULL else _LLVMOrcCreateNewThreadSafeContext__retval


@cython.embedsignature(True)
def LLVMOrcThreadSafeContextGetContext(object TSCtx):
    r"""(No short description, might be part of a group.)

    Get a reference to the wrapped LLVMContext.

    Args:
        TSCtx (`~.LLVMOrcOpaqueThreadSafeContext`/`~.object`):
            (undocumented)
    """
    _LLVMOrcThreadSafeContextGetContext__retval = LLVMOpaqueContext.fromPtr(corc.LLVMOrcThreadSafeContextGetContext(
        LLVMOrcOpaqueThreadSafeContext.fromPyobj(TSCtx).getElementPtr()))
    return None if _LLVMOrcThreadSafeContextGetContext__retval._ptr == NULL else _LLVMOrcThreadSafeContextGetContext__retval


@cython.embedsignature(True)
def LLVMOrcDisposeThreadSafeContext(object TSCtx):
    r"""(No short description, might be part of a group.)

    Dispose of a ThreadSafeContext.

    Args:
        TSCtx (`~.LLVMOrcOpaqueThreadSafeContext`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeThreadSafeContext(
        LLVMOrcOpaqueThreadSafeContext.fromPyobj(TSCtx).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcCreateNewThreadSafeModule(object M, object TSCtx):
    r"""(No short description, might be part of a group.)

    Create a ThreadSafeModule wrapper around the given LLVM module. This takes
    ownership of the M argument which should not be disposed of or referenced
    after this function returns.

    Ownership of the ThreadSafeModule is unique: If it is transferred to the JIT
    (e.g. by LLVMOrcLLJITAddLLVMIRModule) then the client is no longer
    responsible for it. If it is not transferred to the JIT then the client
    should call LLVMOrcDisposeThreadSafeModule to dispose of it.

    Args:
        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)

        TSCtx (`~.LLVMOrcOpaqueThreadSafeContext`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateNewThreadSafeModule__retval = LLVMOrcOpaqueThreadSafeModule.fromPtr(corc.LLVMOrcCreateNewThreadSafeModule(
        LLVMOpaqueModule.fromPyobj(M).getElementPtr(),
        LLVMOrcOpaqueThreadSafeContext.fromPyobj(TSCtx).getElementPtr()))
    return None if _LLVMOrcCreateNewThreadSafeModule__retval._ptr == NULL else _LLVMOrcCreateNewThreadSafeModule__retval


@cython.embedsignature(True)
def LLVMOrcDisposeThreadSafeModule(object TSM):
    r"""(No short description, might be part of a group.)

    Dispose of a ThreadSafeModule. This should only be called if ownership has
    not been passed to LLJIT (e.g. because some error prevented the client from
    adding this to the JIT).

    Args:
        TSM (`~.LLVMOrcOpaqueThreadSafeModule`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeThreadSafeModule(
        LLVMOrcOpaqueThreadSafeModule.fromPyobj(TSM).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcThreadSafeModuleWithModuleDo(object TSM, object F, object Ctx):
    r"""(No short description, might be part of a group.)

    Apply the given function to the module contained in this ThreadSafeModule.

    Args:
        TSM (`~.LLVMOrcOpaqueThreadSafeModule`/`~.object`):
            (undocumented)

        F (`~.LLVMOrcGenericIRModuleOperationFunction`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcThreadSafeModuleWithModuleDo__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcThreadSafeModuleWithModuleDo(
        LLVMOrcOpaqueThreadSafeModule.fromPyobj(TSM).getElementPtr(),
        LLVMOrcGenericIRModuleOperationFunction.fromPyobj(F).getElementPtr(),
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(Ctx)._ptr))
    return None if _LLVMOrcThreadSafeModuleWithModuleDo__retval._ptr == NULL else _LLVMOrcThreadSafeModuleWithModuleDo__retval


@cython.embedsignature(True)
def LLVMOrcJITTargetMachineBuilderDetectHost(object Result):
    r"""(No short description, might be part of a group.)

    Create a JITTargetMachineBuilder by detecting the host.

    On success the client owns the resulting JITTargetMachineBuilder. It must be
    passed to a consuming operation (e.g.
    LLVMOrcLLJITBuilderSetJITTargetMachineBuilder) or disposed of by calling
    LLVMOrcDisposeJITTargetMachineBuilder.

    Args:
        Result (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITTargetMachineBuilderDetectHost__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcJITTargetMachineBuilderDetectHost(
        <corc.LLVMOrcJITTargetMachineBuilderRef*>rocm.llvm._util.types.Pointer.fromPyobj(Result)._ptr))
    return None if _LLVMOrcJITTargetMachineBuilderDetectHost__retval._ptr == NULL else _LLVMOrcJITTargetMachineBuilderDetectHost__retval


@cython.embedsignature(True)
def LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine(object TM):
    r"""(No short description, might be part of a group.)

    Create a JITTargetMachineBuilder from the given TargetMachine template.

    This operation takes ownership of the given TargetMachine and destroys it
    before returing. The resulting JITTargetMachineBuilder is owned by the client
    and must be passed to a consuming operation (e.g.
    LLVMOrcLLJITBuilderSetJITTargetMachineBuilder) or disposed of by calling
    LLVMOrcDisposeJITTargetMachineBuilder.

    Args:
        TM (`~.LLVMOpaqueTargetMachine`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine__retval = LLVMOrcOpaqueJITTargetMachineBuilder.fromPtr(corc.LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine(
        LLVMOpaqueTargetMachine.fromPyobj(TM).getElementPtr()))
    return None if _LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine__retval._ptr == NULL else _LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine__retval


@cython.embedsignature(True)
def LLVMOrcDisposeJITTargetMachineBuilder(object JTMB):
    r"""(No short description, might be part of a group.)

    Dispose of a JITTargetMachineBuilder.

    Args:
        JTMB (`~.LLVMOrcOpaqueJITTargetMachineBuilder`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeJITTargetMachineBuilder(
        LLVMOrcOpaqueJITTargetMachineBuilder.fromPyobj(JTMB).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcJITTargetMachineBuilderGetTargetTriple(object JTMB):
    r"""(No short description, might be part of a group.)

    Returns the target triple for the given JITTargetMachineBuilder as a string.

    The caller owns the resulting string as must dispose of it by calling
    LLVMDisposeMessage

    Args:
        JTMB (`~.LLVMOrcOpaqueJITTargetMachineBuilder`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITTargetMachineBuilderGetTargetTriple__retval = rocm.llvm._util.types.CStr.fromPtr(<void*>corc.LLVMOrcJITTargetMachineBuilderGetTargetTriple(
        LLVMOrcOpaqueJITTargetMachineBuilder.fromPyobj(JTMB).getElementPtr()))
    return None if _LLVMOrcJITTargetMachineBuilderGetTargetTriple__retval._ptr == NULL else _LLVMOrcJITTargetMachineBuilderGetTargetTriple__retval


@cython.embedsignature(True)
def LLVMOrcJITTargetMachineBuilderSetTargetTriple(object JTMB, object TargetTriple):
    r"""(No short description, might be part of a group.)

    Sets the target triple for the given JITTargetMachineBuilder to the given
    string.

    Args:
        JTMB (`~.LLVMOrcOpaqueJITTargetMachineBuilder`/`~.object`):
            (undocumented)

        TargetTriple (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcJITTargetMachineBuilderSetTargetTriple(
        LLVMOrcOpaqueJITTargetMachineBuilder.fromPyobj(JTMB).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(TargetTriple)._ptr)


@cython.embedsignature(True)
def LLVMOrcObjectLayerAddObjectFile(object ObjLayer, object JD, object ObjBuffer):
    r"""(No short description, might be part of a group.)

    Add an object to an ObjectLayer to the given JITDylib.

    Adds a buffer representing an object file to the given JITDylib using the
    given ObjectLayer instance. This operation transfers ownership of the buffer
    to the ObjectLayer instance. The buffer should not be disposed of or
    referenced once this function returns.

    Resources associated with the given object will be tracked by the given
    JITDylib's default ResourceTracker.

    Args:
        ObjLayer (`~.LLVMOrcOpaqueObjectLayer`/`~.object`):
            (undocumented)

        JD (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)

        ObjBuffer (`~.LLVMOpaqueMemoryBuffer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcObjectLayerAddObjectFile__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcObjectLayerAddObjectFile(
        LLVMOrcOpaqueObjectLayer.fromPyobj(ObjLayer).getElementPtr(),
        LLVMOrcOpaqueJITDylib.fromPyobj(JD).getElementPtr(),
        LLVMOpaqueMemoryBuffer.fromPyobj(ObjBuffer).getElementPtr()))
    return None if _LLVMOrcObjectLayerAddObjectFile__retval._ptr == NULL else _LLVMOrcObjectLayerAddObjectFile__retval


@cython.embedsignature(True)
def LLVMOrcObjectLayerAddObjectFileWithRT(object ObjLayer, object RT, object ObjBuffer):
    r"""(No short description, might be part of a group.)

    Add an object to an ObjectLayer using the given ResourceTracker.

    Adds a buffer representing an object file to the given ResourceTracker's
    JITDylib using the given ObjectLayer instance. This operation transfers
    ownership of the buffer to the ObjectLayer instance. The buffer should not
    be disposed of or referenced once this function returns.

    Resources associated with the given object will be tracked by
    ResourceTracker RT.

    Args:
        ObjLayer (`~.LLVMOrcOpaqueObjectLayer`/`~.object`):
            (undocumented)

        RT (`~.LLVMOrcOpaqueResourceTracker`/`~.object`):
            (undocumented)

        ObjBuffer (`~.LLVMOpaqueMemoryBuffer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcObjectLayerAddObjectFileWithRT__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcObjectLayerAddObjectFileWithRT(
        LLVMOrcOpaqueObjectLayer.fromPyobj(ObjLayer).getElementPtr(),
        LLVMOrcOpaqueResourceTracker.fromPyobj(RT).getElementPtr(),
        LLVMOpaqueMemoryBuffer.fromPyobj(ObjBuffer).getElementPtr()))
    return None if _LLVMOrcObjectLayerAddObjectFileWithRT__retval._ptr == NULL else _LLVMOrcObjectLayerAddObjectFileWithRT__retval


@cython.embedsignature(True)
def LLVMOrcObjectLayerEmit(object ObjLayer, object R, object ObjBuffer):
    r"""(No short description, might be part of a group.)

    Emit an object buffer to an ObjectLayer.

    Ownership of the responsibility object and object buffer pass to this
    function. The client is not responsible for cleanup.

    Args:
        ObjLayer (`~.LLVMOrcOpaqueObjectLayer`/`~.object`):
            (undocumented)

        R (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        ObjBuffer (`~.LLVMOpaqueMemoryBuffer`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcObjectLayerEmit(
        LLVMOrcOpaqueObjectLayer.fromPyobj(ObjLayer).getElementPtr(),
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(R).getElementPtr(),
        LLVMOpaqueMemoryBuffer.fromPyobj(ObjBuffer).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcDisposeObjectLayer(object ObjLayer):
    r"""(No short description, might be part of a group.)

    Dispose of an ObjectLayer.

    Args:
        ObjLayer (`~.LLVMOrcOpaqueObjectLayer`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeObjectLayer(
        LLVMOrcOpaqueObjectLayer.fromPyobj(ObjLayer).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcIRTransformLayerEmit(object IRTransformLayer, object MR, object TSM):
    r"""(No short description, might be part of a group.)

    Args:
        IRTransformLayer (`~.LLVMOrcOpaqueIRTransformLayer`/`~.object`):
            (undocumented)

        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        TSM (`~.LLVMOrcOpaqueThreadSafeModule`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcIRTransformLayerEmit(
        LLVMOrcOpaqueIRTransformLayer.fromPyobj(IRTransformLayer).getElementPtr(),
        LLVMOrcOpaqueMaterializationResponsibility.fromPyobj(MR).getElementPtr(),
        LLVMOrcOpaqueThreadSafeModule.fromPyobj(TSM).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcIRTransformLayerSetTransform(object IRTransformLayer, object TransformFunction, object Ctx):
    r"""(No short description, might be part of a group.)

    Set the transform function of the provided transform layer, passing through a
    pointer to user provided context.

    Args:
        IRTransformLayer (`~.LLVMOrcOpaqueIRTransformLayer`/`~.object`):
            (undocumented)

        TransformFunction (`~.LLVMOrcIRTransformLayerTransformFunction`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcIRTransformLayerSetTransform(
        LLVMOrcOpaqueIRTransformLayer.fromPyobj(IRTransformLayer).getElementPtr(),
        LLVMOrcIRTransformLayerTransformFunction.fromPyobj(TransformFunction).getElementPtr(),
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(Ctx)._ptr)


@cython.embedsignature(True)
def LLVMOrcObjectTransformLayerSetTransform(object ObjTransformLayer, object TransformFunction, object Ctx):
    r"""(No short description, might be part of a group.)

    Set the transform function on an LLVMOrcObjectTransformLayer.

    Args:
        ObjTransformLayer (`~.LLVMOrcOpaqueObjectTransformLayer`/`~.object`):
            (undocumented)

        TransformFunction (`~.LLVMOrcObjectTransformLayerTransformFunction`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcObjectTransformLayerSetTransform(
        LLVMOrcOpaqueObjectTransformLayer.fromPyobj(ObjTransformLayer).getElementPtr(),
        LLVMOrcObjectTransformLayerTransformFunction.fromPyobj(TransformFunction).getElementPtr(),
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(Ctx)._ptr)


@cython.embedsignature(True)
def LLVMOrcCreateLocalIndirectStubsManager(object TargetTriple):
    r"""(No short description, might be part of a group.)

    Create a LocalIndirectStubsManager from the given target triple.

    The resulting IndirectStubsManager is owned by the client
    and must be disposed of by calling LLVMOrcDisposeDisposeIndirectStubsManager.

    Args:
        TargetTriple (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateLocalIndirectStubsManager__retval = LLVMOrcOpaqueIndirectStubsManager.fromPtr(corc.LLVMOrcCreateLocalIndirectStubsManager(
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(TargetTriple)._ptr))
    return None if _LLVMOrcCreateLocalIndirectStubsManager__retval._ptr == NULL else _LLVMOrcCreateLocalIndirectStubsManager__retval


@cython.embedsignature(True)
def LLVMOrcDisposeIndirectStubsManager(object ISM):
    r"""(No short description, might be part of a group.)

    Dispose of an IndirectStubsManager.

    Args:
        ISM (`~.LLVMOrcOpaqueIndirectStubsManager`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeIndirectStubsManager(
        LLVMOrcOpaqueIndirectStubsManager.fromPyobj(ISM).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcCreateLocalLazyCallThroughManager(object TargetTriple, object ES, unsigned long ErrorHandlerAddr, object LCTM):
    r"""(No short description, might be part of a group.)

    Args:
        TargetTriple (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        ErrorHandlerAddr (`~.int`):
            (undocumented)

        LCTM (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateLocalLazyCallThroughManager__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcCreateLocalLazyCallThroughManager(
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(TargetTriple)._ptr,
        LLVMOrcOpaqueExecutionSession.fromPyobj(ES).getElementPtr(),ErrorHandlerAddr,
        <corc.LLVMOrcLazyCallThroughManagerRef*>rocm.llvm._util.types.Pointer.fromPyobj(LCTM)._ptr))
    return None if _LLVMOrcCreateLocalLazyCallThroughManager__retval._ptr == NULL else _LLVMOrcCreateLocalLazyCallThroughManager__retval


@cython.embedsignature(True)
def LLVMOrcDisposeLazyCallThroughManager(object LCTM):
    r"""(No short description, might be part of a group.)

    Dispose of an LazyCallThroughManager.

    Args:
        LCTM (`~.LLVMOrcOpaqueLazyCallThroughManager`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeLazyCallThroughManager(
        LLVMOrcOpaqueLazyCallThroughManager.fromPyobj(LCTM).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcCreateDumpObjects(object DumpDir, object IdentifierOverride):
    r"""(No short description, might be part of a group.)

    Create a DumpObjects instance.

    DumpDir specifies the path to write dumped objects to. DumpDir may be empty
    in which case files will be dumped to the working directory.

    IdentifierOverride specifies a file name stem to use when dumping objects.
    If empty then each MemoryBuffer's identifier will be used (with a .o suffix
    added if not already present). If an identifier override is supplied it will
    be used instead, along with an incrementing counter (since all buffers will
    use the same identifier, the resulting files will be named <ident>.o,
    <ident>.2.o, <ident>.3.o, and so on). IdentifierOverride should not contain
    an extension, as a .o suffix will be added by DumpObjects.

    Args:
        DumpDir (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        IdentifierOverride (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateDumpObjects__retval = LLVMOrcOpaqueDumpObjects.fromPtr(corc.LLVMOrcCreateDumpObjects(
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(DumpDir)._ptr,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(IdentifierOverride)._ptr))
    return None if _LLVMOrcCreateDumpObjects__retval._ptr == NULL else _LLVMOrcCreateDumpObjects__retval


@cython.embedsignature(True)
def LLVMOrcDisposeDumpObjects(object DumpObjects):
    r"""(No short description, might be part of a group.)

    Dispose of a DumpObjects instance.

    Args:
        DumpObjects (`~.LLVMOrcOpaqueDumpObjects`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeDumpObjects(
        LLVMOrcOpaqueDumpObjects.fromPyobj(DumpObjects).getElementPtr())


@cython.embedsignature(True)
def LLVMOrcDumpObjects_CallOperator(object DumpObjects, object ObjBuffer):
    r"""(No short description, might be part of a group.)

    Dump the contents of the given MemoryBuffer.

    Args:
        DumpObjects (`~.LLVMOrcOpaqueDumpObjects`/`~.object`):
            (undocumented)

        ObjBuffer (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcDumpObjects_CallOperator__retval = LLVMOpaqueError.fromPtr(corc.LLVMOrcDumpObjects_CallOperator(
        LLVMOrcOpaqueDumpObjects.fromPyobj(DumpObjects).getElementPtr(),
        <corc.LLVMMemoryBufferRef*>rocm.llvm._util.types.Pointer.fromPyobj(ObjBuffer)._ptr))
    return None if _LLVMOrcDumpObjects_CallOperator__retval._ptr == NULL else _LLVMOrcDumpObjects_CallOperator__retval

__all__ = [
    "_LLVMJITSymbolGenericFlags__Base",
    "LLVMJITSymbolGenericFlags",
    "LLVMJITSymbolFlags",
    "LLVMJITEvaluatedSymbol",
    "LLVMOrcOpaqueExecutionSession",
    "LLVMOrcExecutionSessionRef",
    "LLVMOrcErrorReporterFunction",
    "LLVMOrcOpaqueSymbolStringPool",
    "LLVMOrcSymbolStringPoolRef",
    "LLVMOrcOpaqueSymbolStringPoolEntry",
    "LLVMOrcSymbolStringPoolEntryRef",
    "LLVMOrcCSymbolFlagsMapPair",
    "LLVMOrcCSymbolFlagsMapPairs",
    "LLVMOrcCSymbolMapPair",
    "LLVMOrcCSymbolMapPairs",
    "LLVMOrcCSymbolAliasMapEntry",
    "LLVMOrcCSymbolAliasMapPair",
    "LLVMOrcCSymbolAliasMapPairs",
    "LLVMOrcOpaqueJITDylib",
    "LLVMOrcJITDylibRef",
    "LLVMOrcCSymbolsList",
    "LLVMOrcCDependenceMapPair",
    "LLVMOrcCDependenceMapPairs",
    "_LLVMOrcLookupKind__Base",
    "LLVMOrcLookupKind",
    "_LLVMOrcJITDylibLookupFlags__Base",
    "LLVMOrcJITDylibLookupFlags",
    "LLVMOrcCJITDylibSearchOrderElement",
    "LLVMOrcCJITDylibSearchOrder",
    "_LLVMOrcSymbolLookupFlags__Base",
    "LLVMOrcSymbolLookupFlags",
    "LLVMOrcCLookupSetElement",
    "LLVMOrcCLookupSet",
    "LLVMOrcOpaqueMaterializationUnit",
    "LLVMOrcMaterializationUnitRef",
    "LLVMOrcOpaqueMaterializationResponsibility",
    "LLVMOrcMaterializationResponsibilityRef",
    "LLVMOrcMaterializationUnitMaterializeFunction",
    "LLVMOrcMaterializationUnitDiscardFunction",
    "LLVMOrcMaterializationUnitDestroyFunction",
    "LLVMOrcOpaqueResourceTracker",
    "LLVMOrcResourceTrackerRef",
    "LLVMOrcOpaqueDefinitionGenerator",
    "LLVMOrcDefinitionGeneratorRef",
    "LLVMOrcOpaqueLookupState",
    "LLVMOrcLookupStateRef",
    "LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction",
    "LLVMOrcDisposeCAPIDefinitionGeneratorFunction",
    "LLVMOrcSymbolPredicate",
    "LLVMOrcOpaqueThreadSafeContext",
    "LLVMOrcThreadSafeContextRef",
    "LLVMOrcOpaqueThreadSafeModule",
    "LLVMOrcThreadSafeModuleRef",
    "LLVMOrcGenericIRModuleOperationFunction",
    "LLVMOrcOpaqueJITTargetMachineBuilder",
    "LLVMOrcJITTargetMachineBuilderRef",
    "LLVMOrcOpaqueObjectLayer",
    "LLVMOrcObjectLayerRef",
    "LLVMOrcOpaqueObjectLinkingLayer",
    "LLVMOrcObjectLinkingLayerRef",
    "LLVMOrcOpaqueIRTransformLayer",
    "LLVMOrcIRTransformLayerRef",
    "LLVMOrcIRTransformLayerTransformFunction",
    "LLVMOrcOpaqueObjectTransformLayer",
    "LLVMOrcObjectTransformLayerRef",
    "LLVMOrcObjectTransformLayerTransformFunction",
    "LLVMOrcOpaqueIndirectStubsManager",
    "LLVMOrcIndirectStubsManagerRef",
    "LLVMOrcOpaqueLazyCallThroughManager",
    "LLVMOrcLazyCallThroughManagerRef",
    "LLVMOrcOpaqueDumpObjects",
    "LLVMOrcDumpObjectsRef",
    "LLVMOrcExecutionSessionSetErrorReporter",
    "LLVMOrcExecutionSessionGetSymbolStringPool",
    "LLVMOrcSymbolStringPoolClearDeadEntries",
    "LLVMOrcExecutionSessionIntern",
    "LLVMOrcExecutionSessionLookupHandleResultFunction",
    "LLVMOrcExecutionSessionLookup",
    "LLVMOrcRetainSymbolStringPoolEntry",
    "LLVMOrcReleaseSymbolStringPoolEntry",
    "LLVMOrcSymbolStringPoolEntryStr",
    "LLVMOrcReleaseResourceTracker",
    "LLVMOrcResourceTrackerTransferTo",
    "LLVMOrcResourceTrackerRemove",
    "LLVMOrcDisposeDefinitionGenerator",
    "LLVMOrcDisposeMaterializationUnit",
    "LLVMOrcCreateCustomMaterializationUnit",
    "LLVMOrcAbsoluteSymbols",
    "LLVMOrcLazyReexports",
    "LLVMOrcDisposeMaterializationResponsibility",
    "LLVMOrcMaterializationResponsibilityGetTargetDylib",
    "LLVMOrcMaterializationResponsibilityGetExecutionSession",
    "LLVMOrcMaterializationResponsibilityGetSymbols",
    "LLVMOrcDisposeCSymbolFlagsMap",
    "LLVMOrcMaterializationResponsibilityGetInitializerSymbol",
    "LLVMOrcMaterializationResponsibilityGetRequestedSymbols",
    "LLVMOrcDisposeSymbols",
    "LLVMOrcMaterializationResponsibilityNotifyResolved",
    "LLVMOrcMaterializationResponsibilityNotifyEmitted",
    "LLVMOrcMaterializationResponsibilityDefineMaterializing",
    "LLVMOrcMaterializationResponsibilityFailMaterialization",
    "LLVMOrcMaterializationResponsibilityReplace",
    "LLVMOrcMaterializationResponsibilityDelegate",
    "LLVMOrcMaterializationResponsibilityAddDependencies",
    "LLVMOrcMaterializationResponsibilityAddDependenciesForAll",
    "LLVMOrcExecutionSessionCreateBareJITDylib",
    "LLVMOrcExecutionSessionCreateJITDylib",
    "LLVMOrcExecutionSessionGetJITDylibByName",
    "LLVMOrcJITDylibCreateResourceTracker",
    "LLVMOrcJITDylibGetDefaultResourceTracker",
    "LLVMOrcJITDylibDefine",
    "LLVMOrcJITDylibClear",
    "LLVMOrcJITDylibAddGenerator",
    "LLVMOrcCreateCustomCAPIDefinitionGenerator",
    "LLVMOrcLookupStateContinueLookup",
    "LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess",
    "LLVMOrcCreateDynamicLibrarySearchGeneratorForPath",
    "LLVMOrcCreateStaticLibrarySearchGeneratorForPath",
    "LLVMOrcCreateNewThreadSafeContext",
    "LLVMOrcThreadSafeContextGetContext",
    "LLVMOrcDisposeThreadSafeContext",
    "LLVMOrcCreateNewThreadSafeModule",
    "LLVMOrcDisposeThreadSafeModule",
    "LLVMOrcThreadSafeModuleWithModuleDo",
    "LLVMOrcJITTargetMachineBuilderDetectHost",
    "LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine",
    "LLVMOrcDisposeJITTargetMachineBuilder",
    "LLVMOrcJITTargetMachineBuilderGetTargetTriple",
    "LLVMOrcJITTargetMachineBuilderSetTargetTriple",
    "LLVMOrcObjectLayerAddObjectFile",
    "LLVMOrcObjectLayerAddObjectFileWithRT",
    "LLVMOrcObjectLayerEmit",
    "LLVMOrcDisposeObjectLayer",
    "LLVMOrcIRTransformLayerEmit",
    "LLVMOrcIRTransformLayerSetTransform",
    "LLVMOrcObjectTransformLayerSetTransform",
    "LLVMOrcCreateLocalIndirectStubsManager",
    "LLVMOrcDisposeIndirectStubsManager",
    "LLVMOrcCreateLocalLazyCallThroughManager",
    "LLVMOrcDisposeLazyCallThroughManager",
    "LLVMOrcCreateDumpObjects",
    "LLVMOrcDisposeDumpObjects",
    "LLVMOrcDumpObjects_CallOperator",
]