# MIT License
# 
# Copyright (c) 2023 Advanced Micro Devices, Inc.
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    LLVMOrcExecutionSessionRef:
        alias of `~.LLVMOrcOpaqueExecutionSession`

    LLVMOrcSymbolStringPoolRef:
        alias of `~.LLVMOrcOpaqueSymbolStringPool`

    LLVMOrcSymbolStringPoolEntryRef:
        alias of `~.LLVMOrcOpaqueSymbolStringPoolEntry`

    LLVMOrcCSymbolFlagsMapPairs:
        alias of `~.LLVMOrcCSymbolFlagsMapPair`

    LLVMOrcCSymbolMapPairs:
        alias of `~.LLVMOrcCSymbolMapPair`

    LLVMOrcCSymbolAliasMapPairs:
        alias of `~.LLVMOrcCSymbolAliasMapPair`

    LLVMOrcJITDylibRef:
        alias of `~.LLVMOrcOpaqueJITDylib`

    LLVMOrcCDependenceMapPairs:
        alias of `~.LLVMOrcCDependenceMapPair`

    LLVMOrcCJITDylibSearchOrder:
        alias of `~.LLVMOrcCJITDylibSearchOrderElement`

    LLVMOrcCLookupSet:
        alias of `~.LLVMOrcCLookupSetElement`

    LLVMOrcMaterializationUnitRef:
        alias of `~.LLVMOrcOpaqueMaterializationUnit`

    LLVMOrcMaterializationResponsibilityRef:
        alias of `~.LLVMOrcOpaqueMaterializationResponsibility`

    LLVMOrcResourceTrackerRef:
        alias of `~.LLVMOrcOpaqueResourceTracker`

    LLVMOrcDefinitionGeneratorRef:
        alias of `~.LLVMOrcOpaqueDefinitionGenerator`

    LLVMOrcLookupStateRef:
        alias of `~.LLVMOrcOpaqueLookupState`

    LLVMOrcThreadSafeContextRef:
        alias of `~.LLVMOrcOpaqueThreadSafeContext`

    LLVMOrcThreadSafeModuleRef:
        alias of `~.LLVMOrcOpaqueThreadSafeModule`

    LLVMOrcJITTargetMachineBuilderRef:
        alias of `~.LLVMOrcOpaqueJITTargetMachineBuilder`

    LLVMOrcObjectLayerRef:
        alias of `~.LLVMOrcOpaqueObjectLayer`

    LLVMOrcObjectLinkingLayerRef:
        alias of `~.LLVMOrcOpaqueObjectLinkingLayer`

    LLVMOrcIRTransformLayerRef:
        alias of `~.LLVMOrcOpaqueIRTransformLayer`

    LLVMOrcObjectTransformLayerRef:
        alias of `~.LLVMOrcOpaqueObjectTransformLayer`

    LLVMOrcIndirectStubsManagerRef:
        alias of `~.LLVMOrcOpaqueIndirectStubsManager`

    LLVMOrcLazyCallThroughManagerRef:
        alias of `~.LLVMOrcOpaqueLazyCallThroughManager`

    LLVMOrcDumpObjectsRef:
        alias of `~.LLVMOrcOpaqueDumpObjects`

"""

import cython
import ctypes
import enum

from rocm.llvm.c.error import LLVMErrorRef
from rocm.llvm.c.error import LLVMErrorTypeId
from rocm.llvm.c.error import LLVMGetErrorTypeId
from rocm.llvm.c.error import LLVMConsumeError
from rocm.llvm.c.error import LLVMGetErrorMessage
from rocm.llvm.c.error import LLVMDisposeErrorMessage
from rocm.llvm.c.error import LLVMGetStringErrorTypeId
from rocm.llvm.c.error import LLVMCreateStringError


from rocm.llvm.c.targetmachine import LLVMTargetMachineRef
from rocm.llvm.c.targetmachine import LLVMTargetRef
from rocm.llvm.c.targetmachine import LLVMCodeGenOptLevel
from rocm.llvm.c.targetmachine import LLVMRelocMode
from rocm.llvm.c.targetmachine import LLVMCodeModel
from rocm.llvm.c.targetmachine import LLVMCodeGenFileType
from rocm.llvm.c.targetmachine import LLVMGetFirstTarget
from rocm.llvm.c.targetmachine import LLVMGetNextTarget
from rocm.llvm.c.targetmachine import LLVMGetTargetFromName
from rocm.llvm.c.targetmachine import LLVMGetTargetFromTriple
from rocm.llvm.c.targetmachine import LLVMGetTargetName
from rocm.llvm.c.targetmachine import LLVMGetTargetDescription
from rocm.llvm.c.targetmachine import LLVMTargetHasJIT
from rocm.llvm.c.targetmachine import LLVMTargetHasTargetMachine
from rocm.llvm.c.targetmachine import LLVMTargetHasAsmBackend
from rocm.llvm.c.targetmachine import LLVMCreateTargetMachine
from rocm.llvm.c.targetmachine import LLVMDisposeTargetMachine
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineTarget
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineTriple
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineCPU
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineFeatureString
from rocm.llvm.c.targetmachine import LLVMCreateTargetDataLayout
from rocm.llvm.c.targetmachine import LLVMSetTargetMachineAsmVerbosity
from rocm.llvm.c.targetmachine import LLVMTargetMachineEmitToFile
from rocm.llvm.c.targetmachine import LLVMTargetMachineEmitToMemoryBuffer
from rocm.llvm.c.targetmachine import LLVMGetDefaultTargetTriple
from rocm.llvm.c.targetmachine import LLVMNormalizeTargetTriple
from rocm.llvm.c.targetmachine import LLVMGetHostCPUName
from rocm.llvm.c.targetmachine import LLVMGetHostCPUFeatures
from rocm.llvm.c.targetmachine import LLVMAddAnalysisPasses


from rocm.llvm.c.types import LLVMBool
from rocm.llvm.c.types import LLVMMemoryBufferRef
from rocm.llvm.c.types import LLVMContextRef
from rocm.llvm.c.types import LLVMModuleRef
from rocm.llvm.c.types import LLVMTypeRef
from rocm.llvm.c.types import LLVMValueRef
from rocm.llvm.c.types import LLVMBasicBlockRef
from rocm.llvm.c.types import LLVMMetadataRef
from rocm.llvm.c.types import LLVMNamedMDNodeRef
from rocm.llvm.c.types import LLVMValueMetadataEntry
from rocm.llvm.c.types import LLVMBuilderRef
from rocm.llvm.c.types import LLVMDIBuilderRef
from rocm.llvm.c.types import LLVMModuleProviderRef
from rocm.llvm.c.types import LLVMPassManagerRef
from rocm.llvm.c.types import LLVMPassRegistryRef
from rocm.llvm.c.types import LLVMUseRef
from rocm.llvm.c.types import LLVMAttributeRef
from rocm.llvm.c.types import LLVMDiagnosticInfoRef
from rocm.llvm.c.types import LLVMComdatRef
from rocm.llvm.c.types import LLVMModuleFlagEntry
from rocm.llvm.c.types import LLVMJITEventListenerRef
from rocm.llvm.c.types import LLVMBinaryRef

class _LLVMJITSymbolGenericFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class LLVMJITSymbolGenericFlags(_LLVMJITSymbolGenericFlags__Base):
    """Represents generic linkage flags for a symbol definition.

    Attributes:
        LLVMJITSymbolGenericFlagsNone:
            (undocumented)
        LLVMJITSymbolGenericFlagsExported:
            (undocumented)
        LLVMJITSymbolGenericFlagsWeak:
            (undocumented)
        LLVMJITSymbolGenericFlagsCallable:
            (undocumented)
        LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly:
            (undocumented)
    """
    LLVMJITSymbolGenericFlagsNone = corc.LLVMJITSymbolGenericFlagsNone
    LLVMJITSymbolGenericFlagsExported = corc.LLVMJITSymbolGenericFlagsExported
    LLVMJITSymbolGenericFlagsWeak = corc.LLVMJITSymbolGenericFlagsWeak
    LLVMJITSymbolGenericFlagsCallable = corc.LLVMJITSymbolGenericFlagsCallable
    LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly = corc.LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class LLVMJITSymbolFlags:
    """Python wrapper for C type corc.LLVMJITSymbolFlags.
    
    Python wrapper for C type corc.LLVMJITSymbolFlags.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMJITSymbolFlags from_ptr(corc.LLVMJITSymbolFlags* ptr, bint owner=False):
        """Factory function to create ``LLVMJITSymbolFlags`` objects from
        given ``corc.LLVMJITSymbolFlags`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMJITSymbolFlags wrapper = LLVMJITSymbolFlags.__new__(LLVMJITSymbolFlags)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMJITSymbolFlags from_pyobj(object pyobj):
        """Derives a LLVMJITSymbolFlags from a Python object.

        Derives a LLVMJITSymbolFlags from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMJITSymbolFlags`` reference, this method
        returns it directly. No new ``LLVMJITSymbolFlags`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMJITSymbolFlags`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMJITSymbolFlags!
        """
        cdef LLVMJITSymbolFlags wrapper = LLVMJITSymbolFlags.__new__(LLVMJITSymbolFlags)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMJITSymbolFlags):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMJITSymbolFlags*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMJITSymbolFlags*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMJITSymbolFlags*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMJITSymbolFlags*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(corc.LLVMJITSymbolFlags** ptr):
        ptr[0] = <corc.LLVMJITSymbolFlags*>stdlib.malloc(sizeof(corc.LLVMJITSymbolFlags))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMJITSymbolFlags))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMJITSymbolFlags new():
        """Factory function to create LLVMJITSymbolFlags objects with
        newly allocated corc.LLVMJITSymbolFlags"""
        cdef corc.LLVMJITSymbolFlags* ptr
        LLVMJITSymbolFlags.__allocate(&ptr)
        return LLVMJITSymbolFlags.from_ptr(ptr, owner=True)

    @staticmethod
    cdef LLVMJITSymbolFlags from_value(corc.LLVMJITSymbolFlags other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMJITSymbolFlags.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMJITSymbolFlags))
        return wrapper
   
    def __init__(self,*args,**kwargs):
        """Constructor type LLVMJITSymbolFlags.

        Constructor for type LLVMJITSymbolFlags.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs: 
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMJITSymbolFlags.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMJITSymbolFlags object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return sizeof(corc.LLVMJITSymbolFlags)
    def get_GenericFlags(self, i):
        """Get value ``GenericFlags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].GenericFlags
    def set_GenericFlags(self, i, unsigned char value):
        """Set value ``GenericFlags`` of ``self._ptr[i]``.
        """
        self._ptr[i].GenericFlags = value
    @property
    def GenericFlags(self):
        """(undocumented)"""
        return self.get_GenericFlags(0)
    @GenericFlags.setter
    def GenericFlags(self, unsigned char value):
        self.set_GenericFlags(0,value)

    def get_TargetFlags(self, i):
        """Get value ``TargetFlags`` of ``self._ptr[i]``.
        """
        return self._ptr[i].TargetFlags
    def set_TargetFlags(self, i, unsigned char value):
        """Set value ``TargetFlags`` of ``self._ptr[i]``.
        """
        self._ptr[i].TargetFlags = value
    @property
    def TargetFlags(self):
        """(undocumented)"""
        return self.get_TargetFlags(0)
    @TargetFlags.setter
    def TargetFlags(self, unsigned char value):
        self.set_TargetFlags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["GenericFlags","TargetFlags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class LLVMJITEvaluatedSymbol:
    """Python wrapper for C type corc.LLVMJITEvaluatedSymbol.
    
    Python wrapper for C type corc.LLVMJITEvaluatedSymbol.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMJITEvaluatedSymbol from_ptr(corc.LLVMJITEvaluatedSymbol* ptr, bint owner=False):
        """Factory function to create ``LLVMJITEvaluatedSymbol`` objects from
        given ``corc.LLVMJITEvaluatedSymbol`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMJITEvaluatedSymbol wrapper = LLVMJITEvaluatedSymbol.__new__(LLVMJITEvaluatedSymbol)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMJITEvaluatedSymbol from_pyobj(object pyobj):
        """Derives a LLVMJITEvaluatedSymbol from a Python object.

        Derives a LLVMJITEvaluatedSymbol from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMJITEvaluatedSymbol`` reference, this method
        returns it directly. No new ``LLVMJITEvaluatedSymbol`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMJITEvaluatedSymbol`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMJITEvaluatedSymbol!
        """
        cdef LLVMJITEvaluatedSymbol wrapper = LLVMJITEvaluatedSymbol.__new__(LLVMJITEvaluatedSymbol)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMJITEvaluatedSymbol):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMJITEvaluatedSymbol*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMJITEvaluatedSymbol*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMJITEvaluatedSymbol*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMJITEvaluatedSymbol*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(corc.LLVMJITEvaluatedSymbol** ptr):
        ptr[0] = <corc.LLVMJITEvaluatedSymbol*>stdlib.malloc(sizeof(corc.LLVMJITEvaluatedSymbol))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMJITEvaluatedSymbol))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMJITEvaluatedSymbol new():
        """Factory function to create LLVMJITEvaluatedSymbol objects with
        newly allocated corc.LLVMJITEvaluatedSymbol"""
        cdef corc.LLVMJITEvaluatedSymbol* ptr
        LLVMJITEvaluatedSymbol.__allocate(&ptr)
        return LLVMJITEvaluatedSymbol.from_ptr(ptr, owner=True)

    @staticmethod
    cdef LLVMJITEvaluatedSymbol from_value(corc.LLVMJITEvaluatedSymbol other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMJITEvaluatedSymbol.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMJITEvaluatedSymbol))
        return wrapper
   
    def __init__(self,*args,**kwargs):
        """Constructor type LLVMJITEvaluatedSymbol.

        Constructor for type LLVMJITEvaluatedSymbol.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs: 
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMJITEvaluatedSymbol.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMJITEvaluatedSymbol object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return sizeof(corc.LLVMJITEvaluatedSymbol)
    def get_Address(self, i):
        """Get value ``Address`` of ``self._ptr[i]``.
        """
        return self._ptr[i].Address
    def set_Address(self, i, unsigned long value):
        """Set value ``Address`` of ``self._ptr[i]``.
        """
        self._ptr[i].Address = value
    @property
    def Address(self):
        """(undocumented)"""
        return self.get_Address(0)
    @Address.setter
    def Address(self, unsigned long value):
        self.set_Address(0,value)

    def get_Flags(self, i):
        """Get value of ``Flags`` of ``self._ptr[i]``.
        """
        return LLVMJITSymbolFlags.from_ptr(&self._ptr[i].Flags)
    @property
    def Flags(self):
        """(undocumented)"""
        return self.get_Flags(0)

    @staticmethod
    def PROPERTIES():
        return ["Address","Flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class LLVMOrcOpaqueExecutionSession:
    """Python wrapper for C type corc.LLVMOrcOpaqueExecutionSession.
    
    Python wrapper for C type corc.LLVMOrcOpaqueExecutionSession.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueExecutionSession from_ptr(corc.LLVMOrcOpaqueExecutionSession* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueExecutionSession`` objects from
        given ``corc.LLVMOrcOpaqueExecutionSession`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueExecutionSession wrapper = LLVMOrcOpaqueExecutionSession.__new__(LLVMOrcOpaqueExecutionSession)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueExecutionSession from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueExecutionSession from a Python object.

        Derives a LLVMOrcOpaqueExecutionSession from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueExecutionSession`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueExecutionSession`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueExecutionSession`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueExecutionSession!
        """
        cdef LLVMOrcOpaqueExecutionSession wrapper = LLVMOrcOpaqueExecutionSession.__new__(LLVMOrcOpaqueExecutionSession)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueExecutionSession):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueExecutionSession*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueExecutionSession*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueExecutionSession*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueExecutionSession*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueExecutionSession object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcExecutionSessionRef = LLVMOrcOpaqueExecutionSession

cdef class LLVMOrcErrorReporterFunction:
    """Python wrapper for C type corc.LLVMOrcErrorReporterFunction.
    
    Python wrapper for C type corc.LLVMOrcErrorReporterFunction.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcErrorReporterFunction from_ptr(corc.LLVMOrcErrorReporterFunction ptr, bint owner=False):
        """Factory function to create ``LLVMOrcErrorReporterFunction`` objects from
        given ``corc.LLVMOrcErrorReporterFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcErrorReporterFunction wrapper = LLVMOrcErrorReporterFunction.__new__(LLVMOrcErrorReporterFunction)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcErrorReporterFunction from_pyobj(object pyobj):
        """Derives a LLVMOrcErrorReporterFunction from a Python object.

        Derives a LLVMOrcErrorReporterFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcErrorReporterFunction`` reference, this method
        returns it directly. No new ``LLVMOrcErrorReporterFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcErrorReporterFunction`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcErrorReporterFunction!
        """
        cdef LLVMOrcErrorReporterFunction wrapper = LLVMOrcErrorReporterFunction.__new__(LLVMOrcErrorReporterFunction)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcErrorReporterFunction):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcErrorReporterFunction>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcErrorReporterFunction>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <corc.LLVMOrcErrorReporterFunction>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcErrorReporterFunction object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcOpaqueSymbolStringPool:
    """Python wrapper for C type corc.LLVMOrcOpaqueSymbolStringPool.
    
    Python wrapper for C type corc.LLVMOrcOpaqueSymbolStringPool.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueSymbolStringPool from_ptr(corc.LLVMOrcOpaqueSymbolStringPool* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueSymbolStringPool`` objects from
        given ``corc.LLVMOrcOpaqueSymbolStringPool`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueSymbolStringPool wrapper = LLVMOrcOpaqueSymbolStringPool.__new__(LLVMOrcOpaqueSymbolStringPool)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueSymbolStringPool from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueSymbolStringPool from a Python object.

        Derives a LLVMOrcOpaqueSymbolStringPool from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueSymbolStringPool`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueSymbolStringPool`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueSymbolStringPool`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueSymbolStringPool!
        """
        cdef LLVMOrcOpaqueSymbolStringPool wrapper = LLVMOrcOpaqueSymbolStringPool.__new__(LLVMOrcOpaqueSymbolStringPool)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueSymbolStringPool):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueSymbolStringPool*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueSymbolStringPool*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueSymbolStringPool*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueSymbolStringPool*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueSymbolStringPool object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcSymbolStringPoolRef = LLVMOrcOpaqueSymbolStringPool

cdef class LLVMOrcOpaqueSymbolStringPoolEntry:
    """Python wrapper for C type corc.LLVMOrcOpaqueSymbolStringPoolEntry.
    
    Python wrapper for C type corc.LLVMOrcOpaqueSymbolStringPoolEntry.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueSymbolStringPoolEntry from_ptr(corc.LLVMOrcOpaqueSymbolStringPoolEntry* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueSymbolStringPoolEntry`` objects from
        given ``corc.LLVMOrcOpaqueSymbolStringPoolEntry`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueSymbolStringPoolEntry wrapper = LLVMOrcOpaqueSymbolStringPoolEntry.__new__(LLVMOrcOpaqueSymbolStringPoolEntry)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueSymbolStringPoolEntry from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueSymbolStringPoolEntry from a Python object.

        Derives a LLVMOrcOpaqueSymbolStringPoolEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueSymbolStringPoolEntry`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueSymbolStringPoolEntry`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueSymbolStringPoolEntry`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueSymbolStringPoolEntry!
        """
        cdef LLVMOrcOpaqueSymbolStringPoolEntry wrapper = LLVMOrcOpaqueSymbolStringPoolEntry.__new__(LLVMOrcOpaqueSymbolStringPoolEntry)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueSymbolStringPoolEntry):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueSymbolStringPoolEntry*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueSymbolStringPoolEntry*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueSymbolStringPoolEntry*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueSymbolStringPoolEntry*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueSymbolStringPoolEntry object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcSymbolStringPoolEntryRef = LLVMOrcOpaqueSymbolStringPoolEntry

cdef class LLVMOrcCSymbolFlagsMapPair:
    """Python wrapper for C type corc.LLVMOrcCSymbolFlagsMapPair.
    
    Python wrapper for C type corc.LLVMOrcCSymbolFlagsMapPair.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcCSymbolFlagsMapPair from_ptr(corc.LLVMOrcCSymbolFlagsMapPair* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCSymbolFlagsMapPair`` objects from
        given ``corc.LLVMOrcCSymbolFlagsMapPair`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCSymbolFlagsMapPair wrapper = LLVMOrcCSymbolFlagsMapPair.__new__(LLVMOrcCSymbolFlagsMapPair)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcCSymbolFlagsMapPair from_pyobj(object pyobj):
        """Derives a LLVMOrcCSymbolFlagsMapPair from a Python object.

        Derives a LLVMOrcCSymbolFlagsMapPair from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolFlagsMapPair`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolFlagsMapPair`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcCSymbolFlagsMapPair`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCSymbolFlagsMapPair!
        """
        cdef LLVMOrcCSymbolFlagsMapPair wrapper = LLVMOrcCSymbolFlagsMapPair.__new__(LLVMOrcCSymbolFlagsMapPair)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcCSymbolFlagsMapPair):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcCSymbolFlagsMapPair*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcCSymbolFlagsMapPair*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcCSymbolFlagsMapPair*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcCSymbolFlagsMapPair*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(corc.LLVMOrcCSymbolFlagsMapPair** ptr):
        ptr[0] = <corc.LLVMOrcCSymbolFlagsMapPair*>stdlib.malloc(sizeof(corc.LLVMOrcCSymbolFlagsMapPair))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCSymbolFlagsMapPair))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCSymbolFlagsMapPair new():
        """Factory function to create LLVMOrcCSymbolFlagsMapPair objects with
        newly allocated corc.LLVMOrcCSymbolFlagsMapPair"""
        cdef corc.LLVMOrcCSymbolFlagsMapPair* ptr
        LLVMOrcCSymbolFlagsMapPair.__allocate(&ptr)
        return LLVMOrcCSymbolFlagsMapPair.from_ptr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCSymbolFlagsMapPair from_value(corc.LLVMOrcCSymbolFlagsMapPair other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCSymbolFlagsMapPair.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCSymbolFlagsMapPair))
        return wrapper
   
    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCSymbolFlagsMapPair.

        Constructor for type LLVMOrcCSymbolFlagsMapPair.

        Args:
            **kwargs: 
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCSymbolFlagsMapPair.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcCSymbolFlagsMapPair object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCSymbolFlagsMapPair)
    def get_Flags(self, i):
        """Get value of ``Flags`` of ``self._ptr[i]``.
        """
        return LLVMJITSymbolFlags.from_ptr(&self._ptr[i].Flags)
    @property
    def Flags(self):
        """(undocumented)"""
        return self.get_Flags(0)

    @staticmethod
    def PROPERTIES():
        return ["Flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcCSymbolFlagsMapPairs = LLVMOrcCSymbolFlagsMapPair

cdef class LLVMOrcCSymbolMapPair:
    """Python wrapper for C type corc.LLVMOrcCSymbolMapPair.
    
    Python wrapper for C type corc.LLVMOrcCSymbolMapPair.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcCSymbolMapPair from_ptr(corc.LLVMOrcCSymbolMapPair* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCSymbolMapPair`` objects from
        given ``corc.LLVMOrcCSymbolMapPair`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCSymbolMapPair wrapper = LLVMOrcCSymbolMapPair.__new__(LLVMOrcCSymbolMapPair)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcCSymbolMapPair from_pyobj(object pyobj):
        """Derives a LLVMOrcCSymbolMapPair from a Python object.

        Derives a LLVMOrcCSymbolMapPair from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolMapPair`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolMapPair`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcCSymbolMapPair`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCSymbolMapPair!
        """
        cdef LLVMOrcCSymbolMapPair wrapper = LLVMOrcCSymbolMapPair.__new__(LLVMOrcCSymbolMapPair)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcCSymbolMapPair):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcCSymbolMapPair*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcCSymbolMapPair*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcCSymbolMapPair*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcCSymbolMapPair*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(corc.LLVMOrcCSymbolMapPair** ptr):
        ptr[0] = <corc.LLVMOrcCSymbolMapPair*>stdlib.malloc(sizeof(corc.LLVMOrcCSymbolMapPair))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCSymbolMapPair))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCSymbolMapPair new():
        """Factory function to create LLVMOrcCSymbolMapPair objects with
        newly allocated corc.LLVMOrcCSymbolMapPair"""
        cdef corc.LLVMOrcCSymbolMapPair* ptr
        LLVMOrcCSymbolMapPair.__allocate(&ptr)
        return LLVMOrcCSymbolMapPair.from_ptr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCSymbolMapPair from_value(corc.LLVMOrcCSymbolMapPair other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCSymbolMapPair.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCSymbolMapPair))
        return wrapper
   
    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCSymbolMapPair.

        Constructor for type LLVMOrcCSymbolMapPair.

        Args:
            **kwargs: 
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCSymbolMapPair.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcCSymbolMapPair object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCSymbolMapPair)
    def get_Sym(self, i):
        """Get value of ``Sym`` of ``self._ptr[i]``.
        """
        return LLVMJITEvaluatedSymbol.from_ptr(&self._ptr[i].Sym)
    @property
    def Sym(self):
        """(undocumented)"""
        return self.get_Sym(0)

    @staticmethod
    def PROPERTIES():
        return ["Sym"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcCSymbolMapPairs = LLVMOrcCSymbolMapPair

cdef class LLVMOrcCSymbolAliasMapEntry:
    """Python wrapper for C type corc.LLVMOrcCSymbolAliasMapEntry.
    
    Python wrapper for C type corc.LLVMOrcCSymbolAliasMapEntry.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapEntry from_ptr(corc.LLVMOrcCSymbolAliasMapEntry* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCSymbolAliasMapEntry`` objects from
        given ``corc.LLVMOrcCSymbolAliasMapEntry`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCSymbolAliasMapEntry wrapper = LLVMOrcCSymbolAliasMapEntry.__new__(LLVMOrcCSymbolAliasMapEntry)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapEntry from_pyobj(object pyobj):
        """Derives a LLVMOrcCSymbolAliasMapEntry from a Python object.

        Derives a LLVMOrcCSymbolAliasMapEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolAliasMapEntry`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolAliasMapEntry`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcCSymbolAliasMapEntry`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCSymbolAliasMapEntry!
        """
        cdef LLVMOrcCSymbolAliasMapEntry wrapper = LLVMOrcCSymbolAliasMapEntry.__new__(LLVMOrcCSymbolAliasMapEntry)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcCSymbolAliasMapEntry):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcCSymbolAliasMapEntry*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcCSymbolAliasMapEntry*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcCSymbolAliasMapEntry*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcCSymbolAliasMapEntry*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(corc.LLVMOrcCSymbolAliasMapEntry** ptr):
        ptr[0] = <corc.LLVMOrcCSymbolAliasMapEntry*>stdlib.malloc(sizeof(corc.LLVMOrcCSymbolAliasMapEntry))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCSymbolAliasMapEntry))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapEntry new():
        """Factory function to create LLVMOrcCSymbolAliasMapEntry objects with
        newly allocated corc.LLVMOrcCSymbolAliasMapEntry"""
        cdef corc.LLVMOrcCSymbolAliasMapEntry* ptr
        LLVMOrcCSymbolAliasMapEntry.__allocate(&ptr)
        return LLVMOrcCSymbolAliasMapEntry.from_ptr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapEntry from_value(corc.LLVMOrcCSymbolAliasMapEntry other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCSymbolAliasMapEntry.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCSymbolAliasMapEntry))
        return wrapper
   
    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCSymbolAliasMapEntry.

        Constructor for type LLVMOrcCSymbolAliasMapEntry.

        Args:
            **kwargs: 
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCSymbolAliasMapEntry.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcCSymbolAliasMapEntry object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCSymbolAliasMapEntry)
    def get_Flags(self, i):
        """Get value of ``Flags`` of ``self._ptr[i]``.
        """
        return LLVMJITSymbolFlags.from_ptr(&self._ptr[i].Flags)
    @property
    def Flags(self):
        """(undocumented)"""
        return self.get_Flags(0)

    @staticmethod
    def PROPERTIES():
        return ["Flags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class LLVMOrcCSymbolAliasMapPair:
    """Python wrapper for C type corc.LLVMOrcCSymbolAliasMapPair.
    
    Python wrapper for C type corc.LLVMOrcCSymbolAliasMapPair.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapPair from_ptr(corc.LLVMOrcCSymbolAliasMapPair* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCSymbolAliasMapPair`` objects from
        given ``corc.LLVMOrcCSymbolAliasMapPair`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCSymbolAliasMapPair wrapper = LLVMOrcCSymbolAliasMapPair.__new__(LLVMOrcCSymbolAliasMapPair)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapPair from_pyobj(object pyobj):
        """Derives a LLVMOrcCSymbolAliasMapPair from a Python object.

        Derives a LLVMOrcCSymbolAliasMapPair from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolAliasMapPair`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolAliasMapPair`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcCSymbolAliasMapPair`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCSymbolAliasMapPair!
        """
        cdef LLVMOrcCSymbolAliasMapPair wrapper = LLVMOrcCSymbolAliasMapPair.__new__(LLVMOrcCSymbolAliasMapPair)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcCSymbolAliasMapPair):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcCSymbolAliasMapPair*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcCSymbolAliasMapPair*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcCSymbolAliasMapPair*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcCSymbolAliasMapPair*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(corc.LLVMOrcCSymbolAliasMapPair** ptr):
        ptr[0] = <corc.LLVMOrcCSymbolAliasMapPair*>stdlib.malloc(sizeof(corc.LLVMOrcCSymbolAliasMapPair))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCSymbolAliasMapPair))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapPair new():
        """Factory function to create LLVMOrcCSymbolAliasMapPair objects with
        newly allocated corc.LLVMOrcCSymbolAliasMapPair"""
        cdef corc.LLVMOrcCSymbolAliasMapPair* ptr
        LLVMOrcCSymbolAliasMapPair.__allocate(&ptr)
        return LLVMOrcCSymbolAliasMapPair.from_ptr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCSymbolAliasMapPair from_value(corc.LLVMOrcCSymbolAliasMapPair other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCSymbolAliasMapPair.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCSymbolAliasMapPair))
        return wrapper
   
    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCSymbolAliasMapPair.

        Constructor for type LLVMOrcCSymbolAliasMapPair.

        Args:
            **kwargs: 
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCSymbolAliasMapPair.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcCSymbolAliasMapPair object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCSymbolAliasMapPair)
    def get_Entry(self, i):
        """Get value of ``Entry`` of ``self._ptr[i]``.
        """
        return LLVMOrcCSymbolAliasMapEntry.from_ptr(&self._ptr[i].Entry)
    @property
    def Entry(self):
        """(undocumented)"""
        return self.get_Entry(0)

    @staticmethod
    def PROPERTIES():
        return ["Entry"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcCSymbolAliasMapPairs = LLVMOrcCSymbolAliasMapPair

cdef class LLVMOrcOpaqueJITDylib:
    """Python wrapper for C type corc.LLVMOrcOpaqueJITDylib.
    
    Python wrapper for C type corc.LLVMOrcOpaqueJITDylib.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueJITDylib from_ptr(corc.LLVMOrcOpaqueJITDylib* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueJITDylib`` objects from
        given ``corc.LLVMOrcOpaqueJITDylib`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueJITDylib wrapper = LLVMOrcOpaqueJITDylib.__new__(LLVMOrcOpaqueJITDylib)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueJITDylib from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueJITDylib from a Python object.

        Derives a LLVMOrcOpaqueJITDylib from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueJITDylib`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueJITDylib`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueJITDylib`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueJITDylib!
        """
        cdef LLVMOrcOpaqueJITDylib wrapper = LLVMOrcOpaqueJITDylib.__new__(LLVMOrcOpaqueJITDylib)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueJITDylib):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueJITDylib*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueJITDylib*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueJITDylib*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueJITDylib*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueJITDylib object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcJITDylibRef = LLVMOrcOpaqueJITDylib

cdef class LLVMOrcCSymbolsList:
    """Python wrapper for C type corc.LLVMOrcCSymbolsList.
    
    Python wrapper for C type corc.LLVMOrcCSymbolsList.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcCSymbolsList from_ptr(corc.LLVMOrcCSymbolsList* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCSymbolsList`` objects from
        given ``corc.LLVMOrcCSymbolsList`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCSymbolsList wrapper = LLVMOrcCSymbolsList.__new__(LLVMOrcCSymbolsList)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcCSymbolsList from_pyobj(object pyobj):
        """Derives a LLVMOrcCSymbolsList from a Python object.

        Derives a LLVMOrcCSymbolsList from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCSymbolsList`` reference, this method
        returns it directly. No new ``LLVMOrcCSymbolsList`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcCSymbolsList`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCSymbolsList!
        """
        cdef LLVMOrcCSymbolsList wrapper = LLVMOrcCSymbolsList.__new__(LLVMOrcCSymbolsList)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcCSymbolsList):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcCSymbolsList*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcCSymbolsList*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcCSymbolsList*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcCSymbolsList*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(corc.LLVMOrcCSymbolsList** ptr):
        ptr[0] = <corc.LLVMOrcCSymbolsList*>stdlib.malloc(sizeof(corc.LLVMOrcCSymbolsList))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCSymbolsList))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCSymbolsList new():
        """Factory function to create LLVMOrcCSymbolsList objects with
        newly allocated corc.LLVMOrcCSymbolsList"""
        cdef corc.LLVMOrcCSymbolsList* ptr
        LLVMOrcCSymbolsList.__allocate(&ptr)
        return LLVMOrcCSymbolsList.from_ptr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCSymbolsList from_value(corc.LLVMOrcCSymbolsList other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCSymbolsList.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCSymbolsList))
        return wrapper
   
    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCSymbolsList.

        Constructor for type LLVMOrcCSymbolsList.

        Args:
            **kwargs: 
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCSymbolsList.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcCSymbolsList object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCSymbolsList)
    def get_Length(self, i):
        """Get value ``Length`` of ``self._ptr[i]``.
        """
        return self._ptr[i].Length
    def set_Length(self, i, unsigned long value):
        """Set value ``Length`` of ``self._ptr[i]``.
        """
        self._ptr[i].Length = value
    @property
    def Length(self):
        """(undocumented)"""
        return self.get_Length(0)
    @Length.setter
    def Length(self, unsigned long value):
        self.set_Length(0,value)

    @staticmethod
    def PROPERTIES():
        return ["Length"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class LLVMOrcCDependenceMapPair:
    """Python wrapper for C type corc.LLVMOrcCDependenceMapPair.
    
    Python wrapper for C type corc.LLVMOrcCDependenceMapPair.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcCDependenceMapPair from_ptr(corc.LLVMOrcCDependenceMapPair* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCDependenceMapPair`` objects from
        given ``corc.LLVMOrcCDependenceMapPair`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCDependenceMapPair wrapper = LLVMOrcCDependenceMapPair.__new__(LLVMOrcCDependenceMapPair)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcCDependenceMapPair from_pyobj(object pyobj):
        """Derives a LLVMOrcCDependenceMapPair from a Python object.

        Derives a LLVMOrcCDependenceMapPair from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCDependenceMapPair`` reference, this method
        returns it directly. No new ``LLVMOrcCDependenceMapPair`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcCDependenceMapPair`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCDependenceMapPair!
        """
        cdef LLVMOrcCDependenceMapPair wrapper = LLVMOrcCDependenceMapPair.__new__(LLVMOrcCDependenceMapPair)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcCDependenceMapPair):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcCDependenceMapPair*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcCDependenceMapPair*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcCDependenceMapPair*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcCDependenceMapPair*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(corc.LLVMOrcCDependenceMapPair** ptr):
        ptr[0] = <corc.LLVMOrcCDependenceMapPair*>stdlib.malloc(sizeof(corc.LLVMOrcCDependenceMapPair))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCDependenceMapPair))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCDependenceMapPair new():
        """Factory function to create LLVMOrcCDependenceMapPair objects with
        newly allocated corc.LLVMOrcCDependenceMapPair"""
        cdef corc.LLVMOrcCDependenceMapPair* ptr
        LLVMOrcCDependenceMapPair.__allocate(&ptr)
        return LLVMOrcCDependenceMapPair.from_ptr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCDependenceMapPair from_value(corc.LLVMOrcCDependenceMapPair other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCDependenceMapPair.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCDependenceMapPair))
        return wrapper
   
    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCDependenceMapPair.

        Constructor for type LLVMOrcCDependenceMapPair.

        Args:
            **kwargs: 
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCDependenceMapPair.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcCDependenceMapPair object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCDependenceMapPair)
    def get_Names(self, i):
        """Get value of ``Names`` of ``self._ptr[i]``.
        """
        return LLVMOrcCSymbolsList.from_ptr(&self._ptr[i].Names)
    @property
    def Names(self):
        """(undocumented)"""
        return self.get_Names(0)

    @staticmethod
    def PROPERTIES():
        return ["Names"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcCDependenceMapPairs = LLVMOrcCDependenceMapPair

class _LLVMOrcLookupKind__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class LLVMOrcLookupKind(_LLVMOrcLookupKind__Base):
    """Lookup kind. This can be used by definition generators when deciding whether to produce a definition for a requested symbol.

    Attributes:
        LLVMOrcLookupKindStatic:
            (undocumented)
        LLVMOrcLookupKindDLSym:
            (undocumented)
    """
    LLVMOrcLookupKindStatic = corc.LLVMOrcLookupKindStatic
    LLVMOrcLookupKindDLSym = corc.LLVMOrcLookupKindDLSym
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


class _LLVMOrcJITDylibLookupFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class LLVMOrcJITDylibLookupFlags(_LLVMOrcJITDylibLookupFlags__Base):
    """JITDylib lookup flags. This can be used by definition generators when deciding whether to produce a definition for a requested symbol.

    Attributes:
        LLVMOrcJITDylibLookupFlagsMatchExportedSymbolsOnly:
            (undocumented)
        LLVMOrcJITDylibLookupFlagsMatchAllSymbols:
            (undocumented)
    """
    LLVMOrcJITDylibLookupFlagsMatchExportedSymbolsOnly = corc.LLVMOrcJITDylibLookupFlagsMatchExportedSymbolsOnly
    LLVMOrcJITDylibLookupFlagsMatchAllSymbols = corc.LLVMOrcJITDylibLookupFlagsMatchAllSymbols
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class LLVMOrcCJITDylibSearchOrderElement:
    """Python wrapper for C type corc.LLVMOrcCJITDylibSearchOrderElement.
    
    Python wrapper for C type corc.LLVMOrcCJITDylibSearchOrderElement.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcCJITDylibSearchOrderElement from_ptr(corc.LLVMOrcCJITDylibSearchOrderElement* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCJITDylibSearchOrderElement`` objects from
        given ``corc.LLVMOrcCJITDylibSearchOrderElement`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCJITDylibSearchOrderElement wrapper = LLVMOrcCJITDylibSearchOrderElement.__new__(LLVMOrcCJITDylibSearchOrderElement)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcCJITDylibSearchOrderElement from_pyobj(object pyobj):
        """Derives a LLVMOrcCJITDylibSearchOrderElement from a Python object.

        Derives a LLVMOrcCJITDylibSearchOrderElement from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCJITDylibSearchOrderElement`` reference, this method
        returns it directly. No new ``LLVMOrcCJITDylibSearchOrderElement`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcCJITDylibSearchOrderElement`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCJITDylibSearchOrderElement!
        """
        cdef LLVMOrcCJITDylibSearchOrderElement wrapper = LLVMOrcCJITDylibSearchOrderElement.__new__(LLVMOrcCJITDylibSearchOrderElement)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcCJITDylibSearchOrderElement):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcCJITDylibSearchOrderElement*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcCJITDylibSearchOrderElement*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcCJITDylibSearchOrderElement*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcCJITDylibSearchOrderElement*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(corc.LLVMOrcCJITDylibSearchOrderElement** ptr):
        ptr[0] = <corc.LLVMOrcCJITDylibSearchOrderElement*>stdlib.malloc(sizeof(corc.LLVMOrcCJITDylibSearchOrderElement))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCJITDylibSearchOrderElement))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCJITDylibSearchOrderElement new():
        """Factory function to create LLVMOrcCJITDylibSearchOrderElement objects with
        newly allocated corc.LLVMOrcCJITDylibSearchOrderElement"""
        cdef corc.LLVMOrcCJITDylibSearchOrderElement* ptr
        LLVMOrcCJITDylibSearchOrderElement.__allocate(&ptr)
        return LLVMOrcCJITDylibSearchOrderElement.from_ptr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCJITDylibSearchOrderElement from_value(corc.LLVMOrcCJITDylibSearchOrderElement other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCJITDylibSearchOrderElement.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCJITDylibSearchOrderElement))
        return wrapper
   
    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCJITDylibSearchOrderElement.

        Constructor for type LLVMOrcCJITDylibSearchOrderElement.

        Args:
            **kwargs: 
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCJITDylibSearchOrderElement.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcCJITDylibSearchOrderElement object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCJITDylibSearchOrderElement)
    def get_JDLookupFlags(self, i):
        """Get value of ``JDLookupFlags`` of ``self._ptr[i]``.
        """
        return LLVMOrcJITDylibLookupFlags(self._ptr[i].JDLookupFlags)
    def set_JDLookupFlags(self, i, value):
        """Set value ``JDLookupFlags`` of ``self._ptr[i]``.
        """
        if not isinstance(value, LLVMOrcJITDylibLookupFlags):
            raise TypeError("'value' must be of type 'LLVMOrcJITDylibLookupFlags'")
        self._ptr[i].JDLookupFlags = value.value
    @property
    def JDLookupFlags(self):
        """(undocumented)"""
        return self.get_JDLookupFlags(0)
    @JDLookupFlags.setter
    def JDLookupFlags(self, value):
        self.set_JDLookupFlags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["JDLookupFlags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcCJITDylibSearchOrder = LLVMOrcCJITDylibSearchOrderElement

class _LLVMOrcSymbolLookupFlags__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class LLVMOrcSymbolLookupFlags(_LLVMOrcSymbolLookupFlags__Base):
    """Symbol lookup flags for lookup sets. This should be kept in sync with llvm::orc::SymbolLookupFlags.

    Attributes:
        LLVMOrcSymbolLookupFlagsRequiredSymbol:
            (undocumented)
        LLVMOrcSymbolLookupFlagsWeaklyReferencedSymbol:
            (undocumented)
    """
    LLVMOrcSymbolLookupFlagsRequiredSymbol = corc.LLVMOrcSymbolLookupFlagsRequiredSymbol
    LLVMOrcSymbolLookupFlagsWeaklyReferencedSymbol = corc.LLVMOrcSymbolLookupFlagsWeaklyReferencedSymbol
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class LLVMOrcCLookupSetElement:
    """Python wrapper for C type corc.LLVMOrcCLookupSetElement.
    
    Python wrapper for C type corc.LLVMOrcCLookupSetElement.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcCLookupSetElement from_ptr(corc.LLVMOrcCLookupSetElement* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCLookupSetElement`` objects from
        given ``corc.LLVMOrcCLookupSetElement`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCLookupSetElement wrapper = LLVMOrcCLookupSetElement.__new__(LLVMOrcCLookupSetElement)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcCLookupSetElement from_pyobj(object pyobj):
        """Derives a LLVMOrcCLookupSetElement from a Python object.

        Derives a LLVMOrcCLookupSetElement from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCLookupSetElement`` reference, this method
        returns it directly. No new ``LLVMOrcCLookupSetElement`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcCLookupSetElement`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCLookupSetElement!
        """
        cdef LLVMOrcCLookupSetElement wrapper = LLVMOrcCLookupSetElement.__new__(LLVMOrcCLookupSetElement)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcCLookupSetElement):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcCLookupSetElement*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcCLookupSetElement*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcCLookupSetElement*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcCLookupSetElement*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(corc.LLVMOrcCLookupSetElement** ptr):
        ptr[0] = <corc.LLVMOrcCLookupSetElement*>stdlib.malloc(sizeof(corc.LLVMOrcCLookupSetElement))
        string.memset(<void*>ptr[0], 0, sizeof(corc.LLVMOrcCLookupSetElement))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMOrcCLookupSetElement new():
        """Factory function to create LLVMOrcCLookupSetElement objects with
        newly allocated corc.LLVMOrcCLookupSetElement"""
        cdef corc.LLVMOrcCLookupSetElement* ptr
        LLVMOrcCLookupSetElement.__allocate(&ptr)
        return LLVMOrcCLookupSetElement.from_ptr(ptr, owner=True)

    @staticmethod
    cdef LLVMOrcCLookupSetElement from_value(corc.LLVMOrcCLookupSetElement other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMOrcCLookupSetElement.new()
        string.memcpy(wrapper._ptr, &other, sizeof(corc.LLVMOrcCLookupSetElement))
        return wrapper
   
    def __init__(self,**kwargs):
        """Constructor type LLVMOrcCLookupSetElement.

        Constructor for type LLVMOrcCLookupSetElement.

        Args:
            **kwargs: 
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMOrcCLookupSetElement.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcCLookupSetElement object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return sizeof(corc.LLVMOrcCLookupSetElement)
    def get_LookupFlags(self, i):
        """Get value of ``LookupFlags`` of ``self._ptr[i]``.
        """
        return LLVMOrcSymbolLookupFlags(self._ptr[i].LookupFlags)
    def set_LookupFlags(self, i, value):
        """Set value ``LookupFlags`` of ``self._ptr[i]``.
        """
        if not isinstance(value, LLVMOrcSymbolLookupFlags):
            raise TypeError("'value' must be of type 'LLVMOrcSymbolLookupFlags'")
        self._ptr[i].LookupFlags = value.value
    @property
    def LookupFlags(self):
        """(undocumented)"""
        return self.get_LookupFlags(0)
    @LookupFlags.setter
    def LookupFlags(self, value):
        self.set_LookupFlags(0,value)

    @staticmethod
    def PROPERTIES():
        return ["LookupFlags"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcCLookupSet = LLVMOrcCLookupSetElement

cdef class LLVMOrcOpaqueMaterializationUnit:
    """Python wrapper for C type corc.LLVMOrcOpaqueMaterializationUnit.
    
    Python wrapper for C type corc.LLVMOrcOpaqueMaterializationUnit.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueMaterializationUnit from_ptr(corc.LLVMOrcOpaqueMaterializationUnit* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueMaterializationUnit`` objects from
        given ``corc.LLVMOrcOpaqueMaterializationUnit`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueMaterializationUnit wrapper = LLVMOrcOpaqueMaterializationUnit.__new__(LLVMOrcOpaqueMaterializationUnit)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueMaterializationUnit from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueMaterializationUnit from a Python object.

        Derives a LLVMOrcOpaqueMaterializationUnit from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueMaterializationUnit`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueMaterializationUnit`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueMaterializationUnit`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueMaterializationUnit!
        """
        cdef LLVMOrcOpaqueMaterializationUnit wrapper = LLVMOrcOpaqueMaterializationUnit.__new__(LLVMOrcOpaqueMaterializationUnit)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueMaterializationUnit):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueMaterializationUnit*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueMaterializationUnit*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueMaterializationUnit*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueMaterializationUnit*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueMaterializationUnit object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcMaterializationUnitRef = LLVMOrcOpaqueMaterializationUnit

cdef class LLVMOrcOpaqueMaterializationResponsibility:
    """Python wrapper for C type corc.LLVMOrcOpaqueMaterializationResponsibility.
    
    Python wrapper for C type corc.LLVMOrcOpaqueMaterializationResponsibility.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueMaterializationResponsibility from_ptr(corc.LLVMOrcOpaqueMaterializationResponsibility* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueMaterializationResponsibility`` objects from
        given ``corc.LLVMOrcOpaqueMaterializationResponsibility`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueMaterializationResponsibility wrapper = LLVMOrcOpaqueMaterializationResponsibility.__new__(LLVMOrcOpaqueMaterializationResponsibility)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueMaterializationResponsibility from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueMaterializationResponsibility from a Python object.

        Derives a LLVMOrcOpaqueMaterializationResponsibility from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueMaterializationResponsibility`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueMaterializationResponsibility`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueMaterializationResponsibility`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueMaterializationResponsibility!
        """
        cdef LLVMOrcOpaqueMaterializationResponsibility wrapper = LLVMOrcOpaqueMaterializationResponsibility.__new__(LLVMOrcOpaqueMaterializationResponsibility)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueMaterializationResponsibility):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueMaterializationResponsibility*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueMaterializationResponsibility*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueMaterializationResponsibility*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueMaterializationResponsibility*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueMaterializationResponsibility object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcMaterializationResponsibilityRef = LLVMOrcOpaqueMaterializationResponsibility

cdef class LLVMOrcMaterializationUnitMaterializeFunction:
    """Python wrapper for C type corc.LLVMOrcMaterializationUnitMaterializeFunction.
    
    Python wrapper for C type corc.LLVMOrcMaterializationUnitMaterializeFunction.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcMaterializationUnitMaterializeFunction from_ptr(corc.LLVMOrcMaterializationUnitMaterializeFunction ptr, bint owner=False):
        """Factory function to create ``LLVMOrcMaterializationUnitMaterializeFunction`` objects from
        given ``corc.LLVMOrcMaterializationUnitMaterializeFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcMaterializationUnitMaterializeFunction wrapper = LLVMOrcMaterializationUnitMaterializeFunction.__new__(LLVMOrcMaterializationUnitMaterializeFunction)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcMaterializationUnitMaterializeFunction from_pyobj(object pyobj):
        """Derives a LLVMOrcMaterializationUnitMaterializeFunction from a Python object.

        Derives a LLVMOrcMaterializationUnitMaterializeFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcMaterializationUnitMaterializeFunction`` reference, this method
        returns it directly. No new ``LLVMOrcMaterializationUnitMaterializeFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcMaterializationUnitMaterializeFunction`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcMaterializationUnitMaterializeFunction!
        """
        cdef LLVMOrcMaterializationUnitMaterializeFunction wrapper = LLVMOrcMaterializationUnitMaterializeFunction.__new__(LLVMOrcMaterializationUnitMaterializeFunction)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcMaterializationUnitMaterializeFunction):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcMaterializationUnitMaterializeFunction>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcMaterializationUnitMaterializeFunction>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <corc.LLVMOrcMaterializationUnitMaterializeFunction>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcMaterializationUnitMaterializeFunction object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcMaterializationUnitDiscardFunction:
    """Python wrapper for C type corc.LLVMOrcMaterializationUnitDiscardFunction.
    
    Python wrapper for C type corc.LLVMOrcMaterializationUnitDiscardFunction.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcMaterializationUnitDiscardFunction from_ptr(corc.LLVMOrcMaterializationUnitDiscardFunction ptr, bint owner=False):
        """Factory function to create ``LLVMOrcMaterializationUnitDiscardFunction`` objects from
        given ``corc.LLVMOrcMaterializationUnitDiscardFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcMaterializationUnitDiscardFunction wrapper = LLVMOrcMaterializationUnitDiscardFunction.__new__(LLVMOrcMaterializationUnitDiscardFunction)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcMaterializationUnitDiscardFunction from_pyobj(object pyobj):
        """Derives a LLVMOrcMaterializationUnitDiscardFunction from a Python object.

        Derives a LLVMOrcMaterializationUnitDiscardFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcMaterializationUnitDiscardFunction`` reference, this method
        returns it directly. No new ``LLVMOrcMaterializationUnitDiscardFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcMaterializationUnitDiscardFunction`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcMaterializationUnitDiscardFunction!
        """
        cdef LLVMOrcMaterializationUnitDiscardFunction wrapper = LLVMOrcMaterializationUnitDiscardFunction.__new__(LLVMOrcMaterializationUnitDiscardFunction)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcMaterializationUnitDiscardFunction):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcMaterializationUnitDiscardFunction>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcMaterializationUnitDiscardFunction>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <corc.LLVMOrcMaterializationUnitDiscardFunction>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcMaterializationUnitDiscardFunction object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcMaterializationUnitDestroyFunction:
    """Python wrapper for C type corc.LLVMOrcMaterializationUnitDestroyFunction.
    
    Python wrapper for C type corc.LLVMOrcMaterializationUnitDestroyFunction.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcMaterializationUnitDestroyFunction from_ptr(corc.LLVMOrcMaterializationUnitDestroyFunction ptr, bint owner=False):
        """Factory function to create ``LLVMOrcMaterializationUnitDestroyFunction`` objects from
        given ``corc.LLVMOrcMaterializationUnitDestroyFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcMaterializationUnitDestroyFunction wrapper = LLVMOrcMaterializationUnitDestroyFunction.__new__(LLVMOrcMaterializationUnitDestroyFunction)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcMaterializationUnitDestroyFunction from_pyobj(object pyobj):
        """Derives a LLVMOrcMaterializationUnitDestroyFunction from a Python object.

        Derives a LLVMOrcMaterializationUnitDestroyFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcMaterializationUnitDestroyFunction`` reference, this method
        returns it directly. No new ``LLVMOrcMaterializationUnitDestroyFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcMaterializationUnitDestroyFunction`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcMaterializationUnitDestroyFunction!
        """
        cdef LLVMOrcMaterializationUnitDestroyFunction wrapper = LLVMOrcMaterializationUnitDestroyFunction.__new__(LLVMOrcMaterializationUnitDestroyFunction)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcMaterializationUnitDestroyFunction):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcMaterializationUnitDestroyFunction>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcMaterializationUnitDestroyFunction>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <corc.LLVMOrcMaterializationUnitDestroyFunction>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcMaterializationUnitDestroyFunction object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcOpaqueResourceTracker:
    """Python wrapper for C type corc.LLVMOrcOpaqueResourceTracker.
    
    Python wrapper for C type corc.LLVMOrcOpaqueResourceTracker.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueResourceTracker from_ptr(corc.LLVMOrcOpaqueResourceTracker* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueResourceTracker`` objects from
        given ``corc.LLVMOrcOpaqueResourceTracker`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueResourceTracker wrapper = LLVMOrcOpaqueResourceTracker.__new__(LLVMOrcOpaqueResourceTracker)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueResourceTracker from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueResourceTracker from a Python object.

        Derives a LLVMOrcOpaqueResourceTracker from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueResourceTracker`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueResourceTracker`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueResourceTracker`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueResourceTracker!
        """
        cdef LLVMOrcOpaqueResourceTracker wrapper = LLVMOrcOpaqueResourceTracker.__new__(LLVMOrcOpaqueResourceTracker)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueResourceTracker):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueResourceTracker*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueResourceTracker*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueResourceTracker*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueResourceTracker*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueResourceTracker object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcResourceTrackerRef = LLVMOrcOpaqueResourceTracker

cdef class LLVMOrcOpaqueDefinitionGenerator:
    """Python wrapper for C type corc.LLVMOrcOpaqueDefinitionGenerator.
    
    Python wrapper for C type corc.LLVMOrcOpaqueDefinitionGenerator.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueDefinitionGenerator from_ptr(corc.LLVMOrcOpaqueDefinitionGenerator* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueDefinitionGenerator`` objects from
        given ``corc.LLVMOrcOpaqueDefinitionGenerator`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueDefinitionGenerator wrapper = LLVMOrcOpaqueDefinitionGenerator.__new__(LLVMOrcOpaqueDefinitionGenerator)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueDefinitionGenerator from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueDefinitionGenerator from a Python object.

        Derives a LLVMOrcOpaqueDefinitionGenerator from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueDefinitionGenerator`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueDefinitionGenerator`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueDefinitionGenerator`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueDefinitionGenerator!
        """
        cdef LLVMOrcOpaqueDefinitionGenerator wrapper = LLVMOrcOpaqueDefinitionGenerator.__new__(LLVMOrcOpaqueDefinitionGenerator)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueDefinitionGenerator):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueDefinitionGenerator*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueDefinitionGenerator*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueDefinitionGenerator*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueDefinitionGenerator*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueDefinitionGenerator object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcDefinitionGeneratorRef = LLVMOrcOpaqueDefinitionGenerator

cdef class LLVMOrcOpaqueLookupState:
    """Python wrapper for C type corc.LLVMOrcOpaqueLookupState.
    
    Python wrapper for C type corc.LLVMOrcOpaqueLookupState.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueLookupState from_ptr(corc.LLVMOrcOpaqueLookupState* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueLookupState`` objects from
        given ``corc.LLVMOrcOpaqueLookupState`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueLookupState wrapper = LLVMOrcOpaqueLookupState.__new__(LLVMOrcOpaqueLookupState)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueLookupState from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueLookupState from a Python object.

        Derives a LLVMOrcOpaqueLookupState from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueLookupState`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueLookupState`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueLookupState`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueLookupState!
        """
        cdef LLVMOrcOpaqueLookupState wrapper = LLVMOrcOpaqueLookupState.__new__(LLVMOrcOpaqueLookupState)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueLookupState):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueLookupState*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueLookupState*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueLookupState*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueLookupState*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueLookupState object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcLookupStateRef = LLVMOrcOpaqueLookupState

cdef class LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction:
    """Python wrapper for C type corc.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction.
    
    Python wrapper for C type corc.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction from_ptr(corc.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction ptr, bint owner=False):
        """Factory function to create ``LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`` objects from
        given ``corc.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction wrapper = LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction.__new__(LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction from_pyobj(object pyobj):
        """Derives a LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction from a Python object.

        Derives a LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`` reference, this method
        returns it directly. No new ``LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction!
        """
        cdef LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction wrapper = LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction.__new__(LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <corc.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcDisposeCAPIDefinitionGeneratorFunction:
    """Python wrapper for C type corc.LLVMOrcDisposeCAPIDefinitionGeneratorFunction.
    
    Python wrapper for C type corc.LLVMOrcDisposeCAPIDefinitionGeneratorFunction.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcDisposeCAPIDefinitionGeneratorFunction from_ptr(corc.LLVMOrcDisposeCAPIDefinitionGeneratorFunction ptr, bint owner=False):
        """Factory function to create ``LLVMOrcDisposeCAPIDefinitionGeneratorFunction`` objects from
        given ``corc.LLVMOrcDisposeCAPIDefinitionGeneratorFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcDisposeCAPIDefinitionGeneratorFunction wrapper = LLVMOrcDisposeCAPIDefinitionGeneratorFunction.__new__(LLVMOrcDisposeCAPIDefinitionGeneratorFunction)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcDisposeCAPIDefinitionGeneratorFunction from_pyobj(object pyobj):
        """Derives a LLVMOrcDisposeCAPIDefinitionGeneratorFunction from a Python object.

        Derives a LLVMOrcDisposeCAPIDefinitionGeneratorFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcDisposeCAPIDefinitionGeneratorFunction`` reference, this method
        returns it directly. No new ``LLVMOrcDisposeCAPIDefinitionGeneratorFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcDisposeCAPIDefinitionGeneratorFunction`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcDisposeCAPIDefinitionGeneratorFunction!
        """
        cdef LLVMOrcDisposeCAPIDefinitionGeneratorFunction wrapper = LLVMOrcDisposeCAPIDefinitionGeneratorFunction.__new__(LLVMOrcDisposeCAPIDefinitionGeneratorFunction)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcDisposeCAPIDefinitionGeneratorFunction):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcDisposeCAPIDefinitionGeneratorFunction>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcDisposeCAPIDefinitionGeneratorFunction>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <corc.LLVMOrcDisposeCAPIDefinitionGeneratorFunction>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcDisposeCAPIDefinitionGeneratorFunction object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcSymbolPredicate:
    """Python wrapper for C type corc.LLVMOrcSymbolPredicate.
    
    Python wrapper for C type corc.LLVMOrcSymbolPredicate.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcSymbolPredicate from_ptr(corc.LLVMOrcSymbolPredicate ptr, bint owner=False):
        """Factory function to create ``LLVMOrcSymbolPredicate`` objects from
        given ``corc.LLVMOrcSymbolPredicate`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcSymbolPredicate wrapper = LLVMOrcSymbolPredicate.__new__(LLVMOrcSymbolPredicate)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcSymbolPredicate from_pyobj(object pyobj):
        """Derives a LLVMOrcSymbolPredicate from a Python object.

        Derives a LLVMOrcSymbolPredicate from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcSymbolPredicate`` reference, this method
        returns it directly. No new ``LLVMOrcSymbolPredicate`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcSymbolPredicate`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcSymbolPredicate!
        """
        cdef LLVMOrcSymbolPredicate wrapper = LLVMOrcSymbolPredicate.__new__(LLVMOrcSymbolPredicate)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcSymbolPredicate):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcSymbolPredicate>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcSymbolPredicate>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <corc.LLVMOrcSymbolPredicate>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcSymbolPredicate object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcOpaqueThreadSafeContext:
    """Python wrapper for C type corc.LLVMOrcOpaqueThreadSafeContext.
    
    Python wrapper for C type corc.LLVMOrcOpaqueThreadSafeContext.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueThreadSafeContext from_ptr(corc.LLVMOrcOpaqueThreadSafeContext* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueThreadSafeContext`` objects from
        given ``corc.LLVMOrcOpaqueThreadSafeContext`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueThreadSafeContext wrapper = LLVMOrcOpaqueThreadSafeContext.__new__(LLVMOrcOpaqueThreadSafeContext)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueThreadSafeContext from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueThreadSafeContext from a Python object.

        Derives a LLVMOrcOpaqueThreadSafeContext from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueThreadSafeContext`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueThreadSafeContext`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueThreadSafeContext`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueThreadSafeContext!
        """
        cdef LLVMOrcOpaqueThreadSafeContext wrapper = LLVMOrcOpaqueThreadSafeContext.__new__(LLVMOrcOpaqueThreadSafeContext)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueThreadSafeContext):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueThreadSafeContext*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueThreadSafeContext*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueThreadSafeContext*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueThreadSafeContext*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueThreadSafeContext object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcThreadSafeContextRef = LLVMOrcOpaqueThreadSafeContext

cdef class LLVMOrcOpaqueThreadSafeModule:
    """Python wrapper for C type corc.LLVMOrcOpaqueThreadSafeModule.
    
    Python wrapper for C type corc.LLVMOrcOpaqueThreadSafeModule.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueThreadSafeModule from_ptr(corc.LLVMOrcOpaqueThreadSafeModule* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueThreadSafeModule`` objects from
        given ``corc.LLVMOrcOpaqueThreadSafeModule`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueThreadSafeModule wrapper = LLVMOrcOpaqueThreadSafeModule.__new__(LLVMOrcOpaqueThreadSafeModule)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueThreadSafeModule from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueThreadSafeModule from a Python object.

        Derives a LLVMOrcOpaqueThreadSafeModule from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueThreadSafeModule`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueThreadSafeModule`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueThreadSafeModule`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueThreadSafeModule!
        """
        cdef LLVMOrcOpaqueThreadSafeModule wrapper = LLVMOrcOpaqueThreadSafeModule.__new__(LLVMOrcOpaqueThreadSafeModule)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueThreadSafeModule):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueThreadSafeModule*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueThreadSafeModule*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueThreadSafeModule*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueThreadSafeModule*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueThreadSafeModule object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcThreadSafeModuleRef = LLVMOrcOpaqueThreadSafeModule

cdef class LLVMOrcGenericIRModuleOperationFunction:
    """Python wrapper for C type corc.LLVMOrcGenericIRModuleOperationFunction.
    
    Python wrapper for C type corc.LLVMOrcGenericIRModuleOperationFunction.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcGenericIRModuleOperationFunction from_ptr(corc.LLVMOrcGenericIRModuleOperationFunction ptr, bint owner=False):
        """Factory function to create ``LLVMOrcGenericIRModuleOperationFunction`` objects from
        given ``corc.LLVMOrcGenericIRModuleOperationFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcGenericIRModuleOperationFunction wrapper = LLVMOrcGenericIRModuleOperationFunction.__new__(LLVMOrcGenericIRModuleOperationFunction)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcGenericIRModuleOperationFunction from_pyobj(object pyobj):
        """Derives a LLVMOrcGenericIRModuleOperationFunction from a Python object.

        Derives a LLVMOrcGenericIRModuleOperationFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcGenericIRModuleOperationFunction`` reference, this method
        returns it directly. No new ``LLVMOrcGenericIRModuleOperationFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcGenericIRModuleOperationFunction`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcGenericIRModuleOperationFunction!
        """
        cdef LLVMOrcGenericIRModuleOperationFunction wrapper = LLVMOrcGenericIRModuleOperationFunction.__new__(LLVMOrcGenericIRModuleOperationFunction)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcGenericIRModuleOperationFunction):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcGenericIRModuleOperationFunction>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcGenericIRModuleOperationFunction>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <corc.LLVMOrcGenericIRModuleOperationFunction>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcGenericIRModuleOperationFunction object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcOpaqueJITTargetMachineBuilder:
    """Python wrapper for C type corc.LLVMOrcOpaqueJITTargetMachineBuilder.
    
    Python wrapper for C type corc.LLVMOrcOpaqueJITTargetMachineBuilder.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueJITTargetMachineBuilder from_ptr(corc.LLVMOrcOpaqueJITTargetMachineBuilder* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueJITTargetMachineBuilder`` objects from
        given ``corc.LLVMOrcOpaqueJITTargetMachineBuilder`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueJITTargetMachineBuilder wrapper = LLVMOrcOpaqueJITTargetMachineBuilder.__new__(LLVMOrcOpaqueJITTargetMachineBuilder)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueJITTargetMachineBuilder from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueJITTargetMachineBuilder from a Python object.

        Derives a LLVMOrcOpaqueJITTargetMachineBuilder from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueJITTargetMachineBuilder`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueJITTargetMachineBuilder`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueJITTargetMachineBuilder`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueJITTargetMachineBuilder!
        """
        cdef LLVMOrcOpaqueJITTargetMachineBuilder wrapper = LLVMOrcOpaqueJITTargetMachineBuilder.__new__(LLVMOrcOpaqueJITTargetMachineBuilder)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueJITTargetMachineBuilder):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueJITTargetMachineBuilder*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueJITTargetMachineBuilder*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueJITTargetMachineBuilder*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueJITTargetMachineBuilder*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueJITTargetMachineBuilder object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcJITTargetMachineBuilderRef = LLVMOrcOpaqueJITTargetMachineBuilder

cdef class LLVMOrcOpaqueObjectLayer:
    """Python wrapper for C type corc.LLVMOrcOpaqueObjectLayer.
    
    Python wrapper for C type corc.LLVMOrcOpaqueObjectLayer.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueObjectLayer from_ptr(corc.LLVMOrcOpaqueObjectLayer* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueObjectLayer`` objects from
        given ``corc.LLVMOrcOpaqueObjectLayer`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueObjectLayer wrapper = LLVMOrcOpaqueObjectLayer.__new__(LLVMOrcOpaqueObjectLayer)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueObjectLayer from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueObjectLayer from a Python object.

        Derives a LLVMOrcOpaqueObjectLayer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueObjectLayer`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueObjectLayer`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueObjectLayer`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueObjectLayer!
        """
        cdef LLVMOrcOpaqueObjectLayer wrapper = LLVMOrcOpaqueObjectLayer.__new__(LLVMOrcOpaqueObjectLayer)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueObjectLayer):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueObjectLayer*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueObjectLayer*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueObjectLayer*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueObjectLayer*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueObjectLayer object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcObjectLayerRef = LLVMOrcOpaqueObjectLayer

cdef class LLVMOrcOpaqueObjectLinkingLayer:
    """Python wrapper for C type corc.LLVMOrcOpaqueObjectLinkingLayer.
    
    Python wrapper for C type corc.LLVMOrcOpaqueObjectLinkingLayer.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueObjectLinkingLayer from_ptr(corc.LLVMOrcOpaqueObjectLinkingLayer* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueObjectLinkingLayer`` objects from
        given ``corc.LLVMOrcOpaqueObjectLinkingLayer`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueObjectLinkingLayer wrapper = LLVMOrcOpaqueObjectLinkingLayer.__new__(LLVMOrcOpaqueObjectLinkingLayer)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueObjectLinkingLayer from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueObjectLinkingLayer from a Python object.

        Derives a LLVMOrcOpaqueObjectLinkingLayer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueObjectLinkingLayer`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueObjectLinkingLayer`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueObjectLinkingLayer`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueObjectLinkingLayer!
        """
        cdef LLVMOrcOpaqueObjectLinkingLayer wrapper = LLVMOrcOpaqueObjectLinkingLayer.__new__(LLVMOrcOpaqueObjectLinkingLayer)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueObjectLinkingLayer):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueObjectLinkingLayer*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueObjectLinkingLayer*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueObjectLinkingLayer*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueObjectLinkingLayer*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueObjectLinkingLayer object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcObjectLinkingLayerRef = LLVMOrcOpaqueObjectLinkingLayer

cdef class LLVMOrcOpaqueIRTransformLayer:
    """Python wrapper for C type corc.LLVMOrcOpaqueIRTransformLayer.
    
    Python wrapper for C type corc.LLVMOrcOpaqueIRTransformLayer.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueIRTransformLayer from_ptr(corc.LLVMOrcOpaqueIRTransformLayer* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueIRTransformLayer`` objects from
        given ``corc.LLVMOrcOpaqueIRTransformLayer`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueIRTransformLayer wrapper = LLVMOrcOpaqueIRTransformLayer.__new__(LLVMOrcOpaqueIRTransformLayer)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueIRTransformLayer from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueIRTransformLayer from a Python object.

        Derives a LLVMOrcOpaqueIRTransformLayer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueIRTransformLayer`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueIRTransformLayer`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueIRTransformLayer`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueIRTransformLayer!
        """
        cdef LLVMOrcOpaqueIRTransformLayer wrapper = LLVMOrcOpaqueIRTransformLayer.__new__(LLVMOrcOpaqueIRTransformLayer)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueIRTransformLayer):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueIRTransformLayer*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueIRTransformLayer*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueIRTransformLayer*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueIRTransformLayer*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueIRTransformLayer object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcIRTransformLayerRef = LLVMOrcOpaqueIRTransformLayer

cdef class LLVMOrcIRTransformLayerTransformFunction:
    """Python wrapper for C type corc.LLVMOrcIRTransformLayerTransformFunction.
    
    Python wrapper for C type corc.LLVMOrcIRTransformLayerTransformFunction.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcIRTransformLayerTransformFunction from_ptr(corc.LLVMOrcIRTransformLayerTransformFunction ptr, bint owner=False):
        """Factory function to create ``LLVMOrcIRTransformLayerTransformFunction`` objects from
        given ``corc.LLVMOrcIRTransformLayerTransformFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcIRTransformLayerTransformFunction wrapper = LLVMOrcIRTransformLayerTransformFunction.__new__(LLVMOrcIRTransformLayerTransformFunction)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcIRTransformLayerTransformFunction from_pyobj(object pyobj):
        """Derives a LLVMOrcIRTransformLayerTransformFunction from a Python object.

        Derives a LLVMOrcIRTransformLayerTransformFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcIRTransformLayerTransformFunction`` reference, this method
        returns it directly. No new ``LLVMOrcIRTransformLayerTransformFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcIRTransformLayerTransformFunction`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcIRTransformLayerTransformFunction!
        """
        cdef LLVMOrcIRTransformLayerTransformFunction wrapper = LLVMOrcIRTransformLayerTransformFunction.__new__(LLVMOrcIRTransformLayerTransformFunction)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcIRTransformLayerTransformFunction):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcIRTransformLayerTransformFunction>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcIRTransformLayerTransformFunction>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <corc.LLVMOrcIRTransformLayerTransformFunction>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcIRTransformLayerTransformFunction object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcOpaqueObjectTransformLayer:
    """Python wrapper for C type corc.LLVMOrcOpaqueObjectTransformLayer.
    
    Python wrapper for C type corc.LLVMOrcOpaqueObjectTransformLayer.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueObjectTransformLayer from_ptr(corc.LLVMOrcOpaqueObjectTransformLayer* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueObjectTransformLayer`` objects from
        given ``corc.LLVMOrcOpaqueObjectTransformLayer`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueObjectTransformLayer wrapper = LLVMOrcOpaqueObjectTransformLayer.__new__(LLVMOrcOpaqueObjectTransformLayer)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueObjectTransformLayer from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueObjectTransformLayer from a Python object.

        Derives a LLVMOrcOpaqueObjectTransformLayer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueObjectTransformLayer`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueObjectTransformLayer`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueObjectTransformLayer`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueObjectTransformLayer!
        """
        cdef LLVMOrcOpaqueObjectTransformLayer wrapper = LLVMOrcOpaqueObjectTransformLayer.__new__(LLVMOrcOpaqueObjectTransformLayer)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueObjectTransformLayer):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueObjectTransformLayer*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueObjectTransformLayer*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueObjectTransformLayer*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueObjectTransformLayer*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueObjectTransformLayer object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcObjectTransformLayerRef = LLVMOrcOpaqueObjectTransformLayer

cdef class LLVMOrcObjectTransformLayerTransformFunction:
    """Python wrapper for C type corc.LLVMOrcObjectTransformLayerTransformFunction.
    
    Python wrapper for C type corc.LLVMOrcObjectTransformLayerTransformFunction.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcObjectTransformLayerTransformFunction from_ptr(corc.LLVMOrcObjectTransformLayerTransformFunction ptr, bint owner=False):
        """Factory function to create ``LLVMOrcObjectTransformLayerTransformFunction`` objects from
        given ``corc.LLVMOrcObjectTransformLayerTransformFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcObjectTransformLayerTransformFunction wrapper = LLVMOrcObjectTransformLayerTransformFunction.__new__(LLVMOrcObjectTransformLayerTransformFunction)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcObjectTransformLayerTransformFunction from_pyobj(object pyobj):
        """Derives a LLVMOrcObjectTransformLayerTransformFunction from a Python object.

        Derives a LLVMOrcObjectTransformLayerTransformFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcObjectTransformLayerTransformFunction`` reference, this method
        returns it directly. No new ``LLVMOrcObjectTransformLayerTransformFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcObjectTransformLayerTransformFunction`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcObjectTransformLayerTransformFunction!
        """
        cdef LLVMOrcObjectTransformLayerTransformFunction wrapper = LLVMOrcObjectTransformLayerTransformFunction.__new__(LLVMOrcObjectTransformLayerTransformFunction)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcObjectTransformLayerTransformFunction):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcObjectTransformLayerTransformFunction>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcObjectTransformLayerTransformFunction>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <corc.LLVMOrcObjectTransformLayerTransformFunction>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcObjectTransformLayerTransformFunction object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMOrcOpaqueIndirectStubsManager:
    """Python wrapper for C type corc.LLVMOrcOpaqueIndirectStubsManager.
    
    Python wrapper for C type corc.LLVMOrcOpaqueIndirectStubsManager.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueIndirectStubsManager from_ptr(corc.LLVMOrcOpaqueIndirectStubsManager* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueIndirectStubsManager`` objects from
        given ``corc.LLVMOrcOpaqueIndirectStubsManager`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueIndirectStubsManager wrapper = LLVMOrcOpaqueIndirectStubsManager.__new__(LLVMOrcOpaqueIndirectStubsManager)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueIndirectStubsManager from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueIndirectStubsManager from a Python object.

        Derives a LLVMOrcOpaqueIndirectStubsManager from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueIndirectStubsManager`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueIndirectStubsManager`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueIndirectStubsManager`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueIndirectStubsManager!
        """
        cdef LLVMOrcOpaqueIndirectStubsManager wrapper = LLVMOrcOpaqueIndirectStubsManager.__new__(LLVMOrcOpaqueIndirectStubsManager)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueIndirectStubsManager):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueIndirectStubsManager*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueIndirectStubsManager*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueIndirectStubsManager*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueIndirectStubsManager*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueIndirectStubsManager object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcIndirectStubsManagerRef = LLVMOrcOpaqueIndirectStubsManager

cdef class LLVMOrcOpaqueLazyCallThroughManager:
    """Python wrapper for C type corc.LLVMOrcOpaqueLazyCallThroughManager.
    
    Python wrapper for C type corc.LLVMOrcOpaqueLazyCallThroughManager.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueLazyCallThroughManager from_ptr(corc.LLVMOrcOpaqueLazyCallThroughManager* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueLazyCallThroughManager`` objects from
        given ``corc.LLVMOrcOpaqueLazyCallThroughManager`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueLazyCallThroughManager wrapper = LLVMOrcOpaqueLazyCallThroughManager.__new__(LLVMOrcOpaqueLazyCallThroughManager)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueLazyCallThroughManager from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueLazyCallThroughManager from a Python object.

        Derives a LLVMOrcOpaqueLazyCallThroughManager from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueLazyCallThroughManager`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueLazyCallThroughManager`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueLazyCallThroughManager`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueLazyCallThroughManager!
        """
        cdef LLVMOrcOpaqueLazyCallThroughManager wrapper = LLVMOrcOpaqueLazyCallThroughManager.__new__(LLVMOrcOpaqueLazyCallThroughManager)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueLazyCallThroughManager):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueLazyCallThroughManager*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueLazyCallThroughManager*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueLazyCallThroughManager*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueLazyCallThroughManager*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueLazyCallThroughManager object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcLazyCallThroughManagerRef = LLVMOrcOpaqueLazyCallThroughManager

cdef class LLVMOrcOpaqueDumpObjects:
    """Python wrapper for C type corc.LLVMOrcOpaqueDumpObjects.
    
    Python wrapper for C type corc.LLVMOrcOpaqueDumpObjects.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcOpaqueDumpObjects from_ptr(corc.LLVMOrcOpaqueDumpObjects* ptr, bint owner=False):
        """Factory function to create ``LLVMOrcOpaqueDumpObjects`` objects from
        given ``corc.LLVMOrcOpaqueDumpObjects`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcOpaqueDumpObjects wrapper = LLVMOrcOpaqueDumpObjects.__new__(LLVMOrcOpaqueDumpObjects)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcOpaqueDumpObjects from_pyobj(object pyobj):
        """Derives a LLVMOrcOpaqueDumpObjects from a Python object.

        Derives a LLVMOrcOpaqueDumpObjects from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcOpaqueDumpObjects`` reference, this method
        returns it directly. No new ``LLVMOrcOpaqueDumpObjects`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcOpaqueDumpObjects`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcOpaqueDumpObjects!
        """
        cdef LLVMOrcOpaqueDumpObjects wrapper = LLVMOrcOpaqueDumpObjects.__new__(LLVMOrcOpaqueDumpObjects)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcOpaqueDumpObjects):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcOpaqueDumpObjects*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcOpaqueDumpObjects*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <corc.LLVMOrcOpaqueDumpObjects*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <corc.LLVMOrcOpaqueDumpObjects*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcOpaqueDumpObjects object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMOrcDumpObjectsRef = LLVMOrcOpaqueDumpObjects

@cython.embedsignature(True)
def LLVMOrcExecutionSessionSetErrorReporter(object ES, object ReportError, object Ctx):
    r"""(No short description, might be part of a group.)

    Attach a custom error reporter function to the ExecutionSession.

    The error reporter will be called to deliver failure notices that can not be
    directly reported to a caller. For example, failure to resolve symbols in
    the JIT linker is typically reported via the error reporter (callers
    requesting definitions from the JIT will typically be delivered a
    FailureToMaterialize error instead).

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        ReportError (`~.LLVMOrcErrorReporterFunction`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcExecutionSessionSetErrorReporter(
        LLVMOrcOpaqueExecutionSession.from_pyobj(ES)._ptr,
        LLVMOrcErrorReporterFunction.from_pyobj(ReportError)._ptr,
        <void *>rocm.llvm._util.Pointer.from_pyobj(Ctx)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcExecutionSessionGetSymbolStringPool(object ES):
    r"""(No short description, might be part of a group.)

    Return a reference to the SymbolStringPool for an ExecutionSession.

    Ownership of the pool remains with the ExecutionSession: The caller is
    not required to free the pool.

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)
    """
    _LLVMOrcExecutionSessionGetSymbolStringPool__retval = LLVMOrcSymbolStringPoolRef.from_value(corc.LLVMOrcExecutionSessionGetSymbolStringPool(
        LLVMOrcOpaqueExecutionSession.from_pyobj(ES)._ptr))    # fully specified
    return (_LLVMOrcExecutionSessionGetSymbolStringPool__retval,)


@cython.embedsignature(True)
def LLVMOrcSymbolStringPoolClearDeadEntries(object SSP):
    r"""(No short description, might be part of a group.)

    Clear all unreferenced symbol string pool entries.

    This can be called at any time to release unused entries in the
    ExecutionSession's string pool. Since it locks the pool (preventing
    interning of any new strings) it is recommended that it only be called
    infrequently, ideally when the caller has reason to believe that some
    entries will have become unreferenced, e.g. after removing a module or
    closing a JITDylib.

    Args:
        SSP (`~.LLVMOrcOpaqueSymbolStringPool`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcSymbolStringPoolClearDeadEntries(
        LLVMOrcOpaqueSymbolStringPool.from_pyobj(SSP)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcExecutionSessionIntern(object ES, const char * Name):
    r"""(No short description, might be part of a group.)

    Intern a string in the ExecutionSession's SymbolStringPool and return a
    reference to it. This increments the ref-count of the pool entry, and the
    returned value should be released once the client is done with it by
    calling LLVMOrReleaseSymbolStringPoolEntry.

    Since strings are uniqued within the SymbolStringPool
    LLVMOrcSymbolStringPoolEntryRefs can be compared by value to test string
    equality.

    Note that this function does not perform linker-mangling on the string.

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        Name (`~.bytes`):
            (undocumented)
    """
    _LLVMOrcExecutionSessionIntern__retval = LLVMOrcSymbolStringPoolEntryRef.from_value(corc.LLVMOrcExecutionSessionIntern(
        LLVMOrcOpaqueExecutionSession.from_pyobj(ES)._ptr,Name))    # fully specified
    return (_LLVMOrcExecutionSessionIntern__retval,)


cdef class LLVMOrcExecutionSessionLookupHandleResultFunction:
    """Python wrapper for C type corc.LLVMOrcExecutionSessionLookupHandleResultFunction.
    
    Python wrapper for C type corc.LLVMOrcExecutionSessionLookupHandleResultFunction.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOrcExecutionSessionLookupHandleResultFunction from_ptr(corc.LLVMOrcExecutionSessionLookupHandleResultFunction ptr, bint owner=False):
        """Factory function to create ``LLVMOrcExecutionSessionLookupHandleResultFunction`` objects from
        given ``corc.LLVMOrcExecutionSessionLookupHandleResultFunction`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOrcExecutionSessionLookupHandleResultFunction wrapper = LLVMOrcExecutionSessionLookupHandleResultFunction.__new__(LLVMOrcExecutionSessionLookupHandleResultFunction)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOrcExecutionSessionLookupHandleResultFunction from_pyobj(object pyobj):
        """Derives a LLVMOrcExecutionSessionLookupHandleResultFunction from a Python object.

        Derives a LLVMOrcExecutionSessionLookupHandleResultFunction from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOrcExecutionSessionLookupHandleResultFunction`` reference, this method
        returns it directly. No new ``LLVMOrcExecutionSessionLookupHandleResultFunction`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOrcExecutionSessionLookupHandleResultFunction`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOrcExecutionSessionLookupHandleResultFunction!
        """
        cdef LLVMOrcExecutionSessionLookupHandleResultFunction wrapper = LLVMOrcExecutionSessionLookupHandleResultFunction.__new__(LLVMOrcExecutionSessionLookupHandleResultFunction)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOrcExecutionSessionLookupHandleResultFunction):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <corc.LLVMOrcExecutionSessionLookupHandleResultFunction>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <corc.LLVMOrcExecutionSessionLookupHandleResultFunction>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <corc.LLVMOrcExecutionSessionLookupHandleResultFunction>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOrcExecutionSessionLookupHandleResultFunction object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def LLVMOrcExecutionSessionLookup(object ES, object K, object SearchOrder, unsigned long SearchOrderSize, object Symbols, unsigned long SymbolsSize, object HandleResult, object Ctx):
    r"""(No short description, might be part of a group.)

    Look up symbols in an execution session.

    This is a wrapper around the general ExecutionSession`~.lookup` function.

    The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags)
    pairs that describe the search order. The JITDylibs will be searched in the
    given order to try to find the symbols in the Symbols argument.

    The Symbols argument should contain a null-terminated array of
    (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be
    searched for. This function takes ownership of the elements of the Symbols
    array. The Name fields of the Symbols elements are taken to have been
    retained by the client for this function. The client should *not* release the
    Name fields, but are still responsible for destroying the array itself.

    The HandleResult function will be called once all searched for symbols have
    been found, or an error occurs. The HandleResult function will be passed an
    LLVMErrorRef indicating success or failure, and (on success) a
    null-terminated LLVMOrcCSymbolMapPairs array containing the function result,
    and the Ctx value passed to the lookup function.

    The client is fully responsible for managing the lifetime of the Ctx object.
    A common idiom is to allocate the context prior to the lookup and deallocate
    it in the handler.

    THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        K (`~.LLVMOrcLookupKind`):
            (undocumented)

        SearchOrder (`~.LLVMOrcCJITDylibSearchOrderElement`/`~.object`):
            (undocumented)

        SearchOrderSize (`~.int`):
            (undocumented)

        Symbols (`~.LLVMOrcCLookupSetElement`/`~.object`):
            (undocumented)

        SymbolsSize (`~.int`):
            (undocumented)

        HandleResult (`~.LLVMOrcExecutionSessionLookupHandleResultFunction`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(K,_LLVMOrcLookupKind__Base):
        raise TypeError("argument 'K' must be of type '_LLVMOrcLookupKind__Base'")
    corc.LLVMOrcExecutionSessionLookup(
        LLVMOrcOpaqueExecutionSession.from_pyobj(ES)._ptr,K.value,
        LLVMOrcCJITDylibSearchOrderElement.from_pyobj(SearchOrder)._ptr,SearchOrderSize,
        LLVMOrcCLookupSetElement.from_pyobj(Symbols)._ptr,SymbolsSize,
        LLVMOrcExecutionSessionLookupHandleResultFunction.from_pyobj(HandleResult)._ptr,
        <void *>rocm.llvm._util.Pointer.from_pyobj(Ctx)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcRetainSymbolStringPoolEntry(object S):
    r"""(No short description, might be part of a group.)

    Increments the ref-count for a SymbolStringPool entry.

    Args:
        S (`~.LLVMOrcOpaqueSymbolStringPoolEntry`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcRetainSymbolStringPoolEntry(
        LLVMOrcOpaqueSymbolStringPoolEntry.from_pyobj(S)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcReleaseSymbolStringPoolEntry(object S):
    r"""(No short description, might be part of a group.)

    Reduces the ref-count for of a SymbolStringPool entry.

    Args:
        S (`~.LLVMOrcOpaqueSymbolStringPoolEntry`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcReleaseSymbolStringPoolEntry(
        LLVMOrcOpaqueSymbolStringPoolEntry.from_pyobj(S)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcSymbolStringPoolEntryStr(object S):
    r"""(No short description, might be part of a group.)

    Return the c-string for the given symbol. This string will remain valid until
    the entry is freed (once all LLVMOrcSymbolStringPoolEntryRefs have been
    released).

    Args:
        S (`~.LLVMOrcOpaqueSymbolStringPoolEntry`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.bytes`
    """
    cdef const char * _LLVMOrcSymbolStringPoolEntryStr__retval = corc.LLVMOrcSymbolStringPoolEntryStr(
        LLVMOrcOpaqueSymbolStringPoolEntry.from_pyobj(S)._ptr)    # fully specified
    return (_LLVMOrcSymbolStringPoolEntryStr__retval,)


@cython.embedsignature(True)
def LLVMOrcReleaseResourceTracker(object RT):
    r"""(No short description, might be part of a group.)

    Reduces the ref-count of a ResourceTracker.

    Args:
        RT (`~.LLVMOrcOpaqueResourceTracker`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcReleaseResourceTracker(
        LLVMOrcOpaqueResourceTracker.from_pyobj(RT)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcResourceTrackerTransferTo(object SrcRT, object DstRT):
    r"""(No short description, might be part of a group.)

    Transfers tracking of all resources associated with resource tracker SrcRT
    to resource tracker DstRT.

    Args:
        SrcRT (`~.LLVMOrcOpaqueResourceTracker`/`~.object`):
            (undocumented)

        DstRT (`~.LLVMOrcOpaqueResourceTracker`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcResourceTrackerTransferTo(
        LLVMOrcOpaqueResourceTracker.from_pyobj(SrcRT)._ptr,
        LLVMOrcOpaqueResourceTracker.from_pyobj(DstRT)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcResourceTrackerRemove(object RT):
    r"""(No short description, might be part of a group.)

    Remove all resources associated with the given tracker. See
    ResourceTracker`~.remove`().

    Args:
        RT (`~.LLVMOrcOpaqueResourceTracker`/`~.object`):
            (undocumented)
    """
    _LLVMOrcResourceTrackerRemove__retval = LLVMErrorRef.from_value(corc.LLVMOrcResourceTrackerRemove(
        LLVMOrcOpaqueResourceTracker.from_pyobj(RT)._ptr))    # fully specified
    return (_LLVMOrcResourceTrackerRemove__retval,)


@cython.embedsignature(True)
def LLVMOrcDisposeDefinitionGenerator(object DG):
    r"""(No short description, might be part of a group.)

    Dispose of a JITDylib`~.DefinitionGenerator`. This should only be called if
    ownership has not been passed to a JITDylib (e.g. because some error
    prevented the client from calling LLVMOrcJITDylibAddGenerator).

    Args:
        DG (`~.LLVMOrcOpaqueDefinitionGenerator`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeDefinitionGenerator(
        LLVMOrcOpaqueDefinitionGenerator.from_pyobj(DG)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcDisposeMaterializationUnit(object MU):
    r"""(No short description, might be part of a group.)

    Dispose of a MaterializationUnit.

    Args:
        MU (`~.LLVMOrcOpaqueMaterializationUnit`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeMaterializationUnit(
        LLVMOrcOpaqueMaterializationUnit.from_pyobj(MU)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcCreateCustomMaterializationUnit(const char * Name, object Ctx, object Syms, unsigned long NumSyms, object InitSym, object Materialize, object Discard, object Destroy):
    r"""(No short description, might be part of a group.)

    Create a custom MaterializationUnit.

    Name is a name for this MaterializationUnit to be used for identification
    and logging purposes (e.g. if this MaterializationUnit produces an
    object buffer then the name of that buffer will be derived from this name).

    The Syms list contains the names and linkages of the symbols provided by this
    unit. This function takes ownership of the elements of the Syms array. The
    Name fields of the array elements are taken to have been retained for this
    function. The client should *not* release the elements of the array, but is
    still responsible for destroying the array itself.

    The InitSym argument indicates whether or not this MaterializationUnit
    contains static initializers. If three are no static initializers (the common
    case) then this argument should be null. If there are static initializers
    then InitSym should be set to a unique name that also appears in the Syms
    list with the LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly flag
    set. This function takes ownership of the InitSym, which should have been
    retained twice on behalf of this function: once for the Syms entry and once
    for InitSym. If clients wish to use the InitSym value after this function
    returns they must retain it once more for themselves.

    If any of the symbols in the Syms list is looked up then the Materialize
    function will be called.

    If any of the symbols in the Syms list is overridden then the Discard
    function will be called.

    The caller owns the underling MaterializationUnit and is responsible for
    either passing it to a JITDylib (via LLVMOrcJITDylibDefine) or disposing
    of it by calling LLVMOrcDisposeMaterializationUnit.

    Args:
        Name (`~.bytes`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)

        Syms (`~.LLVMOrcCSymbolFlagsMapPair`/`~.object`):
            (undocumented)

        NumSyms (`~.int`):
            (undocumented)

        InitSym (`~.LLVMOrcOpaqueSymbolStringPoolEntry`/`~.object`):
            (undocumented)

        Materialize (`~.LLVMOrcMaterializationUnitMaterializeFunction`/`~.object`):
            (undocumented)

        Discard (`~.LLVMOrcMaterializationUnitDiscardFunction`/`~.object`):
            (undocumented)

        Destroy (`~.LLVMOrcMaterializationUnitDestroyFunction`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateCustomMaterializationUnit__retval = LLVMOrcMaterializationUnitRef.from_value(corc.LLVMOrcCreateCustomMaterializationUnit(Name,
        <void *>rocm.llvm._util.Pointer.from_pyobj(Ctx)._ptr,
        LLVMOrcCSymbolFlagsMapPair.from_pyobj(Syms)._ptr,NumSyms,
        LLVMOrcOpaqueSymbolStringPoolEntry.from_pyobj(InitSym)._ptr,
        LLVMOrcMaterializationUnitMaterializeFunction.from_pyobj(Materialize)._ptr,
        LLVMOrcMaterializationUnitDiscardFunction.from_pyobj(Discard)._ptr,
        LLVMOrcMaterializationUnitDestroyFunction.from_pyobj(Destroy)._ptr))    # fully specified
    return (_LLVMOrcCreateCustomMaterializationUnit__retval,)


@cython.embedsignature(True)
def LLVMOrcAbsoluteSymbols(object Syms, unsigned long NumPairs):
    r"""(No short description, might be part of a group.)

    Create a MaterializationUnit to define the given symbols as pointing to
    the corresponding raw addresses.

    This function takes ownership of the elements of the Syms array. The Name
    fields of the array elements are taken to have been retained for this
    function. This allows the following pattern...

      size_t NumPairs;
      LLVMOrcCSymbolMapPairs Sym;
      -- Build Syms array --
      LLVMOrcMaterializationUnitRef MU =
          LLVMOrcAbsoluteSymbols(Syms, NumPairs);

    ... without requiring cleanup of the elements of the Sym array afterwards.

    The client is still responsible for deleting the Sym array itself.

    If a client wishes to reuse elements of the Sym array after this call they
    must explicitly retain each of the elements for themselves.

    Args:
        Syms (`~.LLVMOrcCSymbolMapPair`/`~.object`):
            (undocumented)

        NumPairs (`~.int`):
            (undocumented)
    """
    _LLVMOrcAbsoluteSymbols__retval = LLVMOrcMaterializationUnitRef.from_value(corc.LLVMOrcAbsoluteSymbols(
        LLVMOrcCSymbolMapPair.from_pyobj(Syms)._ptr,NumPairs))    # fully specified
    return (_LLVMOrcAbsoluteSymbols__retval,)


@cython.embedsignature(True)
def LLVMOrcLazyReexports(object LCTM, object ISM, object SourceRef, object CallableAliases, unsigned long NumPairs):
    r"""(No short description, might be part of a group.)

    Create a MaterializationUnit to define lazy re-expots. These are callable
    entry points that call through to the given symbols.

    This function takes ownership of the CallableAliases array. The Name
    fields of the array elements are taken to have been retained for this
    function. This allows the following pattern...

      size_t NumPairs;
      LLVMOrcCSymbolAliasMapPairs CallableAliases;
      -- Build CallableAliases array --
      LLVMOrcMaterializationUnitRef MU =
         LLVMOrcLazyReexports(LCTM, ISM, JD, CallableAliases, NumPairs);

    ... without requiring cleanup of the elements of the CallableAliases array afterwards.

    The client is still responsible for deleting the CallableAliases array itself.

    If a client wishes to reuse elements of the CallableAliases array after this call they
    must explicitly retain each of the elements for themselves.

    Args:
        LCTM (`~.LLVMOrcOpaqueLazyCallThroughManager`/`~.object`):
            (undocumented)

        ISM (`~.LLVMOrcOpaqueIndirectStubsManager`/`~.object`):
            (undocumented)

        SourceRef (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)

        CallableAliases (`~.LLVMOrcCSymbolAliasMapPair`/`~.object`):
            (undocumented)

        NumPairs (`~.int`):
            (undocumented)
    """
    _LLVMOrcLazyReexports__retval = LLVMOrcMaterializationUnitRef.from_value(corc.LLVMOrcLazyReexports(
        LLVMOrcOpaqueLazyCallThroughManager.from_pyobj(LCTM)._ptr,
        LLVMOrcOpaqueIndirectStubsManager.from_pyobj(ISM)._ptr,
        LLVMOrcOpaqueJITDylib.from_pyobj(SourceRef)._ptr,
        LLVMOrcCSymbolAliasMapPair.from_pyobj(CallableAliases)._ptr,NumPairs))    # fully specified
    return (_LLVMOrcLazyReexports__retval,)


@cython.embedsignature(True)
def LLVMOrcDisposeMaterializationResponsibility(object MR):
    r"""(No short description, might be part of a group.)

    Disposes of the passed MaterializationResponsibility object.

    This should only be done after the symbols covered by the object have either
    been resolved and emitted (via
    LLVMOrcMaterializationResponsibilityNotifyResolved and
    LLVMOrcMaterializationResponsibilityNotifyEmitted) or failed (via
    LLVMOrcMaterializationResponsibilityFailMaterialization).

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeMaterializationResponsibility(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityGetTargetDylib(object MR):
    r"""(No short description, might be part of a group.)

    Returns the target JITDylib that these symbols are being materialized into.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityGetTargetDylib__retval = LLVMOrcJITDylibRef.from_value(corc.LLVMOrcMaterializationResponsibilityGetTargetDylib(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr))    # fully specified
    return (_LLVMOrcMaterializationResponsibilityGetTargetDylib__retval,)


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityGetExecutionSession(object MR):
    r"""(No short description, might be part of a group.)

    Returns the ExecutionSession for this MaterializationResponsibility.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityGetExecutionSession__retval = LLVMOrcExecutionSessionRef.from_value(corc.LLVMOrcMaterializationResponsibilityGetExecutionSession(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr))    # fully specified
    return (_LLVMOrcMaterializationResponsibilityGetExecutionSession__retval,)


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityGetSymbols(object MR, object NumPairs):
    r"""(No short description, might be part of a group.)

    Returns the symbol flags map for this responsibility instance.

    The length of the array is returned in NumPairs and the caller is responsible
    for the returned memory and needs to call LLVMOrcDisposeCSymbolFlagsMap.

    To use the returned symbols beyond the livetime of the
    MaterializationResponsibility requires the caller to retain the symbols
    explicitly.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        NumPairs (`~.rocm.llvm._util.ListOfUnsignedLong`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityGetSymbols__retval = LLVMOrcCSymbolFlagsMapPairs.from_value(corc.LLVMOrcMaterializationResponsibilityGetSymbols(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr,
        <unsigned long *>rocm.llvm._util.ListOfUnsignedLong.from_pyobj(NumPairs)._ptr))    # fully specified
    return (_LLVMOrcMaterializationResponsibilityGetSymbols__retval,)


@cython.embedsignature(True)
def LLVMOrcDisposeCSymbolFlagsMap(object Pairs):
    r"""(No short description, might be part of a group.)

    Disposes of the passed LLVMOrcCSymbolFlagsMap.

    Does not release the entries themselves.

    Args:
        Pairs (`~.LLVMOrcCSymbolFlagsMapPair`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeCSymbolFlagsMap(
        LLVMOrcCSymbolFlagsMapPair.from_pyobj(Pairs)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityGetInitializerSymbol(object MR):
    r"""(No short description, might be part of a group.)

    Returns the initialization pseudo-symbol, if any. This symbol will also
    be present in the SymbolFlagsMap for this MaterializationResponsibility
    object.

    The returned symbol is not retained over any mutating operation of the
    MaterializationResponsbility or beyond the lifetime thereof.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityGetInitializerSymbol__retval = LLVMOrcSymbolStringPoolEntryRef.from_value(corc.LLVMOrcMaterializationResponsibilityGetInitializerSymbol(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr))    # fully specified
    return (_LLVMOrcMaterializationResponsibilityGetInitializerSymbol__retval,)


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityGetRequestedSymbols(object MR, object NumSymbols):
    r"""(No short description, might be part of a group.)

    Returns the names of any symbols covered by this
    MaterializationResponsibility object that have queries pending. This
    information can be used to return responsibility for unrequested symbols
    back to the JITDylib via the delegate method.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        NumSymbols (`~.rocm.llvm._util.ListOfUnsignedLong`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityGetRequestedSymbols__retval = LLVMOrcSymbolStringPoolEntryRef*.from_value(corc.LLVMOrcMaterializationResponsibilityGetRequestedSymbols(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr,
        <unsigned long *>rocm.llvm._util.ListOfUnsignedLong.from_pyobj(NumSymbols)._ptr))    # fully specified
    return (_LLVMOrcMaterializationResponsibilityGetRequestedSymbols__retval,)


@cython.embedsignature(True)
def LLVMOrcDisposeSymbols(object Symbols):
    r"""(No short description, might be part of a group.)

    Disposes of the passed LLVMOrcSymbolStringPoolEntryRef* .

    Does not release the symbols themselves.

    Args:
        Symbols (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeSymbols(
        <corc.LLVMOrcSymbolStringPoolEntryRef*>rocm.llvm._util.Pointer.from_pyobj(Symbols)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityNotifyResolved(object MR, object Symbols, unsigned long NumPairs):
    r"""(No short description, might be part of a group.)

    Notifies the target JITDylib that the given symbols have been resolved.
    This will update the given symbols' addresses in the JITDylib, and notify
    any pending queries on the given symbols of their resolution. The given
    symbols must be ones covered by this MaterializationResponsibility
    instance. Individual calls to this method may resolve a subset of the
    symbols, but all symbols must have been resolved prior to calling emit.

    This method will return an error if any symbols being resolved have been
    moved to the error state due to the failure of a dependency. If this
    method returns an error then clients should log it and call
    LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies
    have been registered for the symbols covered by this
    MaterializationResponsibiility then this method is guaranteed to return
    LLVMErrorSuccess.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        Symbols (`~.LLVMOrcCSymbolMapPair`/`~.object`):
            (undocumented)

        NumPairs (`~.int`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityNotifyResolved__retval = LLVMErrorRef.from_value(corc.LLVMOrcMaterializationResponsibilityNotifyResolved(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr,
        LLVMOrcCSymbolMapPair.from_pyobj(Symbols)._ptr,NumPairs))    # fully specified
    return (_LLVMOrcMaterializationResponsibilityNotifyResolved__retval,)


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityNotifyEmitted(object MR):
    r"""(No short description, might be part of a group.)

    Notifies the target JITDylib (and any pending queries on that JITDylib)
    that all symbols covered by this MaterializationResponsibility instance
    have been emitted.

    This method will return an error if any symbols being resolved have been
    moved to the error state due to the failure of a dependency. If this
    method returns an error then clients should log it and call
    LLVMOrcMaterializationResponsibilityFailMaterialization.
    If no dependencies have been registered for the symbols covered by this
    MaterializationResponsibiility then this method is guaranteed to return
    LLVMErrorSuccess.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityNotifyEmitted__retval = LLVMErrorRef.from_value(corc.LLVMOrcMaterializationResponsibilityNotifyEmitted(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr))    # fully specified
    return (_LLVMOrcMaterializationResponsibilityNotifyEmitted__retval,)


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityDefineMaterializing(object MR, object Pairs, unsigned long NumPairs):
    r"""(No short description, might be part of a group.)

    Attempt to claim responsibility for new definitions. This method can be
    used to claim responsibility for symbols that are added to a
    materialization unit during the compilation process (e.g. literal pool
    symbols). Symbol linkage rules are the same as for symbols that are
    defined up front: duplicate strong definitions will result in errors.
    Duplicate weak definitions will be discarded (in which case they will
    not be added to this responsibility instance).

    This method can be used by materialization units that want to add
    additional symbols at materialization time (e.g. stubs, compile
    callbacks, metadata)

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        Pairs (`~.LLVMOrcCSymbolFlagsMapPair`/`~.object`):
            (undocumented)

        NumPairs (`~.int`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityDefineMaterializing__retval = LLVMErrorRef.from_value(corc.LLVMOrcMaterializationResponsibilityDefineMaterializing(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr,
        LLVMOrcCSymbolFlagsMapPair.from_pyobj(Pairs)._ptr,NumPairs))    # fully specified
    return (_LLVMOrcMaterializationResponsibilityDefineMaterializing__retval,)


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityFailMaterialization(object MR):
    r"""(No short description, might be part of a group.)

    Notify all not-yet-emitted covered by this MaterializationResponsibility
    instance that an error has occurred.
    This will remove all symbols covered by this MaterializationResponsibilty
    from the target JITDylib, and send an error to any queries waiting on
    these symbols.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcMaterializationResponsibilityFailMaterialization(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityReplace(object MR, object MU):
    r"""(No short description, might be part of a group.)

    Transfers responsibility to the given MaterializationUnit for all
    symbols defined by that MaterializationUnit. This allows
    materializers to break up work based on run-time information (e.g.
    by introspecting which symbols have actually been looked up and
    materializing only those).

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        MU (`~.LLVMOrcOpaqueMaterializationUnit`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityReplace__retval = LLVMErrorRef.from_value(corc.LLVMOrcMaterializationResponsibilityReplace(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr,
        LLVMOrcOpaqueMaterializationUnit.from_pyobj(MU)._ptr))    # fully specified
    return (_LLVMOrcMaterializationResponsibilityReplace__retval,)


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityDelegate(object MR, object Symbols, unsigned long NumSymbols, object Result):
    r"""(No short description, might be part of a group.)

    Delegates responsibility for the given symbols to the returned
    materialization responsibility. Useful for breaking up work between
    threads, or different kinds of materialization processes.

    The caller retains responsibility of the the passed
    MaterializationResponsibility.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        Symbols (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)

        NumSymbols (`~.int`):
            (undocumented)

        Result (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcMaterializationResponsibilityDelegate__retval = LLVMErrorRef.from_value(corc.LLVMOrcMaterializationResponsibilityDelegate(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr,
        <corc.LLVMOrcSymbolStringPoolEntryRef*>rocm.llvm._util.Pointer.from_pyobj(Symbols)._ptr,NumSymbols,
        <corc.LLVMOrcMaterializationResponsibilityRef*>rocm.llvm._util.Pointer.from_pyobj(Result)._ptr))    # fully specified
    return (_LLVMOrcMaterializationResponsibilityDelegate__retval,)


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityAddDependencies(object MR, object Name, object Dependencies, unsigned long NumPairs):
    r"""(No short description, might be part of a group.)

    Adds dependencies to a symbol that the MaterializationResponsibility is
    responsible for.

    This function takes ownership of Dependencies struct. The Names
    array have been retained for this function. This allows the following
    pattern...

      LLVMOrcSymbolStringPoolEntryRef Names[] = {...};
      LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}
      LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,
    1);

    ... without requiring cleanup of the elements of the Names array afterwards.

    The client is still responsible for deleting the Dependencies.Names array
    itself.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        Name (`~.LLVMOrcOpaqueSymbolStringPoolEntry`/`~.object`):
            (undocumented)

        Dependencies (`~.LLVMOrcCDependenceMapPair`/`~.object`):
            (undocumented)

        NumPairs (`~.int`):
            (undocumented)
    """
    corc.LLVMOrcMaterializationResponsibilityAddDependencies(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr,
        LLVMOrcOpaqueSymbolStringPoolEntry.from_pyobj(Name)._ptr,
        LLVMOrcCDependenceMapPair.from_pyobj(Dependencies)._ptr,NumPairs)    # fully specified


@cython.embedsignature(True)
def LLVMOrcMaterializationResponsibilityAddDependenciesForAll(object MR, object Dependencies, unsigned long NumPairs):
    r"""(No short description, might be part of a group.)

    Adds dependencies to all symbols that the MaterializationResponsibility is
    responsible for. See LLVMOrcMaterializationResponsibilityAddDependencies for
    notes about memory responsibility.

    Args:
        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        Dependencies (`~.LLVMOrcCDependenceMapPair`/`~.object`):
            (undocumented)

        NumPairs (`~.int`):
            (undocumented)
    """
    corc.LLVMOrcMaterializationResponsibilityAddDependenciesForAll(
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr,
        LLVMOrcCDependenceMapPair.from_pyobj(Dependencies)._ptr,NumPairs)    # fully specified


@cython.embedsignature(True)
def LLVMOrcExecutionSessionCreateBareJITDylib(object ES, const char * Name):
    r"""(No short description, might be part of a group.)

    Create a "bare" JITDylib.

    The client is responsible for ensuring that the JITDylib's name is unique,
    e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.

    This call does not install any library code or symbols into the newly
    created JITDylib. The client is responsible for all configuration.

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        Name (`~.bytes`):
            (undocumented)
    """
    _LLVMOrcExecutionSessionCreateBareJITDylib__retval = LLVMOrcJITDylibRef.from_value(corc.LLVMOrcExecutionSessionCreateBareJITDylib(
        LLVMOrcOpaqueExecutionSession.from_pyobj(ES)._ptr,Name))    # fully specified
    return (_LLVMOrcExecutionSessionCreateBareJITDylib__retval,)


@cython.embedsignature(True)
def LLVMOrcExecutionSessionCreateJITDylib(object ES, object Result, const char * Name):
    r"""(No short description, might be part of a group.)

    Create a JITDylib.

    The client is responsible for ensuring that the JITDylib's name is unique,
    e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.

    If a Platform is attached to the ExecutionSession then
    Platform`~.setupJITDylib` will be called to install standard platform symbols
    (e.g. standard library interposes). If no Platform is installed then this
    call is equivalent to LLVMExecutionSessionRefCreateBareJITDylib and will
    always return success.

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        Result (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)

        Name (`~.bytes`):
            (undocumented)
    """
    _LLVMOrcExecutionSessionCreateJITDylib__retval = LLVMErrorRef.from_value(corc.LLVMOrcExecutionSessionCreateJITDylib(
        LLVMOrcOpaqueExecutionSession.from_pyobj(ES)._ptr,
        <corc.LLVMOrcJITDylibRef*>rocm.llvm._util.Pointer.from_pyobj(Result)._ptr,Name))    # fully specified
    return (_LLVMOrcExecutionSessionCreateJITDylib__retval,)


@cython.embedsignature(True)
def LLVMOrcExecutionSessionGetJITDylibByName(object ES, const char * Name):
    r"""(No short description, might be part of a group.)

    Returns the JITDylib with the given name, or NULL if no such JITDylib
    exists.

    Args:
        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        Name (`~.bytes`):
            (undocumented)
    """
    _LLVMOrcExecutionSessionGetJITDylibByName__retval = LLVMOrcJITDylibRef.from_value(corc.LLVMOrcExecutionSessionGetJITDylibByName(
        LLVMOrcOpaqueExecutionSession.from_pyobj(ES)._ptr,Name))    # fully specified
    return (_LLVMOrcExecutionSessionGetJITDylibByName__retval,)


@cython.embedsignature(True)
def LLVMOrcJITDylibCreateResourceTracker(object JD):
    r"""(No short description, might be part of a group.)

    Return a reference to a newly created resource tracker associated with JD.
    The tracker is returned with an initial ref-count of 1, and must be released
    with LLVMOrcReleaseResourceTracker when no longer needed.

    Args:
        JD (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITDylibCreateResourceTracker__retval = LLVMOrcResourceTrackerRef.from_value(corc.LLVMOrcJITDylibCreateResourceTracker(
        LLVMOrcOpaqueJITDylib.from_pyobj(JD)._ptr))    # fully specified
    return (_LLVMOrcJITDylibCreateResourceTracker__retval,)


@cython.embedsignature(True)
def LLVMOrcJITDylibGetDefaultResourceTracker(object JD):
    r"""(No short description, might be part of a group.)

    Return a reference to the default resource tracker for the given JITDylib.
    This operation will increase the retain count of the tracker: Clients should
    call LLVMOrcReleaseResourceTracker when the result is no longer needed.

    Args:
        JD (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITDylibGetDefaultResourceTracker__retval = LLVMOrcResourceTrackerRef.from_value(corc.LLVMOrcJITDylibGetDefaultResourceTracker(
        LLVMOrcOpaqueJITDylib.from_pyobj(JD)._ptr))    # fully specified
    return (_LLVMOrcJITDylibGetDefaultResourceTracker__retval,)


@cython.embedsignature(True)
def LLVMOrcJITDylibDefine(object JD, object MU):
    r"""(No short description, might be part of a group.)

    Add the given MaterializationUnit to the given JITDylib.

    If this operation succeeds then JITDylib JD will take ownership of MU.
    If the operation fails then ownership remains with the caller who should
    call LLVMOrcDisposeMaterializationUnit to destroy it.

    Args:
        JD (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)

        MU (`~.LLVMOrcOpaqueMaterializationUnit`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITDylibDefine__retval = LLVMErrorRef.from_value(corc.LLVMOrcJITDylibDefine(
        LLVMOrcOpaqueJITDylib.from_pyobj(JD)._ptr,
        LLVMOrcOpaqueMaterializationUnit.from_pyobj(MU)._ptr))    # fully specified
    return (_LLVMOrcJITDylibDefine__retval,)


@cython.embedsignature(True)
def LLVMOrcJITDylibClear(object JD):
    r"""(No short description, might be part of a group.)

    Calls remove on all trackers associated with this JITDylib, see
    JITDylib`~.clear`().

    Args:
        JD (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITDylibClear__retval = LLVMErrorRef.from_value(corc.LLVMOrcJITDylibClear(
        LLVMOrcOpaqueJITDylib.from_pyobj(JD)._ptr))    # fully specified
    return (_LLVMOrcJITDylibClear__retval,)


@cython.embedsignature(True)
def LLVMOrcJITDylibAddGenerator(object JD, object DG):
    r"""(No short description, might be part of a group.)

    Add a DefinitionGenerator to the given JITDylib.

    The JITDylib will take ownership of the given generator: The client is no
    longer responsible for managing its memory.

    Args:
        JD (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)

        DG (`~.LLVMOrcOpaqueDefinitionGenerator`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcJITDylibAddGenerator(
        LLVMOrcOpaqueJITDylib.from_pyobj(JD)._ptr,
        LLVMOrcOpaqueDefinitionGenerator.from_pyobj(DG)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcCreateCustomCAPIDefinitionGenerator(object F, object Ctx, object Dispose):
    r"""(No short description, might be part of a group.)

    Create a custom generator.

    The F argument will be used to implement the DefinitionGenerator's
    tryToGenerate method (see
    LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction).

    Ctx is a context object that will be passed to F. This argument is
    permitted to be null.

    Dispose is the disposal function for Ctx. This argument is permitted to be
    null (in which case the client is responsible for the lifetime of Ctx).

    Args:
        F (`~.LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)

        Dispose (`~.LLVMOrcDisposeCAPIDefinitionGeneratorFunction`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateCustomCAPIDefinitionGenerator__retval = LLVMOrcDefinitionGeneratorRef.from_value(corc.LLVMOrcCreateCustomCAPIDefinitionGenerator(
        LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction.from_pyobj(F)._ptr,
        <void *>rocm.llvm._util.Pointer.from_pyobj(Ctx)._ptr,
        LLVMOrcDisposeCAPIDefinitionGeneratorFunction.from_pyobj(Dispose)._ptr))    # fully specified
    return (_LLVMOrcCreateCustomCAPIDefinitionGenerator__retval,)


@cython.embedsignature(True)
def LLVMOrcLookupStateContinueLookup(object S, object Err):
    r"""(No short description, might be part of a group.)

    Continue a lookup that was suspended in a generator (see
    LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction).

    Args:
        S (`~.LLVMOrcOpaqueLookupState`/`~.object`):
            (undocumented)

        Err (`~.LLVMOpaqueError`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcLookupStateContinueLookup(
        LLVMOrcOpaqueLookupState.from_pyobj(S)._ptr,
        LLVMOpaqueError.from_pyobj(Err)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess(object Result, char GlobalPrefx, object Filter, object FilterCtx):
    r"""(No short description, might be part of a group.)

    Get a DynamicLibrarySearchGenerator that will reflect process symbols into
    the JITDylib. On success the resulting generator is owned by the client.
    Ownership is typically transferred by adding the instance to a JITDylib
    using LLVMOrcJITDylibAddGenerator,

    The GlobalPrefix argument specifies the character that appears on the front
    of linker-mangled symbols for the target platform (e.g. '_' on MachO).
    If non-null, this character will be stripped from the start of all symbol
    strings before passing the remaining substring to dlsym.

    The optional Filter and Ctx arguments can be used to supply a symbol name
    filter: Only symbols for which the filter returns true will be visible to
    JIT'd code. If the Filter argument is null then all process symbols will
    be visible to JIT'd code. Note that the symbol name passed to the Filter
    function is the full mangled symbol: The client is responsible for stripping
    the global prefix if present.

    Args:
        Result (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)

        GlobalPrefx (`~.int`):
            (undocumented)

        Filter (`~.LLVMOrcSymbolPredicate`/`~.object`):
            (undocumented)

        FilterCtx (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess__retval = LLVMErrorRef.from_value(corc.LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess(
        <corc.LLVMOrcDefinitionGeneratorRef*>rocm.llvm._util.Pointer.from_pyobj(Result)._ptr,GlobalPrefx,
        LLVMOrcSymbolPredicate.from_pyobj(Filter)._ptr,
        <void *>rocm.llvm._util.Pointer.from_pyobj(FilterCtx)._ptr))    # fully specified
    return (_LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess__retval,)


@cython.embedsignature(True)
def LLVMOrcCreateDynamicLibrarySearchGeneratorForPath(object Result, const char * FileName, char GlobalPrefix, object Filter, object FilterCtx):
    r"""(No short description, might be part of a group.)

    Get a LLVMOrcCreateDynamicLibararySearchGeneratorForPath that will reflect
    library symbols into the JITDylib. On success the resulting generator is
    owned by the client. Ownership is typically transferred by adding the
    instance to a JITDylib using LLVMOrcJITDylibAddGenerator,

    The GlobalPrefix argument specifies the character that appears on the front
    of linker-mangled symbols for the target platform (e.g. '_' on MachO).
    If non-null, this character will be stripped from the start of all symbol
    strings before passing the remaining substring to dlsym.

    The optional Filter and Ctx arguments can be used to supply a symbol name
    filter: Only symbols for which the filter returns true will be visible to
    JIT'd code. If the Filter argument is null then all library symbols will
    be visible to JIT'd code. Note that the symbol name passed to the Filter
    function is the full mangled symbol: The client is responsible for stripping
    the global prefix if present.

    THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!

    Args:
        Result (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)

        FileName (`~.bytes`):
            (undocumented)

        GlobalPrefix (`~.int`):
            (undocumented)

        Filter (`~.LLVMOrcSymbolPredicate`/`~.object`):
            (undocumented)

        FilterCtx (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateDynamicLibrarySearchGeneratorForPath__retval = LLVMErrorRef.from_value(corc.LLVMOrcCreateDynamicLibrarySearchGeneratorForPath(
        <corc.LLVMOrcDefinitionGeneratorRef*>rocm.llvm._util.Pointer.from_pyobj(Result)._ptr,FileName,GlobalPrefix,
        LLVMOrcSymbolPredicate.from_pyobj(Filter)._ptr,
        <void *>rocm.llvm._util.Pointer.from_pyobj(FilterCtx)._ptr))    # fully specified
    return (_LLVMOrcCreateDynamicLibrarySearchGeneratorForPath__retval,)


@cython.embedsignature(True)
def LLVMOrcCreateStaticLibrarySearchGeneratorForPath(object Result, object ObjLayer, const char * FileName, const char * TargetTriple):
    r"""(No short description, might be part of a group.)

    Get a LLVMOrcCreateStaticLibrarySearchGeneratorForPath that will reflect
    static library symbols into the JITDylib. On success the resulting
    generator is owned by the client. Ownership is typically transferred by
    adding the instance to a JITDylib using LLVMOrcJITDylibAddGenerator,

    Call with the optional TargetTriple argument will succeed if the file at
    the given path is a static library or a MachO universal binary containing a
    static library that is compatible with the given triple. Otherwise it will
    return an error.

    THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!

    Args:
        Result (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)

        ObjLayer (`~.LLVMOrcOpaqueObjectLayer`/`~.object`):
            (undocumented)

        FileName (`~.bytes`):
            (undocumented)

        TargetTriple (`~.bytes`):
            (undocumented)
    """
    _LLVMOrcCreateStaticLibrarySearchGeneratorForPath__retval = LLVMErrorRef.from_value(corc.LLVMOrcCreateStaticLibrarySearchGeneratorForPath(
        <corc.LLVMOrcDefinitionGeneratorRef*>rocm.llvm._util.Pointer.from_pyobj(Result)._ptr,
        LLVMOrcOpaqueObjectLayer.from_pyobj(ObjLayer)._ptr,FileName,TargetTriple))    # fully specified
    return (_LLVMOrcCreateStaticLibrarySearchGeneratorForPath__retval,)


@cython.embedsignature(True)
def LLVMOrcCreateNewThreadSafeContext():
    r"""(No short description, might be part of a group.)

    Create a ThreadSafeContext containing a new LLVMContext.

    Ownership of the underlying ThreadSafeContext data is shared: Clients
    can and should dispose of their ThreadSafeContext as soon as they no longer
    need to refer to it directly. Other references (e.g. from ThreadSafeModules)
    will keep the data alive as long as it is needed.
    """
    _LLVMOrcCreateNewThreadSafeContext__retval = LLVMOrcThreadSafeContextRef.from_value(corc.LLVMOrcCreateNewThreadSafeContext())    # fully specified
    return (_LLVMOrcCreateNewThreadSafeContext__retval,)


@cython.embedsignature(True)
def LLVMOrcThreadSafeContextGetContext(object TSCtx):
    r"""(No short description, might be part of a group.)

    Get a reference to the wrapped LLVMContext.

    Args:
        TSCtx (`~.LLVMOrcOpaqueThreadSafeContext`/`~.object`):
            (undocumented)
    """
    _LLVMOrcThreadSafeContextGetContext__retval = LLVMContextRef.from_value(corc.LLVMOrcThreadSafeContextGetContext(
        LLVMOrcOpaqueThreadSafeContext.from_pyobj(TSCtx)._ptr))    # fully specified
    return (_LLVMOrcThreadSafeContextGetContext__retval,)


@cython.embedsignature(True)
def LLVMOrcDisposeThreadSafeContext(object TSCtx):
    r"""(No short description, might be part of a group.)

    Dispose of a ThreadSafeContext.

    Args:
        TSCtx (`~.LLVMOrcOpaqueThreadSafeContext`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeThreadSafeContext(
        LLVMOrcOpaqueThreadSafeContext.from_pyobj(TSCtx)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcCreateNewThreadSafeModule(object M, object TSCtx):
    r"""(No short description, might be part of a group.)

    Create a ThreadSafeModule wrapper around the given LLVM module. This takes
    ownership of the M argument which should not be disposed of or referenced
    after this function returns.

    Ownership of the ThreadSafeModule is unique: If it is transferred to the JIT
    (e.g. by LLVMOrcLLJITAddLLVMIRModule) then the client is no longer
    responsible for it. If it is not transferred to the JIT then the client
    should call LLVMOrcDisposeThreadSafeModule to dispose of it.

    Args:
        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)

        TSCtx (`~.LLVMOrcOpaqueThreadSafeContext`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateNewThreadSafeModule__retval = LLVMOrcThreadSafeModuleRef.from_value(corc.LLVMOrcCreateNewThreadSafeModule(
        LLVMOpaqueModule.from_pyobj(M)._ptr,
        LLVMOrcOpaqueThreadSafeContext.from_pyobj(TSCtx)._ptr))    # fully specified
    return (_LLVMOrcCreateNewThreadSafeModule__retval,)


@cython.embedsignature(True)
def LLVMOrcDisposeThreadSafeModule(object TSM):
    r"""(No short description, might be part of a group.)

    Dispose of a ThreadSafeModule. This should only be called if ownership has
    not been passed to LLJIT (e.g. because some error prevented the client from
    adding this to the JIT).

    Args:
        TSM (`~.LLVMOrcOpaqueThreadSafeModule`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeThreadSafeModule(
        LLVMOrcOpaqueThreadSafeModule.from_pyobj(TSM)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcThreadSafeModuleWithModuleDo(object TSM, object F, object Ctx):
    r"""(No short description, might be part of a group.)

    Apply the given function to the module contained in this ThreadSafeModule.

    Args:
        TSM (`~.LLVMOrcOpaqueThreadSafeModule`/`~.object`):
            (undocumented)

        F (`~.LLVMOrcGenericIRModuleOperationFunction`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcThreadSafeModuleWithModuleDo__retval = LLVMErrorRef.from_value(corc.LLVMOrcThreadSafeModuleWithModuleDo(
        LLVMOrcOpaqueThreadSafeModule.from_pyobj(TSM)._ptr,
        LLVMOrcGenericIRModuleOperationFunction.from_pyobj(F)._ptr,
        <void *>rocm.llvm._util.Pointer.from_pyobj(Ctx)._ptr))    # fully specified
    return (_LLVMOrcThreadSafeModuleWithModuleDo__retval,)


@cython.embedsignature(True)
def LLVMOrcJITTargetMachineBuilderDetectHost(object Result):
    r"""(No short description, might be part of a group.)

    Create a JITTargetMachineBuilder by detecting the host.

    On success the client owns the resulting JITTargetMachineBuilder. It must be
    passed to a consuming operation (e.g.
    LLVMOrcLLJITBuilderSetJITTargetMachineBuilder) or disposed of by calling
    LLVMOrcDisposeJITTargetMachineBuilder.

    Args:
        Result (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITTargetMachineBuilderDetectHost__retval = LLVMErrorRef.from_value(corc.LLVMOrcJITTargetMachineBuilderDetectHost(
        <corc.LLVMOrcJITTargetMachineBuilderRef*>rocm.llvm._util.Pointer.from_pyobj(Result)._ptr))    # fully specified
    return (_LLVMOrcJITTargetMachineBuilderDetectHost__retval,)


@cython.embedsignature(True)
def LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine(object TM):
    r"""(No short description, might be part of a group.)

    Create a JITTargetMachineBuilder from the given TargetMachine template.

    This operation takes ownership of the given TargetMachine and destroys it
    before returing. The resulting JITTargetMachineBuilder is owned by the client
    and must be passed to a consuming operation (e.g.
    LLVMOrcLLJITBuilderSetJITTargetMachineBuilder) or disposed of by calling
    LLVMOrcDisposeJITTargetMachineBuilder.

    Args:
        TM (`~.LLVMOpaqueTargetMachine`/`~.object`):
            (undocumented)
    """
    _LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine__retval = LLVMOrcJITTargetMachineBuilderRef.from_value(corc.LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine(
        LLVMOpaqueTargetMachine.from_pyobj(TM)._ptr))    # fully specified
    return (_LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine__retval,)


@cython.embedsignature(True)
def LLVMOrcDisposeJITTargetMachineBuilder(object JTMB):
    r"""(No short description, might be part of a group.)

    Dispose of a JITTargetMachineBuilder.

    Args:
        JTMB (`~.LLVMOrcOpaqueJITTargetMachineBuilder`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeJITTargetMachineBuilder(
        LLVMOrcOpaqueJITTargetMachineBuilder.from_pyobj(JTMB)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcJITTargetMachineBuilderGetTargetTriple(object JTMB):
    r"""(No short description, might be part of a group.)

    Returns the target triple for the given JITTargetMachineBuilder as a string.

    The caller owns the resulting string as must dispose of it by calling
    LLVMDisposeMessage

    Args:
        JTMB (`~.LLVMOrcOpaqueJITTargetMachineBuilder`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.bytes`
    """
    cdef char * _LLVMOrcJITTargetMachineBuilderGetTargetTriple__retval = corc.LLVMOrcJITTargetMachineBuilderGetTargetTriple(
        LLVMOrcOpaqueJITTargetMachineBuilder.from_pyobj(JTMB)._ptr)    # fully specified
    return (_LLVMOrcJITTargetMachineBuilderGetTargetTriple__retval,)


@cython.embedsignature(True)
def LLVMOrcJITTargetMachineBuilderSetTargetTriple(object JTMB, const char * TargetTriple):
    r"""(No short description, might be part of a group.)

    Sets the target triple for the given JITTargetMachineBuilder to the given
    string.

    Args:
        JTMB (`~.LLVMOrcOpaqueJITTargetMachineBuilder`/`~.object`):
            (undocumented)

        TargetTriple (`~.bytes`):
            (undocumented)
    """
    corc.LLVMOrcJITTargetMachineBuilderSetTargetTriple(
        LLVMOrcOpaqueJITTargetMachineBuilder.from_pyobj(JTMB)._ptr,TargetTriple)    # fully specified


@cython.embedsignature(True)
def LLVMOrcObjectLayerAddObjectFile(object ObjLayer, object JD, object ObjBuffer):
    r"""(No short description, might be part of a group.)

    Add an object to an ObjectLayer to the given JITDylib.

    Adds a buffer representing an object file to the given JITDylib using the
    given ObjectLayer instance. This operation transfers ownership of the buffer
    to the ObjectLayer instance. The buffer should not be disposed of or
    referenced once this function returns.

    Resources associated with the given object will be tracked by the given
    JITDylib's default ResourceTracker.

    Args:
        ObjLayer (`~.LLVMOrcOpaqueObjectLayer`/`~.object`):
            (undocumented)

        JD (`~.LLVMOrcOpaqueJITDylib`/`~.object`):
            (undocumented)

        ObjBuffer (`~.LLVMOpaqueMemoryBuffer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcObjectLayerAddObjectFile__retval = LLVMErrorRef.from_value(corc.LLVMOrcObjectLayerAddObjectFile(
        LLVMOrcOpaqueObjectLayer.from_pyobj(ObjLayer)._ptr,
        LLVMOrcOpaqueJITDylib.from_pyobj(JD)._ptr,
        LLVMOpaqueMemoryBuffer.from_pyobj(ObjBuffer)._ptr))    # fully specified
    return (_LLVMOrcObjectLayerAddObjectFile__retval,)


@cython.embedsignature(True)
def LLVMOrcObjectLayerAddObjectFileWithRT(object ObjLayer, object RT, object ObjBuffer):
    r"""(No short description, might be part of a group.)

    Add an object to an ObjectLayer using the given ResourceTracker.

    Adds a buffer representing an object file to the given ResourceTracker's
    JITDylib using the given ObjectLayer instance. This operation transfers
    ownership of the buffer to the ObjectLayer instance. The buffer should not
    be disposed of or referenced once this function returns.

    Resources associated with the given object will be tracked by
    ResourceTracker RT.

    Args:
        ObjLayer (`~.LLVMOrcOpaqueObjectLayer`/`~.object`):
            (undocumented)

        RT (`~.LLVMOrcOpaqueResourceTracker`/`~.object`):
            (undocumented)

        ObjBuffer (`~.LLVMOpaqueMemoryBuffer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcObjectLayerAddObjectFileWithRT__retval = LLVMErrorRef.from_value(corc.LLVMOrcObjectLayerAddObjectFileWithRT(
        LLVMOrcOpaqueObjectLayer.from_pyobj(ObjLayer)._ptr,
        LLVMOrcOpaqueResourceTracker.from_pyobj(RT)._ptr,
        LLVMOpaqueMemoryBuffer.from_pyobj(ObjBuffer)._ptr))    # fully specified
    return (_LLVMOrcObjectLayerAddObjectFileWithRT__retval,)


@cython.embedsignature(True)
def LLVMOrcObjectLayerEmit(object ObjLayer, object R, object ObjBuffer):
    r"""(No short description, might be part of a group.)

    Emit an object buffer to an ObjectLayer.

    Ownership of the responsibility object and object buffer pass to this
    function. The client is not responsible for cleanup.

    Args:
        ObjLayer (`~.LLVMOrcOpaqueObjectLayer`/`~.object`):
            (undocumented)

        R (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        ObjBuffer (`~.LLVMOpaqueMemoryBuffer`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcObjectLayerEmit(
        LLVMOrcOpaqueObjectLayer.from_pyobj(ObjLayer)._ptr,
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(R)._ptr,
        LLVMOpaqueMemoryBuffer.from_pyobj(ObjBuffer)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcDisposeObjectLayer(object ObjLayer):
    r"""(No short description, might be part of a group.)

    Dispose of an ObjectLayer.

    Args:
        ObjLayer (`~.LLVMOrcOpaqueObjectLayer`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeObjectLayer(
        LLVMOrcOpaqueObjectLayer.from_pyobj(ObjLayer)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcIRTransformLayerEmit(object IRTransformLayer, object MR, object TSM):
    r"""(No short description, might be part of a group.)

    Args:
        IRTransformLayer (`~.LLVMOrcOpaqueIRTransformLayer`/`~.object`):
            (undocumented)

        MR (`~.LLVMOrcOpaqueMaterializationResponsibility`/`~.object`):
            (undocumented)

        TSM (`~.LLVMOrcOpaqueThreadSafeModule`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcIRTransformLayerEmit(
        LLVMOrcOpaqueIRTransformLayer.from_pyobj(IRTransformLayer)._ptr,
        LLVMOrcOpaqueMaterializationResponsibility.from_pyobj(MR)._ptr,
        LLVMOrcOpaqueThreadSafeModule.from_pyobj(TSM)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcIRTransformLayerSetTransform(object IRTransformLayer, object TransformFunction, object Ctx):
    r"""(No short description, might be part of a group.)

    Set the transform function of the provided transform layer, passing through a
    pointer to user provided context.

    Args:
        IRTransformLayer (`~.LLVMOrcOpaqueIRTransformLayer`/`~.object`):
            (undocumented)

        TransformFunction (`~.LLVMOrcIRTransformLayerTransformFunction`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcIRTransformLayerSetTransform(
        LLVMOrcOpaqueIRTransformLayer.from_pyobj(IRTransformLayer)._ptr,
        LLVMOrcIRTransformLayerTransformFunction.from_pyobj(TransformFunction)._ptr,
        <void *>rocm.llvm._util.Pointer.from_pyobj(Ctx)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcObjectTransformLayerSetTransform(object ObjTransformLayer, object TransformFunction, object Ctx):
    r"""(No short description, might be part of a group.)

    Set the transform function on an LLVMOrcObjectTransformLayer.

    Args:
        ObjTransformLayer (`~.LLVMOrcOpaqueObjectTransformLayer`/`~.object`):
            (undocumented)

        TransformFunction (`~.LLVMOrcObjectTransformLayerTransformFunction`/`~.object`):
            (undocumented)

        Ctx (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcObjectTransformLayerSetTransform(
        LLVMOrcOpaqueObjectTransformLayer.from_pyobj(ObjTransformLayer)._ptr,
        LLVMOrcObjectTransformLayerTransformFunction.from_pyobj(TransformFunction)._ptr,
        <void *>rocm.llvm._util.Pointer.from_pyobj(Ctx)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcCreateLocalIndirectStubsManager(const char * TargetTriple):
    r"""(No short description, might be part of a group.)

    Create a LocalIndirectStubsManager from the given target triple.

    The resulting IndirectStubsManager is owned by the client
    and must be disposed of by calling LLVMOrcDisposeDisposeIndirectStubsManager.

    Args:
        TargetTriple (`~.bytes`):
            (undocumented)
    """
    _LLVMOrcCreateLocalIndirectStubsManager__retval = LLVMOrcIndirectStubsManagerRef.from_value(corc.LLVMOrcCreateLocalIndirectStubsManager(TargetTriple))    # fully specified
    return (_LLVMOrcCreateLocalIndirectStubsManager__retval,)


@cython.embedsignature(True)
def LLVMOrcDisposeIndirectStubsManager(object ISM):
    r"""(No short description, might be part of a group.)

    Dispose of an IndirectStubsManager.

    Args:
        ISM (`~.LLVMOrcOpaqueIndirectStubsManager`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeIndirectStubsManager(
        LLVMOrcOpaqueIndirectStubsManager.from_pyobj(ISM)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcCreateLocalLazyCallThroughManager(const char * TargetTriple, object ES, unsigned long ErrorHandlerAddr, object LCTM):
    r"""(No short description, might be part of a group.)

    Args:
        TargetTriple (`~.bytes`):
            (undocumented)

        ES (`~.LLVMOrcOpaqueExecutionSession`/`~.object`):
            (undocumented)

        ErrorHandlerAddr (`~.int`):
            (undocumented)

        LCTM (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcCreateLocalLazyCallThroughManager__retval = LLVMErrorRef.from_value(corc.LLVMOrcCreateLocalLazyCallThroughManager(TargetTriple,
        LLVMOrcOpaqueExecutionSession.from_pyobj(ES)._ptr,ErrorHandlerAddr,
        <corc.LLVMOrcLazyCallThroughManagerRef*>rocm.llvm._util.Pointer.from_pyobj(LCTM)._ptr))    # fully specified
    return (_LLVMOrcCreateLocalLazyCallThroughManager__retval,)


@cython.embedsignature(True)
def LLVMOrcDisposeLazyCallThroughManager(object LCTM):
    r"""(No short description, might be part of a group.)

    Dispose of an LazyCallThroughManager.

    Args:
        LCTM (`~.LLVMOrcOpaqueLazyCallThroughManager`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeLazyCallThroughManager(
        LLVMOrcOpaqueLazyCallThroughManager.from_pyobj(LCTM)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcCreateDumpObjects(const char * DumpDir, const char * IdentifierOverride):
    r"""(No short description, might be part of a group.)

    Create a DumpObjects instance.

    DumpDir specifies the path to write dumped objects to. DumpDir may be empty
    in which case files will be dumped to the working directory.

    IdentifierOverride specifies a file name stem to use when dumping objects.
    If empty then each MemoryBuffer's identifier will be used (with a .o suffix
    added if not already present). If an identifier override is supplied it will
    be used instead, along with an incrementing counter (since all buffers will
    use the same identifier, the resulting files will be named <ident>.o,
    <ident>.2.o, <ident>.3.o, and so on). IdentifierOverride should not contain
    an extension, as a .o suffix will be added by DumpObjects.

    Args:
        DumpDir (`~.bytes`):
            (undocumented)

        IdentifierOverride (`~.bytes`):
            (undocumented)
    """
    _LLVMOrcCreateDumpObjects__retval = LLVMOrcDumpObjectsRef.from_value(corc.LLVMOrcCreateDumpObjects(DumpDir,IdentifierOverride))    # fully specified
    return (_LLVMOrcCreateDumpObjects__retval,)


@cython.embedsignature(True)
def LLVMOrcDisposeDumpObjects(object DumpObjects):
    r"""(No short description, might be part of a group.)

    Dispose of a DumpObjects instance.

    Args:
        DumpObjects (`~.LLVMOrcOpaqueDumpObjects`/`~.object`):
            (undocumented)
    """
    corc.LLVMOrcDisposeDumpObjects(
        LLVMOrcOpaqueDumpObjects.from_pyobj(DumpObjects)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMOrcDumpObjects_CallOperator(object DumpObjects, object ObjBuffer):
    r"""(No short description, might be part of a group.)

    Dump the contents of the given MemoryBuffer.

    Args:
        DumpObjects (`~.LLVMOrcOpaqueDumpObjects`/`~.object`):
            (undocumented)

        ObjBuffer (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMOrcDumpObjects_CallOperator__retval = LLVMErrorRef.from_value(corc.LLVMOrcDumpObjects_CallOperator(
        LLVMOrcOpaqueDumpObjects.from_pyobj(DumpObjects)._ptr,
        <corc.LLVMMemoryBufferRef*>rocm.llvm._util.Pointer.from_pyobj(ObjBuffer)._ptr))    # fully specified
    return (_LLVMOrcDumpObjects_CallOperator__retval,)

__all__ = [
    "_LLVMJITSymbolGenericFlags__Base",
    "LLVMJITSymbolGenericFlags",
    "LLVMJITSymbolFlags",
    "LLVMJITEvaluatedSymbol",
    "LLVMOrcOpaqueExecutionSession",
    "LLVMOrcExecutionSessionRef",
    "LLVMOrcErrorReporterFunction",
    "LLVMOrcOpaqueSymbolStringPool",
    "LLVMOrcSymbolStringPoolRef",
    "LLVMOrcOpaqueSymbolStringPoolEntry",
    "LLVMOrcSymbolStringPoolEntryRef",
    "LLVMOrcCSymbolFlagsMapPair",
    "LLVMOrcCSymbolFlagsMapPairs",
    "LLVMOrcCSymbolMapPair",
    "LLVMOrcCSymbolMapPairs",
    "LLVMOrcCSymbolAliasMapEntry",
    "LLVMOrcCSymbolAliasMapPair",
    "LLVMOrcCSymbolAliasMapPairs",
    "LLVMOrcOpaqueJITDylib",
    "LLVMOrcJITDylibRef",
    "LLVMOrcCSymbolsList",
    "LLVMOrcCDependenceMapPair",
    "LLVMOrcCDependenceMapPairs",
    "_LLVMOrcLookupKind__Base",
    "LLVMOrcLookupKind",
    "_LLVMOrcJITDylibLookupFlags__Base",
    "LLVMOrcJITDylibLookupFlags",
    "LLVMOrcCJITDylibSearchOrderElement",
    "LLVMOrcCJITDylibSearchOrder",
    "_LLVMOrcSymbolLookupFlags__Base",
    "LLVMOrcSymbolLookupFlags",
    "LLVMOrcCLookupSetElement",
    "LLVMOrcCLookupSet",
    "LLVMOrcOpaqueMaterializationUnit",
    "LLVMOrcMaterializationUnitRef",
    "LLVMOrcOpaqueMaterializationResponsibility",
    "LLVMOrcMaterializationResponsibilityRef",
    "LLVMOrcMaterializationUnitMaterializeFunction",
    "LLVMOrcMaterializationUnitDiscardFunction",
    "LLVMOrcMaterializationUnitDestroyFunction",
    "LLVMOrcOpaqueResourceTracker",
    "LLVMOrcResourceTrackerRef",
    "LLVMOrcOpaqueDefinitionGenerator",
    "LLVMOrcDefinitionGeneratorRef",
    "LLVMOrcOpaqueLookupState",
    "LLVMOrcLookupStateRef",
    "LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction",
    "LLVMOrcDisposeCAPIDefinitionGeneratorFunction",
    "LLVMOrcSymbolPredicate",
    "LLVMOrcOpaqueThreadSafeContext",
    "LLVMOrcThreadSafeContextRef",
    "LLVMOrcOpaqueThreadSafeModule",
    "LLVMOrcThreadSafeModuleRef",
    "LLVMOrcGenericIRModuleOperationFunction",
    "LLVMOrcOpaqueJITTargetMachineBuilder",
    "LLVMOrcJITTargetMachineBuilderRef",
    "LLVMOrcOpaqueObjectLayer",
    "LLVMOrcObjectLayerRef",
    "LLVMOrcOpaqueObjectLinkingLayer",
    "LLVMOrcObjectLinkingLayerRef",
    "LLVMOrcOpaqueIRTransformLayer",
    "LLVMOrcIRTransformLayerRef",
    "LLVMOrcIRTransformLayerTransformFunction",
    "LLVMOrcOpaqueObjectTransformLayer",
    "LLVMOrcObjectTransformLayerRef",
    "LLVMOrcObjectTransformLayerTransformFunction",
    "LLVMOrcOpaqueIndirectStubsManager",
    "LLVMOrcIndirectStubsManagerRef",
    "LLVMOrcOpaqueLazyCallThroughManager",
    "LLVMOrcLazyCallThroughManagerRef",
    "LLVMOrcOpaqueDumpObjects",
    "LLVMOrcDumpObjectsRef",
    "LLVMOrcExecutionSessionSetErrorReporter",
    "LLVMOrcExecutionSessionGetSymbolStringPool",
    "LLVMOrcSymbolStringPoolClearDeadEntries",
    "LLVMOrcExecutionSessionIntern",
    "LLVMOrcExecutionSessionLookupHandleResultFunction",
    "LLVMOrcExecutionSessionLookup",
    "LLVMOrcRetainSymbolStringPoolEntry",
    "LLVMOrcReleaseSymbolStringPoolEntry",
    "LLVMOrcSymbolStringPoolEntryStr",
    "LLVMOrcReleaseResourceTracker",
    "LLVMOrcResourceTrackerTransferTo",
    "LLVMOrcResourceTrackerRemove",
    "LLVMOrcDisposeDefinitionGenerator",
    "LLVMOrcDisposeMaterializationUnit",
    "LLVMOrcCreateCustomMaterializationUnit",
    "LLVMOrcAbsoluteSymbols",
    "LLVMOrcLazyReexports",
    "LLVMOrcDisposeMaterializationResponsibility",
    "LLVMOrcMaterializationResponsibilityGetTargetDylib",
    "LLVMOrcMaterializationResponsibilityGetExecutionSession",
    "LLVMOrcMaterializationResponsibilityGetSymbols",
    "LLVMOrcDisposeCSymbolFlagsMap",
    "LLVMOrcMaterializationResponsibilityGetInitializerSymbol",
    "LLVMOrcMaterializationResponsibilityGetRequestedSymbols",
    "LLVMOrcDisposeSymbols",
    "LLVMOrcMaterializationResponsibilityNotifyResolved",
    "LLVMOrcMaterializationResponsibilityNotifyEmitted",
    "LLVMOrcMaterializationResponsibilityDefineMaterializing",
    "LLVMOrcMaterializationResponsibilityFailMaterialization",
    "LLVMOrcMaterializationResponsibilityReplace",
    "LLVMOrcMaterializationResponsibilityDelegate",
    "LLVMOrcMaterializationResponsibilityAddDependencies",
    "LLVMOrcMaterializationResponsibilityAddDependenciesForAll",
    "LLVMOrcExecutionSessionCreateBareJITDylib",
    "LLVMOrcExecutionSessionCreateJITDylib",
    "LLVMOrcExecutionSessionGetJITDylibByName",
    "LLVMOrcJITDylibCreateResourceTracker",
    "LLVMOrcJITDylibGetDefaultResourceTracker",
    "LLVMOrcJITDylibDefine",
    "LLVMOrcJITDylibClear",
    "LLVMOrcJITDylibAddGenerator",
    "LLVMOrcCreateCustomCAPIDefinitionGenerator",
    "LLVMOrcLookupStateContinueLookup",
    "LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess",
    "LLVMOrcCreateDynamicLibrarySearchGeneratorForPath",
    "LLVMOrcCreateStaticLibrarySearchGeneratorForPath",
    "LLVMOrcCreateNewThreadSafeContext",
    "LLVMOrcThreadSafeContextGetContext",
    "LLVMOrcDisposeThreadSafeContext",
    "LLVMOrcCreateNewThreadSafeModule",
    "LLVMOrcDisposeThreadSafeModule",
    "LLVMOrcThreadSafeModuleWithModuleDo",
    "LLVMOrcJITTargetMachineBuilderDetectHost",
    "LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine",
    "LLVMOrcDisposeJITTargetMachineBuilder",
    "LLVMOrcJITTargetMachineBuilderGetTargetTriple",
    "LLVMOrcJITTargetMachineBuilderSetTargetTriple",
    "LLVMOrcObjectLayerAddObjectFile",
    "LLVMOrcObjectLayerAddObjectFileWithRT",
    "LLVMOrcObjectLayerEmit",
    "LLVMOrcDisposeObjectLayer",
    "LLVMOrcIRTransformLayerEmit",
    "LLVMOrcIRTransformLayerSetTransform",
    "LLVMOrcObjectTransformLayerSetTransform",
    "LLVMOrcCreateLocalIndirectStubsManager",
    "LLVMOrcDisposeIndirectStubsManager",
    "LLVMOrcCreateLocalLazyCallThroughManager",
    "LLVMOrcDisposeLazyCallThroughManager",
    "LLVMOrcCreateDumpObjects",
    "LLVMOrcDisposeDumpObjects",
    "LLVMOrcDumpObjects_CallOperator",
]