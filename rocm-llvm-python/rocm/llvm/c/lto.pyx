# MIT License
#
# Copyright (c) 2021-2025 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    lto_module_t:
        alias of `~.LLVMOpaqueLTOModule`

    lto_code_gen_t:
        alias of `~.LLVMOpaqueLTOCodeGenerator`

    thinlto_code_gen_t:
        alias of `~.LLVMOpaqueThinLTOCodeGenerator`

    lto_input_t:
        alias of `~.LLVMOpaqueLTOInput`

"""

import cython
import ctypes
import enum
class _lto_symbol_attributes__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class lto_symbol_attributes(_lto_symbol_attributes__Base):
    """

    Attributes:
        LTO_SYMBOL_ALIGNMENT_MASK:
            (undocumented)
        LTO_SYMBOL_PERMISSIONS_MASK:
            (undocumented)
        LTO_SYMBOL_PERMISSIONS_CODE:
            (undocumented)
        LTO_SYMBOL_PERMISSIONS_DATA:
            (undocumented)
        LTO_SYMBOL_PERMISSIONS_RODATA:
            (undocumented)
        LTO_SYMBOL_DEFINITION_MASK:
            (undocumented)
        LTO_SYMBOL_DEFINITION_REGULAR:
            (undocumented)
        LTO_SYMBOL_DEFINITION_TENTATIVE:
            (undocumented)
        LTO_SYMBOL_DEFINITION_WEAK:
            (undocumented)
        LTO_SYMBOL_DEFINITION_UNDEFINED:
            (undocumented)
        LTO_SYMBOL_DEFINITION_WEAKUNDEF:
            (undocumented)
        LTO_SYMBOL_SCOPE_MASK:
            (undocumented)
        LTO_SYMBOL_SCOPE_INTERNAL:
            (undocumented)
        LTO_SYMBOL_SCOPE_HIDDEN:
            (undocumented)
        LTO_SYMBOL_SCOPE_PROTECTED:
            (undocumented)
        LTO_SYMBOL_SCOPE_DEFAULT:
            (undocumented)
        LTO_SYMBOL_SCOPE_DEFAULT_CAN_BE_HIDDEN:
            (undocumented)
        LTO_SYMBOL_COMDAT:
            (undocumented)
        LTO_SYMBOL_ALIAS:
            (undocumented)
    """
    LTO_SYMBOL_ALIGNMENT_MASK = clto.LTO_SYMBOL_ALIGNMENT_MASK
    LTO_SYMBOL_PERMISSIONS_MASK = clto.LTO_SYMBOL_PERMISSIONS_MASK
    LTO_SYMBOL_PERMISSIONS_CODE = clto.LTO_SYMBOL_PERMISSIONS_CODE
    LTO_SYMBOL_PERMISSIONS_DATA = clto.LTO_SYMBOL_PERMISSIONS_DATA
    LTO_SYMBOL_PERMISSIONS_RODATA = clto.LTO_SYMBOL_PERMISSIONS_RODATA
    LTO_SYMBOL_DEFINITION_MASK = clto.LTO_SYMBOL_DEFINITION_MASK
    LTO_SYMBOL_DEFINITION_REGULAR = clto.LTO_SYMBOL_DEFINITION_REGULAR
    LTO_SYMBOL_DEFINITION_TENTATIVE = clto.LTO_SYMBOL_DEFINITION_TENTATIVE
    LTO_SYMBOL_DEFINITION_WEAK = clto.LTO_SYMBOL_DEFINITION_WEAK
    LTO_SYMBOL_DEFINITION_UNDEFINED = clto.LTO_SYMBOL_DEFINITION_UNDEFINED
    LTO_SYMBOL_DEFINITION_WEAKUNDEF = clto.LTO_SYMBOL_DEFINITION_WEAKUNDEF
    LTO_SYMBOL_SCOPE_MASK = clto.LTO_SYMBOL_SCOPE_MASK
    LTO_SYMBOL_SCOPE_INTERNAL = clto.LTO_SYMBOL_SCOPE_INTERNAL
    LTO_SYMBOL_SCOPE_HIDDEN = clto.LTO_SYMBOL_SCOPE_HIDDEN
    LTO_SYMBOL_SCOPE_PROTECTED = clto.LTO_SYMBOL_SCOPE_PROTECTED
    LTO_SYMBOL_SCOPE_DEFAULT = clto.LTO_SYMBOL_SCOPE_DEFAULT
    LTO_SYMBOL_SCOPE_DEFAULT_CAN_BE_HIDDEN = clto.LTO_SYMBOL_SCOPE_DEFAULT_CAN_BE_HIDDEN
    LTO_SYMBOL_COMDAT = clto.LTO_SYMBOL_COMDAT
    LTO_SYMBOL_ALIAS = clto.LTO_SYMBOL_ALIAS
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _lto_debug_model__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class lto_debug_model(_lto_debug_model__Base):
    """

    Attributes:
        LTO_DEBUG_MODEL_NONE:
            (undocumented)
        LTO_DEBUG_MODEL_DWARF:
            (undocumented)
    """
    LTO_DEBUG_MODEL_NONE = clto.LTO_DEBUG_MODEL_NONE
    LTO_DEBUG_MODEL_DWARF = clto.LTO_DEBUG_MODEL_DWARF
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _lto_codegen_model__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class lto_codegen_model(_lto_codegen_model__Base):
    """

    Attributes:
        LTO_CODEGEN_PIC_MODEL_STATIC:
            (undocumented)
        LTO_CODEGEN_PIC_MODEL_DYNAMIC:
            (undocumented)
        LTO_CODEGEN_PIC_MODEL_DYNAMIC_NO_PIC:
            (undocumented)
        LTO_CODEGEN_PIC_MODEL_DEFAULT:
            (undocumented)
    """
    LTO_CODEGEN_PIC_MODEL_STATIC = clto.LTO_CODEGEN_PIC_MODEL_STATIC
    LTO_CODEGEN_PIC_MODEL_DYNAMIC = clto.LTO_CODEGEN_PIC_MODEL_DYNAMIC
    LTO_CODEGEN_PIC_MODEL_DYNAMIC_NO_PIC = clto.LTO_CODEGEN_PIC_MODEL_DYNAMIC_NO_PIC
    LTO_CODEGEN_PIC_MODEL_DEFAULT = clto.LTO_CODEGEN_PIC_MODEL_DEFAULT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class LLVMOpaqueLTOModule(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class clto.LLVMOpaqueLTOModule.

    Python wrapper for cdef class clto.LLVMOpaqueLTOModule.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef clto.LLVMOpaqueLTOModule* getElementPtr(self):
        return <clto.LLVMOpaqueLTOModule*>self._ptr

    @staticmethod
    cdef LLVMOpaqueLTOModule fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueLTOModule`` objects from
        given ``clto.LLVMOpaqueLTOModule`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueLTOModule wrapper = LLVMOpaqueLTOModule.__new__(LLVMOpaqueLTOModule)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueLTOModule from a Python object.

        Derives a LLVMOpaqueLTOModule from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueLTOModule`` reference, this method
        returns it directly. No new ``LLVMOpaqueLTOModule`` is created in this case.
        """
        return LLVMOpaqueLTOModule.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueLTOModule fromPyobj(object pyobj):
        """Creates a LLVMOpaqueLTOModule from a Python object.

        Derives a LLVMOpaqueLTOModule from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueLTOModule`` reference, this method
        returns it directly. No new ``LLVMOpaqueLTOModule`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueLTOModule`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueLTOModule!
        """
        cdef LLVMOpaqueLTOModule wrapper

        if isinstance(pyobj,LLVMOpaqueLTOModule):
            return pyobj
        else:
            wrapper = LLVMOpaqueLTOModule.__new__(LLVMOpaqueLTOModule)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueLTOModule object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


lto_module_t = LLVMOpaqueLTOModule

cdef class LLVMOpaqueLTOCodeGenerator(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class clto.LLVMOpaqueLTOCodeGenerator.

    Python wrapper for cdef class clto.LLVMOpaqueLTOCodeGenerator.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef clto.LLVMOpaqueLTOCodeGenerator* getElementPtr(self):
        return <clto.LLVMOpaqueLTOCodeGenerator*>self._ptr

    @staticmethod
    cdef LLVMOpaqueLTOCodeGenerator fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueLTOCodeGenerator`` objects from
        given ``clto.LLVMOpaqueLTOCodeGenerator`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueLTOCodeGenerator wrapper = LLVMOpaqueLTOCodeGenerator.__new__(LLVMOpaqueLTOCodeGenerator)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueLTOCodeGenerator from a Python object.

        Derives a LLVMOpaqueLTOCodeGenerator from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueLTOCodeGenerator`` reference, this method
        returns it directly. No new ``LLVMOpaqueLTOCodeGenerator`` is created in this case.
        """
        return LLVMOpaqueLTOCodeGenerator.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueLTOCodeGenerator fromPyobj(object pyobj):
        """Creates a LLVMOpaqueLTOCodeGenerator from a Python object.

        Derives a LLVMOpaqueLTOCodeGenerator from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueLTOCodeGenerator`` reference, this method
        returns it directly. No new ``LLVMOpaqueLTOCodeGenerator`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueLTOCodeGenerator`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueLTOCodeGenerator!
        """
        cdef LLVMOpaqueLTOCodeGenerator wrapper

        if isinstance(pyobj,LLVMOpaqueLTOCodeGenerator):
            return pyobj
        else:
            wrapper = LLVMOpaqueLTOCodeGenerator.__new__(LLVMOpaqueLTOCodeGenerator)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueLTOCodeGenerator object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


lto_code_gen_t = LLVMOpaqueLTOCodeGenerator

cdef class LLVMOpaqueThinLTOCodeGenerator(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class clto.LLVMOpaqueThinLTOCodeGenerator.

    Python wrapper for cdef class clto.LLVMOpaqueThinLTOCodeGenerator.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef clto.LLVMOpaqueThinLTOCodeGenerator* getElementPtr(self):
        return <clto.LLVMOpaqueThinLTOCodeGenerator*>self._ptr

    @staticmethod
    cdef LLVMOpaqueThinLTOCodeGenerator fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueThinLTOCodeGenerator`` objects from
        given ``clto.LLVMOpaqueThinLTOCodeGenerator`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueThinLTOCodeGenerator wrapper = LLVMOpaqueThinLTOCodeGenerator.__new__(LLVMOpaqueThinLTOCodeGenerator)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueThinLTOCodeGenerator from a Python object.

        Derives a LLVMOpaqueThinLTOCodeGenerator from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueThinLTOCodeGenerator`` reference, this method
        returns it directly. No new ``LLVMOpaqueThinLTOCodeGenerator`` is created in this case.
        """
        return LLVMOpaqueThinLTOCodeGenerator.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueThinLTOCodeGenerator fromPyobj(object pyobj):
        """Creates a LLVMOpaqueThinLTOCodeGenerator from a Python object.

        Derives a LLVMOpaqueThinLTOCodeGenerator from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueThinLTOCodeGenerator`` reference, this method
        returns it directly. No new ``LLVMOpaqueThinLTOCodeGenerator`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueThinLTOCodeGenerator`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueThinLTOCodeGenerator!
        """
        cdef LLVMOpaqueThinLTOCodeGenerator wrapper

        if isinstance(pyobj,LLVMOpaqueThinLTOCodeGenerator):
            return pyobj
        else:
            wrapper = LLVMOpaqueThinLTOCodeGenerator.__new__(LLVMOpaqueThinLTOCodeGenerator)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueThinLTOCodeGenerator object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


thinlto_code_gen_t = LLVMOpaqueThinLTOCodeGenerator

@cython.embedsignature(True)
def lto_get_version():
    r"""(No short description, might be part of a group.)

    Returns a printable string.

    Since:
        prior to LTO_API_VERSION=3
    """
    _lto_get_version__retval = rocm.llvm._util.types.CStr.fromPtr(<void*>clto.lto_get_version())
    return None if _lto_get_version__retval._ptr == NULL else _lto_get_version__retval


@cython.embedsignature(True)
def lto_get_error_message():
    r"""(No short description, might be part of a group.)

    Returns the last error string or NULL if last operation was successful.

    Since:
        prior to LTO_API_VERSION=3
    """
    _lto_get_error_message__retval = rocm.llvm._util.types.CStr.fromPtr(<void*>clto.lto_get_error_message())
    return None if _lto_get_error_message__retval._ptr == NULL else _lto_get_error_message__retval


@cython.embedsignature(True)
def lto_module_is_object_file(object path):
    r"""(No short description, might be part of a group.)

    Checks if a file is a loadable object file.

    Since:
        prior to LTO_API_VERSION=3

    Args:
        path (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    cdef _Bool _lto_module_is_object_file__retval = clto.lto_module_is_object_file(
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr)
    return _lto_module_is_object_file__retval


@cython.embedsignature(True)
def lto_module_is_object_file_for_target(object path, object target_triple_prefix):
    r"""(No short description, might be part of a group.)

    Checks if a file is a loadable object compiled for requested target.

    Since:
        prior to LTO_API_VERSION=3

    Args:
        path (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        target_triple_prefix (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    cdef _Bool _lto_module_is_object_file_for_target__retval = clto.lto_module_is_object_file_for_target(
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(target_triple_prefix)._ptr)
    return _lto_module_is_object_file_for_target__retval


@cython.embedsignature(True)
def lto_module_has_objc_category(object mem, unsigned long length):
    r"""(No short description, might be part of a group.)

    Return true if ``Buffer`` contains a bitcode file with ObjC code (category
    or class) in it.

    Since:
        LTO_API_VERSION=20

    Args:
        mem (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        length (`~.int`):
            (undocumented)
    """
    cdef _Bool _lto_module_has_objc_category__retval = clto.lto_module_has_objc_category(
        <const void *>rocm.llvm._util.types.Pointer.fromPyobj(mem)._ptr,length)
    return _lto_module_has_objc_category__retval


@cython.embedsignature(True)
def lto_module_is_object_file_in_memory(object mem, unsigned long length):
    r"""(No short description, might be part of a group.)

    Checks if a buffer is a loadable object file.

    Since:
        prior to LTO_API_VERSION=3

    Args:
        mem (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        length (`~.int`):
            (undocumented)
    """
    cdef _Bool _lto_module_is_object_file_in_memory__retval = clto.lto_module_is_object_file_in_memory(
        <const void *>rocm.llvm._util.types.Pointer.fromPyobj(mem)._ptr,length)
    return _lto_module_is_object_file_in_memory__retval


@cython.embedsignature(True)
def lto_module_is_object_file_in_memory_for_target(object mem, unsigned long length, object target_triple_prefix):
    r"""(No short description, might be part of a group.)

    Checks if a buffer is a loadable object compiled for requested target.

    Since:
        prior to LTO_API_VERSION=3

    Args:
        mem (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        length (`~.int`):
            (undocumented)

        target_triple_prefix (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    cdef _Bool _lto_module_is_object_file_in_memory_for_target__retval = clto.lto_module_is_object_file_in_memory_for_target(
        <const void *>rocm.llvm._util.types.Pointer.fromPyobj(mem)._ptr,length,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(target_triple_prefix)._ptr)
    return _lto_module_is_object_file_in_memory_for_target__retval


@cython.embedsignature(True)
def lto_module_create(object path):
    r"""(No short description, might be part of a group.)

    Loads an object file from disk.
    Returns NULL on error (check lto_get_error_message() for details).

    Since:
        prior to LTO_API_VERSION=3

    Args:
        path (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    _lto_module_create__retval = LLVMOpaqueLTOModule.fromPtr(clto.lto_module_create(
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr))
    return None if _lto_module_create__retval._ptr == NULL else _lto_module_create__retval


@cython.embedsignature(True)
def lto_module_create_from_memory(object mem, unsigned long length):
    r"""(No short description, might be part of a group.)

    Loads an object file from memory.
    Returns NULL on error (check lto_get_error_message() for details).

    Since:
        prior to LTO_API_VERSION=3

    Args:
        mem (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        length (`~.int`):
            (undocumented)
    """
    _lto_module_create_from_memory__retval = LLVMOpaqueLTOModule.fromPtr(clto.lto_module_create_from_memory(
        <const void *>rocm.llvm._util.types.Pointer.fromPyobj(mem)._ptr,length))
    return None if _lto_module_create_from_memory__retval._ptr == NULL else _lto_module_create_from_memory__retval


@cython.embedsignature(True)
def lto_module_create_from_memory_with_path(object mem, unsigned long length, object path):
    r"""(No short description, might be part of a group.)

    Loads an object file from memory with an extra path argument.
    Returns NULL on error (check lto_get_error_message() for details).

    Since:
        LTO_API_VERSION=9

    Args:
        mem (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        length (`~.int`):
            (undocumented)

        path (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    _lto_module_create_from_memory_with_path__retval = LLVMOpaqueLTOModule.fromPtr(clto.lto_module_create_from_memory_with_path(
        <const void *>rocm.llvm._util.types.Pointer.fromPyobj(mem)._ptr,length,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr))
    return None if _lto_module_create_from_memory_with_path__retval._ptr == NULL else _lto_module_create_from_memory_with_path__retval


@cython.embedsignature(True)
def lto_module_create_in_local_context(object mem, unsigned long length, object path):
    r"""(No short description, might be part of a group.)

    Loads an object file in its own context.

    Loads an object file in its own LLVMContext.  This function call is
    thread-safe.  However, modules created this way should not be merged into an
    lto_code_gen_t using *lto_codegen_add_module().*

    Returns NULL on error (check lto_get_error_message() for details).

    Since:
        LTO_API_VERSION=11

    Args:
        mem (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        length (`~.int`):
            (undocumented)

        path (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    _lto_module_create_in_local_context__retval = LLVMOpaqueLTOModule.fromPtr(clto.lto_module_create_in_local_context(
        <const void *>rocm.llvm._util.types.Pointer.fromPyobj(mem)._ptr,length,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr))
    return None if _lto_module_create_in_local_context__retval._ptr == NULL else _lto_module_create_in_local_context__retval


@cython.embedsignature(True)
def lto_module_create_in_codegen_context(object mem, unsigned long length, object path, object cg):
    r"""(No short description, might be part of a group.)

    Loads an object file in the codegen context.

    Loads an object file into the same context as ``cg.``  The module is safe to
    add using *lto_codegen_add_module().*

    Returns NULL on error (check lto_get_error_message() for details).

    Since:
        LTO_API_VERSION=11

    Args:
        mem (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        length (`~.int`):
            (undocumented)

        path (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)
    """
    _lto_module_create_in_codegen_context__retval = LLVMOpaqueLTOModule.fromPtr(clto.lto_module_create_in_codegen_context(
        <const void *>rocm.llvm._util.types.Pointer.fromPyobj(mem)._ptr,length,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr,
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr()))
    return None if _lto_module_create_in_codegen_context__retval._ptr == NULL else _lto_module_create_in_codegen_context__retval


@cython.embedsignature(True)
def lto_module_create_from_fd(int fd, object path, unsigned long file_size):
    r"""(No short description, might be part of a group.)

    Loads an object file from disk. The seek point of fd is not preserved.
    Returns NULL on error (check lto_get_error_message() for details).

    Since:
        LTO_API_VERSION=5

    Args:
        fd (`~.int`):
            (undocumented)

        path (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        file_size (`~.int`):
            (undocumented)
    """
    _lto_module_create_from_fd__retval = LLVMOpaqueLTOModule.fromPtr(clto.lto_module_create_from_fd(fd,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr,file_size))
    return None if _lto_module_create_from_fd__retval._ptr == NULL else _lto_module_create_from_fd__retval


@cython.embedsignature(True)
def lto_module_create_from_fd_at_offset(int fd, object path, unsigned long file_size, unsigned long map_size, long offset):
    r"""(No short description, might be part of a group.)

    Loads an object file from disk. The seek point of fd is not preserved.
    Returns NULL on error (check lto_get_error_message() for details).

    Since:
        LTO_API_VERSION=5

    Args:
        fd (`~.int`):
            (undocumented)

        path (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        file_size (`~.int`):
            (undocumented)

        map_size (`~.int`):
            (undocumented)

        offset (`~.int`):
            (undocumented)
    """
    _lto_module_create_from_fd_at_offset__retval = LLVMOpaqueLTOModule.fromPtr(clto.lto_module_create_from_fd_at_offset(fd,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr,file_size,map_size,offset))
    return None if _lto_module_create_from_fd_at_offset__retval._ptr == NULL else _lto_module_create_from_fd_at_offset__retval


@cython.embedsignature(True)
def lto_module_dispose(object mod):
    r"""(No short description, might be part of a group.)

    Frees all memory internally allocated by the module.
    Upon return the lto_module_t is no longer valid.

    Since:
        prior to LTO_API_VERSION=3

    Args:
        mod (`~.LLVMOpaqueLTOModule`/`~.object`):
            (undocumented)
    """
    clto.lto_module_dispose(
        LLVMOpaqueLTOModule.fromPyobj(mod).getElementPtr())


@cython.embedsignature(True)
def lto_module_get_target_triple(object mod):
    r"""(No short description, might be part of a group.)

    Returns triple string which the object module was compiled under.

    Since:
        prior to LTO_API_VERSION=3

    Args:
        mod (`~.LLVMOpaqueLTOModule`/`~.object`):
            (undocumented)
    """
    _lto_module_get_target_triple__retval = rocm.llvm._util.types.CStr.fromPtr(<void*>clto.lto_module_get_target_triple(
        LLVMOpaqueLTOModule.fromPyobj(mod).getElementPtr()))
    return None if _lto_module_get_target_triple__retval._ptr == NULL else _lto_module_get_target_triple__retval


@cython.embedsignature(True)
def lto_module_set_target_triple(object mod, object triple):
    r"""(No short description, might be part of a group.)

    Sets triple string with which the object will be codegened.

    Since:
        LTO_API_VERSION=4

    Args:
        mod (`~.LLVMOpaqueLTOModule`/`~.object`):
            (undocumented)

        triple (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    clto.lto_module_set_target_triple(
        LLVMOpaqueLTOModule.fromPyobj(mod).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(triple)._ptr)


@cython.embedsignature(True)
def lto_module_get_num_symbols(object mod):
    r"""(No short description, might be part of a group.)

    Returns the number of symbols in the object module.

    Since:
        prior to LTO_API_VERSION=3

    Args:
        mod (`~.LLVMOpaqueLTOModule`/`~.object`):
            (undocumented)
    """
    cdef unsigned int _lto_module_get_num_symbols__retval = clto.lto_module_get_num_symbols(
        LLVMOpaqueLTOModule.fromPyobj(mod).getElementPtr())
    return _lto_module_get_num_symbols__retval


@cython.embedsignature(True)
def lto_module_get_symbol_name(object mod, unsigned int index):
    r"""(No short description, might be part of a group.)

    Returns the name of the ith symbol in the object module.

    Since:
        prior to LTO_API_VERSION=3

    Args:
        mod (`~.LLVMOpaqueLTOModule`/`~.object`):
            (undocumented)

        index (`~.int`):
            (undocumented)
    """
    _lto_module_get_symbol_name__retval = rocm.llvm._util.types.CStr.fromPtr(<void*>clto.lto_module_get_symbol_name(
        LLVMOpaqueLTOModule.fromPyobj(mod).getElementPtr(),index))
    return None if _lto_module_get_symbol_name__retval._ptr == NULL else _lto_module_get_symbol_name__retval


@cython.embedsignature(True)
def lto_module_get_symbol_attribute(object mod, unsigned int index):
    r"""(No short description, might be part of a group.)

    Returns the attributes of the ith symbol in the object module.

    Since:
        prior to LTO_API_VERSION=3

    Args:
        mod (`~.LLVMOpaqueLTOModule`/`~.object`):
            (undocumented)

        index (`~.int`):
            (undocumented)
    """
    _lto_module_get_symbol_attribute__retval = lto_symbol_attributes(clto.lto_module_get_symbol_attribute(
        LLVMOpaqueLTOModule.fromPyobj(mod).getElementPtr(),index))
    return _lto_module_get_symbol_attribute__retval


@cython.embedsignature(True)
def lto_module_get_linkeropts(object mod):
    r"""(No short description, might be part of a group.)

    Returns the module's linker options.

    The linker options may consist of multiple flags. It is the linker's
    responsibility to split the flags using a platform-specific mechanism.

    Since:
        LTO_API_VERSION=16

    Args:
        mod (`~.LLVMOpaqueLTOModule`/`~.object`):
            (undocumented)
    """
    _lto_module_get_linkeropts__retval = rocm.llvm._util.types.CStr.fromPtr(<void*>clto.lto_module_get_linkeropts(
        LLVMOpaqueLTOModule.fromPyobj(mod).getElementPtr()))
    return None if _lto_module_get_linkeropts__retval._ptr == NULL else _lto_module_get_linkeropts__retval


@cython.embedsignature(True)
def lto_module_get_macho_cputype(object mod, object out_cputype, object out_cpusubtype):
    r"""(No short description, might be part of a group.)

    If targeting mach-o on darwin, this function gets the CPU type and subtype
    that will end up being encoded in the mach-o header. These are the values
    that can be found in mach/machine.h.

    ``out_cputype`` and ``out_cpusubtype`` must be non-NULL.

    Returns true on error (check lto_get_error_message() for details).

    Since:
        LTO_API_VERSION=27

    Args:
        mod (`~.LLVMOpaqueLTOModule`/`~.object`):
            (undocumented)

        out_cputype (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        out_cpusubtype (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    cdef _Bool _lto_module_get_macho_cputype__retval = clto.lto_module_get_macho_cputype(
        LLVMOpaqueLTOModule.fromPyobj(mod).getElementPtr(),
        <unsigned int *>rocm.llvm._util.types.Pointer.fromPyobj(out_cputype)._ptr,
        <unsigned int *>rocm.llvm._util.types.Pointer.fromPyobj(out_cpusubtype)._ptr)
    return _lto_module_get_macho_cputype__retval


@cython.embedsignature(True)
def lto_module_has_ctor_dtor(object mod):
    r"""(No short description, might be part of a group.)

    This function can be used by the linker to check if a given module has
    any constructor or destructor functions.

    Returns true if the module has either the @llvm.global_ctors or the
    @llvm.global_dtors symbol. Otherwise returns false.

    Since:
        LTO_API_VERSION=29

    Args:
        mod (`~.LLVMOpaqueLTOModule`/`~.object`):
            (undocumented)
    """
    cdef _Bool _lto_module_has_ctor_dtor__retval = clto.lto_module_has_ctor_dtor(
        LLVMOpaqueLTOModule.fromPyobj(mod).getElementPtr())
    return _lto_module_has_ctor_dtor__retval


class _lto_codegen_diagnostic_severity_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class lto_codegen_diagnostic_severity_t(_lto_codegen_diagnostic_severity_t__Base):
    """Diagnostic severity.

    Attributes:
        LTO_DS_ERROR:
            (undocumented)
        LTO_DS_WARNING:
            (undocumented)
        LTO_DS_REMARK:
            (undocumented)
        LTO_DS_NOTE:
            (undocumented)
    """
    LTO_DS_ERROR = clto.LTO_DS_ERROR
    LTO_DS_WARNING = clto.LTO_DS_WARNING
    LTO_DS_REMARK = clto.LTO_DS_REMARK
    LTO_DS_NOTE = clto.LTO_DS_NOTE
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


cdef class lto_diagnostic_handler_t(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class clto.lto_diagnostic_handler_t.

    Python wrapper for cdef class clto.lto_diagnostic_handler_t.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef clto.lto_diagnostic_handler_t getElementPtr(self):
        return <clto.lto_diagnostic_handler_t>self._ptr

    @staticmethod
    cdef lto_diagnostic_handler_t fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``lto_diagnostic_handler_t`` objects from
        given ``clto.lto_diagnostic_handler_t`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef lto_diagnostic_handler_t wrapper = lto_diagnostic_handler_t.__new__(lto_diagnostic_handler_t)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a lto_diagnostic_handler_t from a Python object.

        Derives a lto_diagnostic_handler_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``lto_diagnostic_handler_t`` reference, this method
        returns it directly. No new ``lto_diagnostic_handler_t`` is created in this case.
        """
        return lto_diagnostic_handler_t.fromPyobj(pyobj)

    @staticmethod
    cdef lto_diagnostic_handler_t fromPyobj(object pyobj):
        """Creates a lto_diagnostic_handler_t from a Python object.

        Derives a lto_diagnostic_handler_t from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``lto_diagnostic_handler_t`` reference, this method
        returns it directly. No new ``lto_diagnostic_handler_t`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `lto_diagnostic_handler_t`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of lto_diagnostic_handler_t!
        """
        cdef lto_diagnostic_handler_t wrapper

        if isinstance(pyobj,lto_diagnostic_handler_t):
            return pyobj
        else:
            wrapper = lto_diagnostic_handler_t.__new__(lto_diagnostic_handler_t)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<lto_diagnostic_handler_t object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def lto_codegen_set_diagnostic_handler(object arg0, object arg1, object arg2):
    r"""(No short description, might be part of a group.)

    Set a diagnostic handler and the related context (void *).
    This is more general than lto_get_error_message, as the diagnostic handler
    can be called at anytime within lto.

    Since:
        LTO_API_VERSION=7

    Args:
        arg0 (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        arg1 (`~.lto_diagnostic_handler_t`/`~.object`):
            (undocumented)

        arg2 (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    clto.lto_codegen_set_diagnostic_handler(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(arg0).getElementPtr(),
        lto_diagnostic_handler_t.fromPyobj(arg1).getElementPtr(),
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(arg2)._ptr)


@cython.embedsignature(True)
def lto_codegen_create():
    r"""(No short description, might be part of a group.)

    Instantiates a code generator.
    Returns NULL on error (check lto_get_error_message() for details).

    All modules added using *lto_codegen_add_module()* must have been created
    in the same context as the codegen.

    Since:
        prior to LTO_API_VERSION=3
    """
    _lto_codegen_create__retval = LLVMOpaqueLTOCodeGenerator.fromPtr(clto.lto_codegen_create())
    return None if _lto_codegen_create__retval._ptr == NULL else _lto_codegen_create__retval


@cython.embedsignature(True)
def lto_codegen_create_in_local_context():
    r"""(No short description, might be part of a group.)

    Instantiate a code generator in its own context.

    Instantiates a code generator in its own context.  Modules added via \a
    lto_codegen_add_module() must have all been created in the same context,
    using *lto_module_create_in_codegen_context().*

    Since:
        LTO_API_VERSION=11
    """
    _lto_codegen_create_in_local_context__retval = LLVMOpaqueLTOCodeGenerator.fromPtr(clto.lto_codegen_create_in_local_context())
    return None if _lto_codegen_create_in_local_context__retval._ptr == NULL else _lto_codegen_create_in_local_context__retval


@cython.embedsignature(True)
def lto_codegen_dispose(object arg0):
    r"""(No short description, might be part of a group.)

    Frees all code generator and all memory it internally allocated.
    Upon return the lto_code_gen_t is no longer valid.

    Since:
        prior to LTO_API_VERSION=3

    Args:
        arg0 (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)
    """
    clto.lto_codegen_dispose(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(arg0).getElementPtr())


@cython.embedsignature(True)
def lto_codegen_add_module(object cg, object mod):
    r"""(No short description, might be part of a group.)

    Add an object module to the set of modules for which code will be generated.
    Returns true on error (check lto_get_error_message() for details).

    ``cg`` and ``mod`` must both be in the same context.  See \a
    lto_codegen_create_in_local_context() and \a
    lto_module_create_in_codegen_context().

    Since:
        prior to LTO_API_VERSION=3

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        mod (`~.LLVMOpaqueLTOModule`/`~.object`):
            (undocumented)
    """
    cdef _Bool _lto_codegen_add_module__retval = clto.lto_codegen_add_module(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        LLVMOpaqueLTOModule.fromPyobj(mod).getElementPtr())
    return _lto_codegen_add_module__retval


@cython.embedsignature(True)
def lto_codegen_set_module(object cg, object mod):
    r"""(No short description, might be part of a group.)

    Sets the object module for code generation. This will transfer the ownership
    of the module to the code generator.

    ``cg`` and ``mod`` must both be in the same context.

    Since:
        LTO_API_VERSION=13

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        mod (`~.LLVMOpaqueLTOModule`/`~.object`):
            (undocumented)
    """
    clto.lto_codegen_set_module(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        LLVMOpaqueLTOModule.fromPyobj(mod).getElementPtr())


@cython.embedsignature(True)
def lto_codegen_set_debug_model(object cg, object arg1):
    r"""(No short description, might be part of a group.)

    Sets if debug info should be generated.
    Returns true on error (check lto_get_error_message() for details).

    Since:
        prior to LTO_API_VERSION=3

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        arg1 (`~.lto_debug_model`):
            (undocumented)
    """
    if not isinstance(arg1,_lto_debug_model__Base):
        raise TypeError("argument 'arg1' must be of type '_lto_debug_model__Base'")
    cdef _Bool _lto_codegen_set_debug_model__retval = clto.lto_codegen_set_debug_model(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),arg1.value)
    return _lto_codegen_set_debug_model__retval


@cython.embedsignature(True)
def lto_codegen_set_pic_model(object cg, object arg1):
    r"""(No short description, might be part of a group.)

    Sets which PIC code model to generated.
    Returns true on error (check lto_get_error_message() for details).

    Since:
        prior to LTO_API_VERSION=3

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        arg1 (`~.lto_codegen_model`):
            (undocumented)
    """
    if not isinstance(arg1,_lto_codegen_model__Base):
        raise TypeError("argument 'arg1' must be of type '_lto_codegen_model__Base'")
    cdef _Bool _lto_codegen_set_pic_model__retval = clto.lto_codegen_set_pic_model(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),arg1.value)
    return _lto_codegen_set_pic_model__retval


@cython.embedsignature(True)
def lto_codegen_set_cpu(object cg, object cpu):
    r"""(No short description, might be part of a group.)

    Sets the cpu to generate code for.

    Since:
        LTO_API_VERSION=4

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        cpu (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    clto.lto_codegen_set_cpu(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(cpu)._ptr)


@cython.embedsignature(True)
def lto_codegen_set_assembler_path(object cg, object path):
    r"""(No short description, might be part of a group.)

    Sets the location of the assembler tool to run. If not set, libLTO
    will use gcc to invoke the assembler.

    Since:
        LTO_API_VERSION=3

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        path (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    clto.lto_codegen_set_assembler_path(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr)


@cython.embedsignature(True)
def lto_codegen_set_assembler_args(object cg, object args, int nargs):
    r"""(No short description, might be part of a group.)

    Sets extra arguments that libLTO should pass to the assembler.

    Since:
        LTO_API_VERSION=4

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        args (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        nargs (`~.int`):
            (undocumented)
    """
    clto.lto_codegen_set_assembler_args(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char **>rocm.llvm._util.types.CStr.fromPyobj(args)._ptr,nargs)


@cython.embedsignature(True)
def lto_codegen_add_must_preserve_symbol(object cg, object symbol):
    r"""(No short description, might be part of a group.)

    Adds to a list of all global symbols that must exist in the final generated
    code. If a function is not listed there, it might be inlined into every usage
    and optimized away.

    Since:
        prior to LTO_API_VERSION=3

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        symbol (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    clto.lto_codegen_add_must_preserve_symbol(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(symbol)._ptr)


@cython.embedsignature(True)
def lto_codegen_write_merged_modules(object cg, object path):
    r"""(No short description, might be part of a group.)

    Writes a new object file at the specified path that contains the
    merged contents of all modules added so far.
    Returns true on error (check lto_get_error_message() for details).

    Since:
        LTO_API_VERSION=5

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        path (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    cdef _Bool _lto_codegen_write_merged_modules__retval = clto.lto_codegen_write_merged_modules(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr)
    return _lto_codegen_write_merged_modules__retval


@cython.embedsignature(True)
def lto_codegen_compile(object cg, object length):
    r"""(No short description, might be part of a group.)

    Generates code for all added modules into one native object file.
    This calls lto_codegen_optimize then lto_codegen_compile_optimized.

    On success returns a pointer to a generated mach-o/ELF buffer and
    length set to the buffer size.  The buffer is owned by the
    lto_code_gen_t and will be freed when lto_codegen_dispose()
    is called, or lto_codegen_compile() is called again.
    On failure, returns NULL (check lto_get_error_message() for details).

    Since:
        prior to LTO_API_VERSION=3

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        length (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _lto_codegen_compile__retval = rocm.llvm._util.types.Pointer.fromPtr(<void*>clto.lto_codegen_compile(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(length)._ptr))
    return None if _lto_codegen_compile__retval._ptr == NULL else _lto_codegen_compile__retval


@cython.embedsignature(True)
def lto_codegen_compile_to_file(object cg, object name):
    r"""(No short description, might be part of a group.)

    Generates code for all added modules into one native object file.
    This calls lto_codegen_optimize then lto_codegen_compile_optimized (instead
    of returning a generated mach-o/ELF buffer, it writes to a file).

    The name of the file is written to name. Returns true on error.

    Since:
        LTO_API_VERSION=5

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        name (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    cdef _Bool _lto_codegen_compile_to_file__retval = clto.lto_codegen_compile_to_file(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char **>rocm.llvm._util.types.CStr.fromPyobj(name)._ptr)
    return _lto_codegen_compile_to_file__retval


@cython.embedsignature(True)
def lto_codegen_optimize(object cg):
    r"""(No short description, might be part of a group.)

    Runs optimization for the merged module. Returns true on error.

    Since:
        LTO_API_VERSION=12

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)
    """
    cdef _Bool _lto_codegen_optimize__retval = clto.lto_codegen_optimize(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr())
    return _lto_codegen_optimize__retval


@cython.embedsignature(True)
def lto_codegen_compile_optimized(object cg, object length):
    r"""(No short description, might be part of a group.)

    Generates code for the optimized merged module into one native object file.
    It will not run any IR optimizations on the merged module.

    On success returns a pointer to a generated mach-o/ELF buffer and length set
    to the buffer size.  The buffer is owned by the lto_code_gen_t and will be
    freed when lto_codegen_dispose() is called, or
    lto_codegen_compile_optimized() is called again. On failure, returns NULL
    (check lto_get_error_message() for details).

    Since:
        LTO_API_VERSION=12

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        length (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _lto_codegen_compile_optimized__retval = rocm.llvm._util.types.Pointer.fromPtr(<void*>clto.lto_codegen_compile_optimized(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(length)._ptr))
    return None if _lto_codegen_compile_optimized__retval._ptr == NULL else _lto_codegen_compile_optimized__retval


@cython.embedsignature(True)
def lto_api_version():
    r"""(No short description, might be part of a group.)

    Returns the runtime API version.

    Since:
        LTO_API_VERSION=12
    """
    cdef unsigned int _lto_api_version__retval = clto.lto_api_version()
    return _lto_api_version__retval


@cython.embedsignature(True)
def lto_set_debug_options(object options, int number):
    r"""(No short description, might be part of a group.)

    Parses options immediately, making them available as early as possible. For
    example during executing codegen`~.InitTargetOptionsFromCodeGenFlags`. Since
    parsing shud only happen once, only one of lto_codegen_debug_options or
    lto_set_debug_options should be called.

    This function takes one or more options separated by spaces.
    Warning: passing file paths through this function may confuse the argument
    parser if the paths contain spaces.

    Since:
        LTO_API_VERSION=28

    Args:
        options (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        number (`~.int`):
            (undocumented)
    """
    clto.lto_set_debug_options(
        <const char *const *>rocm.llvm._util.types.CStr.fromPyobj(options)._ptr,number)


@cython.embedsignature(True)
def lto_codegen_debug_options(object cg, object arg1):
    r"""(No short description, might be part of a group.)

    Sets options to help debug codegen bugs. Since parsing shud only happen once,
    only one of lto_codegen_debug_options or lto_set_debug_options
    should be called.

    This function takes one or more options separated by spaces.
    Warning: passing file paths through this function may confuse the argument
    parser if the paths contain spaces.

    Since:
        prior to LTO_API_VERSION=3

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        arg1 (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    clto.lto_codegen_debug_options(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(arg1)._ptr)


@cython.embedsignature(True)
def lto_codegen_debug_options_array(object cg, object arg1, int number):
    r"""(No short description, might be part of a group.)

    Same as the previous function, but takes every option separately through an
    array.

    Since:
        prior to LTO_API_VERSION=26

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        arg1 (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        number (`~.int`):
            (undocumented)
    """
    clto.lto_codegen_debug_options_array(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *const *>rocm.llvm._util.types.CStr.fromPyobj(arg1)._ptr,number)


@cython.embedsignature(True)
def lto_initialize_disassembler():
    r"""(No short description, might be part of a group.)

    Initializes LLVM disassemblers.
    FIXME: This doesn't really belong here.

    Since:
        LTO_API_VERSION=5
    """
    clto.lto_initialize_disassembler()


@cython.embedsignature(True)
def lto_codegen_set_should_internalize(object cg, _Bool ShouldInternalize):
    r"""(No short description, might be part of a group.)

    Sets if we should run internalize pass during optimization and code
    generation.

    Since:
        LTO_API_VERSION=14

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        ShouldInternalize (`~.bint`):
            (undocumented)
    """
    clto.lto_codegen_set_should_internalize(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),ShouldInternalize)


@cython.embedsignature(True)
def lto_codegen_set_should_embed_uselists(object cg, _Bool ShouldEmbedUselists):
    r"""(No short description, might be part of a group.)

    Set whether to embed uselists in bitcode.

    Sets whether *lto_codegen_write_merged_modules()* should embed uselists in
    output bitcode.  This should be turned on for all -save-temps output.

    Since:
        LTO_API_VERSION=15

    Args:
        cg (`~.LLVMOpaqueLTOCodeGenerator`/`~.object`):
            (undocumented)

        ShouldEmbedUselists (`~.bint`):
            (undocumented)
    """
    clto.lto_codegen_set_should_embed_uselists(
        LLVMOpaqueLTOCodeGenerator.fromPyobj(cg).getElementPtr(),ShouldEmbedUselists)


cdef class LLVMOpaqueLTOInput(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class clto.LLVMOpaqueLTOInput.

    Python wrapper for cdef class clto.LLVMOpaqueLTOInput.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef clto.LLVMOpaqueLTOInput* getElementPtr(self):
        return <clto.LLVMOpaqueLTOInput*>self._ptr

    @staticmethod
    cdef LLVMOpaqueLTOInput fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueLTOInput`` objects from
        given ``clto.LLVMOpaqueLTOInput`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueLTOInput wrapper = LLVMOpaqueLTOInput.__new__(LLVMOpaqueLTOInput)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueLTOInput from a Python object.

        Derives a LLVMOpaqueLTOInput from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueLTOInput`` reference, this method
        returns it directly. No new ``LLVMOpaqueLTOInput`` is created in this case.
        """
        return LLVMOpaqueLTOInput.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueLTOInput fromPyobj(object pyobj):
        """Creates a LLVMOpaqueLTOInput from a Python object.

        Derives a LLVMOpaqueLTOInput from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueLTOInput`` reference, this method
        returns it directly. No new ``LLVMOpaqueLTOInput`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueLTOInput`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueLTOInput!
        """
        cdef LLVMOpaqueLTOInput wrapper

        if isinstance(pyobj,LLVMOpaqueLTOInput):
            return pyobj
        else:
            wrapper = LLVMOpaqueLTOInput.__new__(LLVMOpaqueLTOInput)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueLTOInput object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


lto_input_t = LLVMOpaqueLTOInput

@cython.embedsignature(True)
def lto_input_create(object buffer, unsigned long buffer_size, object path):
    r"""(No short description, might be part of a group.)

    Creates an LTO input file from a buffer. The path
    argument is used for diagnotics as this function
    otherwise does not know which file the given buffer
    is associated with.

    Since:
        LTO_API_VERSION=24

    Args:
        buffer (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        buffer_size (`~.int`):
            (undocumented)

        path (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    _lto_input_create__retval = LLVMOpaqueLTOInput.fromPtr(clto.lto_input_create(
        <const void *>rocm.llvm._util.types.Pointer.fromPyobj(buffer)._ptr,buffer_size,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr))
    return None if _lto_input_create__retval._ptr == NULL else _lto_input_create__retval


@cython.embedsignature(True)
def lto_input_dispose(object input):
    r"""(No short description, might be part of a group.)

    Frees all memory internally allocated by the LTO input file.
    Upon return the lto_module_t is no longer valid.

    Since:
        LTO_API_VERSION=24

    Args:
        input (`~.LLVMOpaqueLTOInput`/`~.object`):
            (undocumented)
    """
    clto.lto_input_dispose(
        LLVMOpaqueLTOInput.fromPyobj(input).getElementPtr())


@cython.embedsignature(True)
def lto_input_get_num_dependent_libraries(object input):
    r"""(No short description, might be part of a group.)

    Returns the number of dependent library specifiers
    for the given LTO input file.

    Since:
        LTO_API_VERSION=24

    Args:
        input (`~.LLVMOpaqueLTOInput`/`~.object`):
            (undocumented)
    """
    cdef unsigned int _lto_input_get_num_dependent_libraries__retval = clto.lto_input_get_num_dependent_libraries(
        LLVMOpaqueLTOInput.fromPyobj(input).getElementPtr())
    return _lto_input_get_num_dependent_libraries__retval


@cython.embedsignature(True)
def lto_input_get_dependent_library(object input, unsigned long index, object size):
    r"""(No short description, might be part of a group.)

    Returns the ith dependent library specifier
    for the given LTO input file. The returned
    string is not null-terminated.

    Since:
        LTO_API_VERSION=24

    Args:
        input (`~.LLVMOpaqueLTOInput`/`~.object`):
            (undocumented)

        index (`~.int`):
            (undocumented)

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _lto_input_get_dependent_library__retval = rocm.llvm._util.types.CStr.fromPtr(<void*>clto.lto_input_get_dependent_library(
        LLVMOpaqueLTOInput.fromPyobj(input).getElementPtr(),index,
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr))
    return None if _lto_input_get_dependent_library__retval._ptr == NULL else _lto_input_get_dependent_library__retval


@cython.embedsignature(True)
def lto_runtime_lib_symbols_list(object size):
    r"""(No short description, might be part of a group.)

    Returns the list of libcall symbols that can be generated by LTO
    that might not be visible from the symbol table of bitcode files.

    Since:
        prior to LTO_API_VERSION=25

    Args:
        size (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _lto_runtime_lib_symbols_list__retval = rocm.llvm._util.types.Pointer.fromPtr(<void*>clto.lto_runtime_lib_symbols_list(
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr))
    return None if _lto_runtime_lib_symbols_list__retval._ptr == NULL else _lto_runtime_lib_symbols_list__retval


cdef class LTOObjectBuffer(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class clto.LTOObjectBuffer.

    Python wrapper for cdef class clto.LTOObjectBuffer.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef clto.LTOObjectBuffer* getElementPtr(self):
        return <clto.LTOObjectBuffer*>self._ptr

    @staticmethod
    cdef LTOObjectBuffer fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LTOObjectBuffer`` objects from
        given ``clto.LTOObjectBuffer`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LTOObjectBuffer wrapper = LTOObjectBuffer.__new__(LTOObjectBuffer)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LTOObjectBuffer from a Python object.

        Derives a LTOObjectBuffer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LTOObjectBuffer`` reference, this method
        returns it directly. No new ``LTOObjectBuffer`` is created in this case.
        """
        return LTOObjectBuffer.fromPyobj(pyobj)

    @staticmethod
    cdef LTOObjectBuffer fromPyobj(object pyobj):
        """Creates a LTOObjectBuffer from a Python object.

        Derives a LTOObjectBuffer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LTOObjectBuffer`` reference, this method
        returns it directly. No new ``LTOObjectBuffer`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LTOObjectBuffer`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LTOObjectBuffer!
        """
        cdef LTOObjectBuffer wrapper

        if isinstance(pyobj,LTOObjectBuffer):
            return pyobj
        else:
            wrapper = LTOObjectBuffer.__new__(LTOObjectBuffer)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(clto.LTOObjectBuffer))
        string.memset(<void*>ptr[0], 0, sizeof(clto.LTOObjectBuffer))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LTOObjectBuffer new():
        """Factory function to create LTOObjectBuffer objects with
        newly allocated clto.LTOObjectBuffer"""
        cdef void* ptr
        LTOObjectBuffer.__allocate(&ptr)
        return LTOObjectBuffer.fromPtr(ptr, owner=True)

    @staticmethod
    cdef LTOObjectBuffer fromValue(clto.LTOObjectBuffer other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LTOObjectBuffer.new()
        string.memcpy(wrapper._ptr, &other, sizeof(clto.LTOObjectBuffer))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(clto.LTOObjectBuffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LTOObjectBuffer object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type LTOObjectBuffer.

        Constructor for type LTOObjectBuffer.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LTOObjectBuffer.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_Buffer(self, i):
        """Get value ``Buffer`` of ``(<clto.LTOObjectBuffer*>self._ptr)[i]``.
        """
        return (<clto.LTOObjectBuffer*>self._ptr)[i].Buffer
    def set_Buffer(self, i, const char * value):
        """Set value ``Buffer`` of ``(<clto.LTOObjectBuffer*>self._ptr)[i]``.
        """
        (<clto.LTOObjectBuffer*>self._ptr)[i].Buffer = value
    @property
    def Buffer(self):
        """(undocumented)"""
        return self.get_Buffer(0)
    @Buffer.setter
    def Buffer(self, const char * value):
        self.set_Buffer(0,value)

    def get_Size(self, i):
        """Get value ``Size`` of ``(<clto.LTOObjectBuffer*>self._ptr)[i]``.
        """
        return (<clto.LTOObjectBuffer*>self._ptr)[i].Size
    def set_Size(self, i, unsigned long value):
        """Set value ``Size`` of ``(<clto.LTOObjectBuffer*>self._ptr)[i]``.
        """
        (<clto.LTOObjectBuffer*>self._ptr)[i].Size = value
    @property
    def Size(self):
        """(undocumented)"""
        return self.get_Size(0)
    @Size.setter
    def Size(self, unsigned long value):
        self.set_Size(0,value)

    @staticmethod
    def PROPERTIES():
        return ["Buffer","Size"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


@cython.embedsignature(True)
def thinlto_create_codegen():
    r"""(No short description, might be part of a group.)

    Instantiates a ThinLTO code generator.
    Returns NULL on error (check lto_get_error_message() for details).

    The ThinLTOCodeGenerator is not intended to be reuse for multiple
    compilation: the model is that the client adds modules to the generator and
    ask to perform the ThinLTO optimizations / codegen, and finally destroys the
    codegenerator.

    Since:
        LTO_API_VERSION=18
    """
    _thinlto_create_codegen__retval = LLVMOpaqueThinLTOCodeGenerator.fromPtr(clto.thinlto_create_codegen())
    return None if _thinlto_create_codegen__retval._ptr == NULL else _thinlto_create_codegen__retval


@cython.embedsignature(True)
def thinlto_codegen_dispose(object cg):
    r"""(No short description, might be part of a group.)

    Frees the generator and all memory it internally allocated.
    Upon return the thinlto_code_gen_t is no longer valid.

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)
    """
    clto.thinlto_codegen_dispose(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr())


@cython.embedsignature(True)
def thinlto_codegen_add_module(object cg, object identifier, object data, int length):
    r"""(No short description, might be part of a group.)

    Add a module to a ThinLTO code generator. Identifier has to be unique among
    all the modules in a code generator. The data buffer stays owned by the
    client, and is expected to be available for the entire lifetime of the
    thinlto_code_gen_t it is added to.

    On failure, returns NULL (check lto_get_error_message() for details).

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        identifier (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        data (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        length (`~.int`):
            (undocumented)
    """
    clto.thinlto_codegen_add_module(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(identifier)._ptr,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(data)._ptr,length)


@cython.embedsignature(True)
def thinlto_codegen_process(object cg):
    r"""(No short description, might be part of a group.)

    Optimize and codegen all the modules added to the codegenerator using
    ThinLTO. Resulting objects are accessible using thinlto_module_get_object().

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)
    """
    clto.thinlto_codegen_process(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr())


@cython.embedsignature(True)
def thinlto_module_get_num_objects(object cg):
    r"""(No short description, might be part of a group.)

    Returns the number of object files produced by the ThinLTO CodeGenerator.

    It usually matches the number of input files, but this is not a guarantee of
    the API and may change in future implementation, so the client should not
    assume it.

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)
    """
    cdef unsigned int _thinlto_module_get_num_objects__retval = clto.thinlto_module_get_num_objects(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr())
    return _thinlto_module_get_num_objects__retval


@cython.embedsignature(True)
def thinlto_module_get_object(object cg, unsigned int index):
    r"""(No short description, might be part of a group.)

    Returns a reference to the ith object file produced by the ThinLTO
    CodeGenerator.

    Client should use ``thinlto_module_get_num_objects()`` to get the number of
    available objects.

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        index (`~.int`):
            (undocumented)
    """
    _thinlto_module_get_object__retval = LTOObjectBuffer.fromValue(clto.thinlto_module_get_object(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),index))
    return _thinlto_module_get_object__retval


@cython.embedsignature(True)
def thinlto_module_get_num_object_files(object cg):
    r"""(No short description, might be part of a group.)

    Returns the number of object files produced by the ThinLTO CodeGenerator.

    It usually matches the number of input files, but this is not a guarantee of
    the API and may change in future implementation, so the client should not
    assume it.

    Since:
        LTO_API_VERSION=21

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)
    """
    cdef unsigned int _thinlto_module_get_num_object_files__retval = clto.thinlto_module_get_num_object_files(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr())
    return _thinlto_module_get_num_object_files__retval


@cython.embedsignature(True)
def thinlto_module_get_object_file(object cg, unsigned int index):
    r"""(No short description, might be part of a group.)

    Returns the path to the ith object file produced by the ThinLTO
    CodeGenerator.

    Client should use ``thinlto_module_get_num_object_files()`` to get the number
    of available objects.

    Since:
        LTO_API_VERSION=21

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        index (`~.int`):
            (undocumented)
    """
    _thinlto_module_get_object_file__retval = rocm.llvm._util.types.CStr.fromPtr(<void*>clto.thinlto_module_get_object_file(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),index))
    return None if _thinlto_module_get_object_file__retval._ptr == NULL else _thinlto_module_get_object_file__retval


@cython.embedsignature(True)
def thinlto_codegen_set_pic_model(object cg, object arg1):
    r"""(No short description, might be part of a group.)

    Sets which PIC code model to generate.
    Returns true on error (check lto_get_error_message() for details).

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        arg1 (`~.lto_codegen_model`):
            (undocumented)
    """
    if not isinstance(arg1,_lto_codegen_model__Base):
        raise TypeError("argument 'arg1' must be of type '_lto_codegen_model__Base'")
    cdef _Bool _thinlto_codegen_set_pic_model__retval = clto.thinlto_codegen_set_pic_model(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),arg1.value)
    return _thinlto_codegen_set_pic_model__retval


@cython.embedsignature(True)
def thinlto_codegen_set_savetemps_dir(object cg, object save_temps_dir):
    r"""(No short description, might be part of a group.)

    Sets the path to a directory to use as a storage for temporary bitcode files.
    The intention is to make the bitcode files available for debugging at various
    stage of the pipeline.

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        save_temps_dir (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    clto.thinlto_codegen_set_savetemps_dir(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(save_temps_dir)._ptr)


@cython.embedsignature(True)
def thinlto_set_generated_objects_dir(object cg, object save_temps_dir):
    r"""(No short description, might be part of a group.)

    Set the path to a directory where to save generated object files. This
    path can be used by a linker to request on-disk files instead of in-memory
    buffers. When set, results are available through
    thinlto_module_get_object_file() instead of thinlto_module_get_object().

    Since:
        LTO_API_VERSION=21

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        save_temps_dir (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    clto.thinlto_set_generated_objects_dir(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(save_temps_dir)._ptr)


@cython.embedsignature(True)
def thinlto_codegen_set_cpu(object cg, object cpu):
    r"""(No short description, might be part of a group.)

    Sets the cpu to generate code for.

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        cpu (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    clto.thinlto_codegen_set_cpu(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(cpu)._ptr)


@cython.embedsignature(True)
def thinlto_codegen_disable_codegen(object cg, _Bool disable):
    r"""(No short description, might be part of a group.)

    Disable CodeGen, only run the stages till codegen and stop. The output will
    be bitcode.

    Since:
        LTO_API_VERSION=19

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        disable (`~.bint`):
            (undocumented)
    """
    clto.thinlto_codegen_disable_codegen(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),disable)


@cython.embedsignature(True)
def thinlto_codegen_set_codegen_only(object cg, _Bool codegen_only):
    r"""(No short description, might be part of a group.)

    Perform CodeGen only: disable all other stages.

    Since:
        LTO_API_VERSION=19

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        codegen_only (`~.bint`):
            (undocumented)
    """
    clto.thinlto_codegen_set_codegen_only(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),codegen_only)


@cython.embedsignature(True)
def thinlto_debug_options(object options, int number):
    r"""(No short description, might be part of a group.)

    Parse -mllvm style debug options.

    Since:
        LTO_API_VERSION=18

    Args:
        options (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        number (`~.int`):
            (undocumented)
    """
    clto.thinlto_debug_options(
        <const char *const *>rocm.llvm._util.types.CStr.fromPyobj(options)._ptr,number)


@cython.embedsignature(True)
def lto_module_is_thinlto(object mod):
    r"""(No short description, might be part of a group.)

    Test if a module has support for ThinLTO linking.

    Since:
        LTO_API_VERSION=18

    Args:
        mod (`~.LLVMOpaqueLTOModule`/`~.object`):
            (undocumented)
    """
    cdef _Bool _lto_module_is_thinlto__retval = clto.lto_module_is_thinlto(
        LLVMOpaqueLTOModule.fromPyobj(mod).getElementPtr())
    return _lto_module_is_thinlto__retval


@cython.embedsignature(True)
def thinlto_codegen_add_must_preserve_symbol(object cg, object name, int length):
    r"""(No short description, might be part of a group.)

    Adds a symbol to the list of global symbols that must exist in the final
    generated code. If a function is not listed there, it might be inlined into
    every usage and optimized away. For every single module, the functions
    referenced from code outside of the ThinLTO modules need to be added here.

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        name (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        length (`~.int`):
            (undocumented)
    """
    clto.thinlto_codegen_add_must_preserve_symbol(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(name)._ptr,length)


@cython.embedsignature(True)
def thinlto_codegen_add_cross_referenced_symbol(object cg, object name, int length):
    r"""(No short description, might be part of a group.)

    Adds a symbol to the list of global symbols that are cross-referenced between
    ThinLTO files. If the ThinLTO CodeGenerator can ensure that every
    references from a ThinLTO module to this symbol is optimized away, then
    the symbol can be discarded.

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        name (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        length (`~.int`):
            (undocumented)
    """
    clto.thinlto_codegen_add_cross_referenced_symbol(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(name)._ptr,length)


@cython.embedsignature(True)
def thinlto_codegen_set_cache_dir(object cg, object cache_dir):
    r"""(No short description, might be part of a group.)

    Sets the path to a directory to use as a cache storage for incremental build.
    Setting this activates caching.

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        cache_dir (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    clto.thinlto_codegen_set_cache_dir(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(cache_dir)._ptr)


@cython.embedsignature(True)
def thinlto_codegen_set_cache_pruning_interval(object cg, int interval):
    r"""(No short description, might be part of a group.)

    Sets the cache pruning interval (in seconds). A negative value disables the
    pruning. An unspecified default value will be applied, and a value of 0 will
    force prunning to occur.

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        interval (`~.int`):
            (undocumented)
    """
    clto.thinlto_codegen_set_cache_pruning_interval(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),interval)


@cython.embedsignature(True)
def thinlto_codegen_set_final_cache_size_relative_to_available_space(object cg, unsigned int percentage):
    r"""(No short description, might be part of a group.)

    Sets the maximum cache size that can be persistent across build, in terms of
    percentage of the available space on the disk. Set to 100 to indicate
    no limit, 50 to indicate that the cache size will not be left over half the
    available space. A value over 100 will be reduced to 100, a value of 0 will
    be ignored. An unspecified default value will be applied.

    The formula looks like:
     AvailableSpace = FreeSpace + ExistingCacheSize
     NewCacheSize = AvailableSpace * P/100

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        percentage (`~.int`):
            (undocumented)
    """
    clto.thinlto_codegen_set_final_cache_size_relative_to_available_space(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),percentage)


@cython.embedsignature(True)
def thinlto_codegen_set_cache_entry_expiration(object cg, unsigned int expiration):
    r"""(No short description, might be part of a group.)

    Sets the expiration (in seconds) for an entry in the cache. An unspecified
    default value will be applied. A value of 0 will be ignored.

    Since:
        LTO_API_VERSION=18

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        expiration (`~.int`):
            (undocumented)
    """
    clto.thinlto_codegen_set_cache_entry_expiration(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),expiration)


@cython.embedsignature(True)
def thinlto_codegen_set_cache_size_bytes(object cg, unsigned int max_size_bytes):
    r"""(No short description, might be part of a group.)

    Sets the maximum size of the cache directory (in bytes). A value over the
    amount of available space on the disk will be reduced to the amount of
    available space. An unspecified default value will be applied. A value of 0
    will be ignored.

    Since:
        LTO_API_VERSION=22

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        max_size_bytes (`~.int`):
            (undocumented)
    """
    clto.thinlto_codegen_set_cache_size_bytes(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),max_size_bytes)


@cython.embedsignature(True)
def thinlto_codegen_set_cache_size_megabytes(object cg, unsigned int max_size_megabytes):
    r"""(No short description, might be part of a group.)

    Same as thinlto_codegen_set_cache_size_bytes, except the maximum size is in
    megabytes (2^20 bytes).

    Since:
        LTO_API_VERSION=23

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        max_size_megabytes (`~.int`):
            (undocumented)
    """
    clto.thinlto_codegen_set_cache_size_megabytes(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),max_size_megabytes)


@cython.embedsignature(True)
def thinlto_codegen_set_cache_size_files(object cg, unsigned int max_size_files):
    r"""(No short description, might be part of a group.)

    Sets the maximum number of files in the cache directory. An unspecified
    default value will be applied. A value of 0 will be ignored.

    Since:
        LTO_API_VERSION=22

    Args:
        cg (`~.LLVMOpaqueThinLTOCodeGenerator`/`~.object`):
            (undocumented)

        max_size_files (`~.int`):
            (undocumented)
    """
    clto.thinlto_codegen_set_cache_size_files(
        LLVMOpaqueThinLTOCodeGenerator.fromPyobj(cg).getElementPtr(),max_size_files)

__all__ = [
    "_lto_symbol_attributes__Base",
    "lto_symbol_attributes",
    "_lto_debug_model__Base",
    "lto_debug_model",
    "_lto_codegen_model__Base",
    "lto_codegen_model",
    "LLVMOpaqueLTOModule",
    "lto_module_t",
    "LLVMOpaqueLTOCodeGenerator",
    "lto_code_gen_t",
    "LLVMOpaqueThinLTOCodeGenerator",
    "thinlto_code_gen_t",
    "lto_get_version",
    "lto_get_error_message",
    "lto_module_is_object_file",
    "lto_module_is_object_file_for_target",
    "lto_module_has_objc_category",
    "lto_module_is_object_file_in_memory",
    "lto_module_is_object_file_in_memory_for_target",
    "lto_module_create",
    "lto_module_create_from_memory",
    "lto_module_create_from_memory_with_path",
    "lto_module_create_in_local_context",
    "lto_module_create_in_codegen_context",
    "lto_module_create_from_fd",
    "lto_module_create_from_fd_at_offset",
    "lto_module_dispose",
    "lto_module_get_target_triple",
    "lto_module_set_target_triple",
    "lto_module_get_num_symbols",
    "lto_module_get_symbol_name",
    "lto_module_get_symbol_attribute",
    "lto_module_get_linkeropts",
    "lto_module_get_macho_cputype",
    "lto_module_has_ctor_dtor",
    "_lto_codegen_diagnostic_severity_t__Base",
    "lto_codegen_diagnostic_severity_t",
    "lto_diagnostic_handler_t",
    "lto_codegen_set_diagnostic_handler",
    "lto_codegen_create",
    "lto_codegen_create_in_local_context",
    "lto_codegen_dispose",
    "lto_codegen_add_module",
    "lto_codegen_set_module",
    "lto_codegen_set_debug_model",
    "lto_codegen_set_pic_model",
    "lto_codegen_set_cpu",
    "lto_codegen_set_assembler_path",
    "lto_codegen_set_assembler_args",
    "lto_codegen_add_must_preserve_symbol",
    "lto_codegen_write_merged_modules",
    "lto_codegen_compile",
    "lto_codegen_compile_to_file",
    "lto_codegen_optimize",
    "lto_codegen_compile_optimized",
    "lto_api_version",
    "lto_set_debug_options",
    "lto_codegen_debug_options",
    "lto_codegen_debug_options_array",
    "lto_initialize_disassembler",
    "lto_codegen_set_should_internalize",
    "lto_codegen_set_should_embed_uselists",
    "LLVMOpaqueLTOInput",
    "lto_input_t",
    "lto_input_create",
    "lto_input_dispose",
    "lto_input_get_num_dependent_libraries",
    "lto_input_get_dependent_library",
    "lto_runtime_lib_symbols_list",
    "LTOObjectBuffer",
    "thinlto_create_codegen",
    "thinlto_codegen_dispose",
    "thinlto_codegen_add_module",
    "thinlto_codegen_process",
    "thinlto_module_get_num_objects",
    "thinlto_module_get_object",
    "thinlto_module_get_num_object_files",
    "thinlto_module_get_object_file",
    "thinlto_codegen_set_pic_model",
    "thinlto_codegen_set_savetemps_dir",
    "thinlto_set_generated_objects_dir",
    "thinlto_codegen_set_cpu",
    "thinlto_codegen_disable_codegen",
    "thinlto_codegen_set_codegen_only",
    "thinlto_debug_options",
    "lto_module_is_thinlto",
    "thinlto_codegen_add_must_preserve_symbol",
    "thinlto_codegen_add_cross_referenced_symbol",
    "thinlto_codegen_set_cache_dir",
    "thinlto_codegen_set_cache_pruning_interval",
    "thinlto_codegen_set_final_cache_size_relative_to_available_space",
    "thinlto_codegen_set_cache_entry_expiration",
    "thinlto_codegen_set_cache_size_bytes",
    "thinlto_codegen_set_cache_size_megabytes",
    "thinlto_codegen_set_cache_size_files",
]