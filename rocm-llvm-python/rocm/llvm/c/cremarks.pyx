# MIT License
# 
# Copyright (c) 2023 Advanced Micro Devices, Inc.
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.

cimport rocm.llvm._util.posixloader as loader
cdef void* _lib_handle = NULL

DLL = "librocmllvm.so"

cdef void __init():
    global DLL
    global _lib_handle
    if not isinstance(DLL,str):
        raise RuntimeError(f"'DLL' must be of type `str`")
    if _lib_handle == NULL:
        _lib_handle = loader.open_library(DLL.encode("utf-8"))

cdef void __init_symbol(void** result, const char* name):
    global _lib_handle
    if _lib_handle == NULL:
        __init()
    if result[0] == NULL:
        result[0] = loader.load_symbol(_lib_handle, name)


cdef void* _LLVMRemarkStringGetData__funptr = NULL
# 
# Returns the buffer holding the string.
# 
# \since REMARKS_API_VERSION=0
cdef const char * LLVMRemarkStringGetData(LLVMRemarkStringRef String):
    global _LLVMRemarkStringGetData__funptr
    __init_symbol(&_LLVMRemarkStringGetData__funptr,"LLVMRemarkStringGetData")
    with nogil:
        return (<const char * (*)(LLVMRemarkStringRef) noexcept nogil> _LLVMRemarkStringGetData__funptr)(String)


cdef void* _LLVMRemarkStringGetLen__funptr = NULL
# 
# Returns the size of the string.
# 
# \since REMARKS_API_VERSION=0
cdef unsigned int LLVMRemarkStringGetLen(LLVMRemarkStringRef String):
    global _LLVMRemarkStringGetLen__funptr
    __init_symbol(&_LLVMRemarkStringGetLen__funptr,"LLVMRemarkStringGetLen")
    with nogil:
        return (<unsigned int (*)(LLVMRemarkStringRef) noexcept nogil> _LLVMRemarkStringGetLen__funptr)(String)


cdef void* _LLVMRemarkDebugLocGetSourceFilePath__funptr = NULL
# 
# Return the path to the source file for a debug location.
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkStringRef LLVMRemarkDebugLocGetSourceFilePath(LLVMRemarkDebugLocRef DL):
    global _LLVMRemarkDebugLocGetSourceFilePath__funptr
    __init_symbol(&_LLVMRemarkDebugLocGetSourceFilePath__funptr,"LLVMRemarkDebugLocGetSourceFilePath")
    with nogil:
        return (<LLVMRemarkStringRef (*)(LLVMRemarkDebugLocRef) noexcept nogil> _LLVMRemarkDebugLocGetSourceFilePath__funptr)(DL)


cdef void* _LLVMRemarkDebugLocGetSourceLine__funptr = NULL
# 
# Return the line in the source file for a debug location.
# 
# \since REMARKS_API_VERSION=0
cdef unsigned int LLVMRemarkDebugLocGetSourceLine(LLVMRemarkDebugLocRef DL):
    global _LLVMRemarkDebugLocGetSourceLine__funptr
    __init_symbol(&_LLVMRemarkDebugLocGetSourceLine__funptr,"LLVMRemarkDebugLocGetSourceLine")
    with nogil:
        return (<unsigned int (*)(LLVMRemarkDebugLocRef) noexcept nogil> _LLVMRemarkDebugLocGetSourceLine__funptr)(DL)


cdef void* _LLVMRemarkDebugLocGetSourceColumn__funptr = NULL
# 
# Return the column in the source file for a debug location.
# 
# \since REMARKS_API_VERSION=0
cdef unsigned int LLVMRemarkDebugLocGetSourceColumn(LLVMRemarkDebugLocRef DL):
    global _LLVMRemarkDebugLocGetSourceColumn__funptr
    __init_symbol(&_LLVMRemarkDebugLocGetSourceColumn__funptr,"LLVMRemarkDebugLocGetSourceColumn")
    with nogil:
        return (<unsigned int (*)(LLVMRemarkDebugLocRef) noexcept nogil> _LLVMRemarkDebugLocGetSourceColumn__funptr)(DL)


cdef void* _LLVMRemarkArgGetKey__funptr = NULL
# 
# Returns the key of an argument. The key defines what the value is, and the
# same key can appear multiple times in the list of arguments.
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkStringRef LLVMRemarkArgGetKey(LLVMRemarkArgRef Arg):
    global _LLVMRemarkArgGetKey__funptr
    __init_symbol(&_LLVMRemarkArgGetKey__funptr,"LLVMRemarkArgGetKey")
    with nogil:
        return (<LLVMRemarkStringRef (*)(LLVMRemarkArgRef) noexcept nogil> _LLVMRemarkArgGetKey__funptr)(Arg)


cdef void* _LLVMRemarkArgGetValue__funptr = NULL
# 
# Returns the value of an argument. This is a string that can contain newlines.
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkStringRef LLVMRemarkArgGetValue(LLVMRemarkArgRef Arg):
    global _LLVMRemarkArgGetValue__funptr
    __init_symbol(&_LLVMRemarkArgGetValue__funptr,"LLVMRemarkArgGetValue")
    with nogil:
        return (<LLVMRemarkStringRef (*)(LLVMRemarkArgRef) noexcept nogil> _LLVMRemarkArgGetValue__funptr)(Arg)


cdef void* _LLVMRemarkArgGetDebugLoc__funptr = NULL
# 
# Returns the debug location that is attached to the value of this argument.
# 
# If there is no debug location, the return value will be `NULL`.
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkDebugLocRef LLVMRemarkArgGetDebugLoc(LLVMRemarkArgRef Arg):
    global _LLVMRemarkArgGetDebugLoc__funptr
    __init_symbol(&_LLVMRemarkArgGetDebugLoc__funptr,"LLVMRemarkArgGetDebugLoc")
    with nogil:
        return (<LLVMRemarkDebugLocRef (*)(LLVMRemarkArgRef) noexcept nogil> _LLVMRemarkArgGetDebugLoc__funptr)(Arg)


cdef void* _LLVMRemarkEntryDispose__funptr = NULL
# 
# Free the resources used by the remark entry.
# 
# \since REMARKS_API_VERSION=0
cdef void LLVMRemarkEntryDispose(LLVMRemarkEntryRef Remark):
    global _LLVMRemarkEntryDispose__funptr
    __init_symbol(&_LLVMRemarkEntryDispose__funptr,"LLVMRemarkEntryDispose")
    with nogil:
        (<void (*)(LLVMRemarkEntryRef) noexcept nogil> _LLVMRemarkEntryDispose__funptr)(Remark)


cdef void* _LLVMRemarkEntryGetType__funptr = NULL
# 
# The type of the remark. For example, it can allow users to only keep the
# missed optimizations from the compiler.
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkType LLVMRemarkEntryGetType(LLVMRemarkEntryRef Remark):
    global _LLVMRemarkEntryGetType__funptr
    __init_symbol(&_LLVMRemarkEntryGetType__funptr,"LLVMRemarkEntryGetType")
    with nogil:
        return (<LLVMRemarkType (*)(LLVMRemarkEntryRef) noexcept nogil> _LLVMRemarkEntryGetType__funptr)(Remark)


cdef void* _LLVMRemarkEntryGetPassName__funptr = NULL
# 
# Get the name of the pass that emitted this remark.
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkStringRef LLVMRemarkEntryGetPassName(LLVMRemarkEntryRef Remark):
    global _LLVMRemarkEntryGetPassName__funptr
    __init_symbol(&_LLVMRemarkEntryGetPassName__funptr,"LLVMRemarkEntryGetPassName")
    with nogil:
        return (<LLVMRemarkStringRef (*)(LLVMRemarkEntryRef) noexcept nogil> _LLVMRemarkEntryGetPassName__funptr)(Remark)


cdef void* _LLVMRemarkEntryGetRemarkName__funptr = NULL
# 
# Get an identifier of the remark.
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkStringRef LLVMRemarkEntryGetRemarkName(LLVMRemarkEntryRef Remark):
    global _LLVMRemarkEntryGetRemarkName__funptr
    __init_symbol(&_LLVMRemarkEntryGetRemarkName__funptr,"LLVMRemarkEntryGetRemarkName")
    with nogil:
        return (<LLVMRemarkStringRef (*)(LLVMRemarkEntryRef) noexcept nogil> _LLVMRemarkEntryGetRemarkName__funptr)(Remark)


cdef void* _LLVMRemarkEntryGetFunctionName__funptr = NULL
# 
# Get the name of the function being processed when the remark was emitted.
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkStringRef LLVMRemarkEntryGetFunctionName(LLVMRemarkEntryRef Remark):
    global _LLVMRemarkEntryGetFunctionName__funptr
    __init_symbol(&_LLVMRemarkEntryGetFunctionName__funptr,"LLVMRemarkEntryGetFunctionName")
    with nogil:
        return (<LLVMRemarkStringRef (*)(LLVMRemarkEntryRef) noexcept nogil> _LLVMRemarkEntryGetFunctionName__funptr)(Remark)


cdef void* _LLVMRemarkEntryGetDebugLoc__funptr = NULL
# 
# Returns the debug location that is attached to this remark.
# 
# If there is no debug location, the return value will be `NULL`.
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkDebugLocRef LLVMRemarkEntryGetDebugLoc(LLVMRemarkEntryRef Remark):
    global _LLVMRemarkEntryGetDebugLoc__funptr
    __init_symbol(&_LLVMRemarkEntryGetDebugLoc__funptr,"LLVMRemarkEntryGetDebugLoc")
    with nogil:
        return (<LLVMRemarkDebugLocRef (*)(LLVMRemarkEntryRef) noexcept nogil> _LLVMRemarkEntryGetDebugLoc__funptr)(Remark)


cdef void* _LLVMRemarkEntryGetHotness__funptr = NULL
# 
# Return the hotness of the remark.
# 
# A hotness of `0` means this value is not set.
# 
# \since REMARKS_API_VERSION=0
cdef unsigned long LLVMRemarkEntryGetHotness(LLVMRemarkEntryRef Remark):
    global _LLVMRemarkEntryGetHotness__funptr
    __init_symbol(&_LLVMRemarkEntryGetHotness__funptr,"LLVMRemarkEntryGetHotness")
    with nogil:
        return (<unsigned long (*)(LLVMRemarkEntryRef) noexcept nogil> _LLVMRemarkEntryGetHotness__funptr)(Remark)


cdef void* _LLVMRemarkEntryGetNumArgs__funptr = NULL
# 
# The number of arguments the remark holds.
# 
# \since REMARKS_API_VERSION=0
cdef unsigned int LLVMRemarkEntryGetNumArgs(LLVMRemarkEntryRef Remark):
    global _LLVMRemarkEntryGetNumArgs__funptr
    __init_symbol(&_LLVMRemarkEntryGetNumArgs__funptr,"LLVMRemarkEntryGetNumArgs")
    with nogil:
        return (<unsigned int (*)(LLVMRemarkEntryRef) noexcept nogil> _LLVMRemarkEntryGetNumArgs__funptr)(Remark)


cdef void* _LLVMRemarkEntryGetFirstArg__funptr = NULL
# 
# Get a new iterator to iterate over a remark's argument.
# 
# If there are no arguments in \p Remark, the return value will be `NULL`.
# 
# The lifetime of the returned value is bound to the lifetime of \p Remark.
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkArgRef LLVMRemarkEntryGetFirstArg(LLVMRemarkEntryRef Remark):
    global _LLVMRemarkEntryGetFirstArg__funptr
    __init_symbol(&_LLVMRemarkEntryGetFirstArg__funptr,"LLVMRemarkEntryGetFirstArg")
    with nogil:
        return (<LLVMRemarkArgRef (*)(LLVMRemarkEntryRef) noexcept nogil> _LLVMRemarkEntryGetFirstArg__funptr)(Remark)


cdef void* _LLVMRemarkEntryGetNextArg__funptr = NULL
# 
# Get the next argument in \p Remark from the position of \p It.
# 
# Returns `NULL` if there are no more arguments available.
# 
# The lifetime of the returned value is bound to the lifetime of \p Remark.
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkArgRef LLVMRemarkEntryGetNextArg(LLVMRemarkArgRef It,LLVMRemarkEntryRef Remark):
    global _LLVMRemarkEntryGetNextArg__funptr
    __init_symbol(&_LLVMRemarkEntryGetNextArg__funptr,"LLVMRemarkEntryGetNextArg")
    with nogil:
        return (<LLVMRemarkArgRef (*)(LLVMRemarkArgRef,LLVMRemarkEntryRef) noexcept nogil> _LLVMRemarkEntryGetNextArg__funptr)(It,Remark)


cdef void* _LLVMRemarkParserCreateYAML__funptr = NULL
# 
# Creates a remark parser that can be used to parse the buffer located in \p
# Buf of size \p Size bytes.
# 
# \p Buf cannot be `NULL`.
# 
# This function should be paired with LLVMRemarkParserDispose() to avoid
# leaking resources.
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkParserRef LLVMRemarkParserCreateYAML(const void * Buf,unsigned long Size):
    global _LLVMRemarkParserCreateYAML__funptr
    __init_symbol(&_LLVMRemarkParserCreateYAML__funptr,"LLVMRemarkParserCreateYAML")
    with nogil:
        return (<LLVMRemarkParserRef (*)(const void *,unsigned long) noexcept nogil> _LLVMRemarkParserCreateYAML__funptr)(Buf,Size)


cdef void* _LLVMRemarkParserCreateBitstream__funptr = NULL
# 
# Creates a remark parser that can be used to parse the buffer located in \p
# Buf of size \p Size bytes.
# 
# \p Buf cannot be `NULL`.
# 
# This function should be paired with LLVMRemarkParserDispose() to avoid
# leaking resources.
# 
# \since REMARKS_API_VERSION=1
cdef LLVMRemarkParserRef LLVMRemarkParserCreateBitstream(const void * Buf,unsigned long Size):
    global _LLVMRemarkParserCreateBitstream__funptr
    __init_symbol(&_LLVMRemarkParserCreateBitstream__funptr,"LLVMRemarkParserCreateBitstream")
    with nogil:
        return (<LLVMRemarkParserRef (*)(const void *,unsigned long) noexcept nogil> _LLVMRemarkParserCreateBitstream__funptr)(Buf,Size)


cdef void* _LLVMRemarkParserGetNext__funptr = NULL
# 
# Returns the next remark in the file.
# 
# The value pointed to by the return value needs to be disposed using a call to
# LLVMRemarkEntryDispose().
# 
# All the entries in the returned value that are of LLVMRemarkStringRef type
# will become invalidated once a call to LLVMRemarkParserDispose is made.
# 
# If the parser reaches the end of the buffer, the return value will be `NULL`.
# 
# In the case of an error, the return value will be `NULL`, and:
# 
# 1) LLVMRemarkParserHasError() will return `1`.
# 
# 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error
#    message.
# 
# An error may occur if:
# 
# 1) An argument is invalid.
# 
# 2) There is a parsing error. This can occur on things like malformed YAML.
# 
# 3) There is a Remark semantic error. This can occur on well-formed files with
#    missing or extra fields.
# 
# Here is a quick example of the usage:
# 
# ```
# LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);
# LLVMRemarkEntryRef Remark = NULL;
# while ((Remark = LLVMRemarkParserGetNext(Parser))) {
#    // use Remark
#    LLVMRemarkEntryDispose(Remark); // Release memory.
# }
# bool HasError = LLVMRemarkParserHasError(Parser);
# LLVMRemarkParserDispose(Parser);
# ```
# 
# \since REMARKS_API_VERSION=0
cdef LLVMRemarkEntryRef LLVMRemarkParserGetNext(LLVMRemarkParserRef Parser):
    global _LLVMRemarkParserGetNext__funptr
    __init_symbol(&_LLVMRemarkParserGetNext__funptr,"LLVMRemarkParserGetNext")
    with nogil:
        return (<LLVMRemarkEntryRef (*)(LLVMRemarkParserRef) noexcept nogil> _LLVMRemarkParserGetNext__funptr)(Parser)


cdef void* _LLVMRemarkParserHasError__funptr = NULL
# 
# Returns `1` if the parser encountered an error while parsing the buffer.
# 
# \since REMARKS_API_VERSION=0
cdef int LLVMRemarkParserHasError(LLVMRemarkParserRef Parser):
    global _LLVMRemarkParserHasError__funptr
    __init_symbol(&_LLVMRemarkParserHasError__funptr,"LLVMRemarkParserHasError")
    with nogil:
        return (<int (*)(LLVMRemarkParserRef) noexcept nogil> _LLVMRemarkParserHasError__funptr)(Parser)


cdef void* _LLVMRemarkParserGetErrorMessage__funptr = NULL
# 
# Returns a null-terminated string containing an error message.
# 
# In case of no error, the result is `NULL`.
# 
# The memory of the string is bound to the lifetime of \p Parser. If
# LLVMRemarkParserDispose() is called, the memory of the string will be
# released.
# 
# \since REMARKS_API_VERSION=0
cdef const char * LLVMRemarkParserGetErrorMessage(LLVMRemarkParserRef Parser):
    global _LLVMRemarkParserGetErrorMessage__funptr
    __init_symbol(&_LLVMRemarkParserGetErrorMessage__funptr,"LLVMRemarkParserGetErrorMessage")
    with nogil:
        return (<const char * (*)(LLVMRemarkParserRef) noexcept nogil> _LLVMRemarkParserGetErrorMessage__funptr)(Parser)


cdef void* _LLVMRemarkParserDispose__funptr = NULL
# 
# Releases all the resources used by \p Parser.
# 
# \since REMARKS_API_VERSION=0
cdef void LLVMRemarkParserDispose(LLVMRemarkParserRef Parser):
    global _LLVMRemarkParserDispose__funptr
    __init_symbol(&_LLVMRemarkParserDispose__funptr,"LLVMRemarkParserDispose")
    with nogil:
        (<void (*)(LLVMRemarkParserRef) noexcept nogil> _LLVMRemarkParserDispose__funptr)(Parser)


cdef void* _LLVMRemarkVersion__funptr = NULL
# 
# Returns the version of the remarks library.
# 
# \since REMARKS_API_VERSION=0
cdef unsigned int LLVMRemarkVersion():
    global _LLVMRemarkVersion__funptr
    __init_symbol(&_LLVMRemarkVersion__funptr,"LLVMRemarkVersion")
    with nogil:
        return (<unsigned int (*)() noexcept nogil> _LLVMRemarkVersion__funptr)()
