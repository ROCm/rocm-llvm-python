# MIT License
# 
# Copyright (c) 2023 Advanced Micro Devices, Inc.
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    LLVMRemarkStringRef:
        alias of `~.LLVMRemarkOpaqueString`

    LLVMRemarkDebugLocRef:
        alias of `~.LLVMRemarkOpaqueDebugLoc`

    LLVMRemarkArgRef:
        alias of `~.LLVMRemarkOpaqueArg`

    LLVMRemarkEntryRef:
        alias of `~.LLVMRemarkOpaqueEntry`

    LLVMRemarkParserRef:
        alias of `~.LLVMRemarkOpaqueParser`

"""

import cython
import ctypes
import enum

from rocm.llvm.c.types import LLVMBool
from rocm.llvm.c.types import LLVMMemoryBufferRef
from rocm.llvm.c.types import LLVMContextRef
from rocm.llvm.c.types import LLVMModuleRef
from rocm.llvm.c.types import LLVMTypeRef
from rocm.llvm.c.types import LLVMValueRef
from rocm.llvm.c.types import LLVMBasicBlockRef
from rocm.llvm.c.types import LLVMMetadataRef
from rocm.llvm.c.types import LLVMNamedMDNodeRef
from rocm.llvm.c.types import LLVMValueMetadataEntry
from rocm.llvm.c.types import LLVMBuilderRef
from rocm.llvm.c.types import LLVMDIBuilderRef
from rocm.llvm.c.types import LLVMModuleProviderRef
from rocm.llvm.c.types import LLVMPassManagerRef
from rocm.llvm.c.types import LLVMPassRegistryRef
from rocm.llvm.c.types import LLVMUseRef
from rocm.llvm.c.types import LLVMAttributeRef
from rocm.llvm.c.types import LLVMDiagnosticInfoRef
from rocm.llvm.c.types import LLVMComdatRef
from rocm.llvm.c.types import LLVMModuleFlagEntry
from rocm.llvm.c.types import LLVMJITEventListenerRef
from rocm.llvm.c.types import LLVMBinaryRef

class _LLVMRemarkType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class LLVMRemarkType(_LLVMRemarkType__Base):
    """The type of the emitted remark.

    Attributes:
        LLVMRemarkTypeUnknown:
            (undocumented)
        LLVMRemarkTypePassed:
            (undocumented)
        LLVMRemarkTypeMissed:
            (undocumented)
        LLVMRemarkTypeAnalysis:
            (undocumented)
        LLVMRemarkTypeAnalysisFPCommute:
            (undocumented)
        LLVMRemarkTypeAnalysisAliasing:
            (undocumented)
        LLVMRemarkTypeFailure:
            (undocumented)
    """
    LLVMRemarkTypeUnknown = cremarks.LLVMRemarkTypeUnknown
    LLVMRemarkTypePassed = cremarks.LLVMRemarkTypePassed
    LLVMRemarkTypeMissed = cremarks.LLVMRemarkTypeMissed
    LLVMRemarkTypeAnalysis = cremarks.LLVMRemarkTypeAnalysis
    LLVMRemarkTypeAnalysisFPCommute = cremarks.LLVMRemarkTypeAnalysisFPCommute
    LLVMRemarkTypeAnalysisAliasing = cremarks.LLVMRemarkTypeAnalysisAliasing
    LLVMRemarkTypeFailure = cremarks.LLVMRemarkTypeFailure
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class LLVMRemarkOpaqueString:
    """Python wrapper for C type cremarks.LLVMRemarkOpaqueString.
    
    Python wrapper for C type cremarks.LLVMRemarkOpaqueString.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMRemarkOpaqueString from_ptr(cremarks.LLVMRemarkOpaqueString* ptr, bint owner=False):
        """Factory function to create ``LLVMRemarkOpaqueString`` objects from
        given ``cremarks.LLVMRemarkOpaqueString`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMRemarkOpaqueString wrapper = LLVMRemarkOpaqueString.__new__(LLVMRemarkOpaqueString)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMRemarkOpaqueString from_pyobj(object pyobj):
        """Derives a LLVMRemarkOpaqueString from a Python object.

        Derives a LLVMRemarkOpaqueString from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMRemarkOpaqueString`` reference, this method
        returns it directly. No new ``LLVMRemarkOpaqueString`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMRemarkOpaqueString`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMRemarkOpaqueString!
        """
        cdef LLVMRemarkOpaqueString wrapper = LLVMRemarkOpaqueString.__new__(LLVMRemarkOpaqueString)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMRemarkOpaqueString):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueString*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueString*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueString*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueString*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMRemarkOpaqueString object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMRemarkStringRef = LLVMRemarkOpaqueString

@cython.embedsignature(True)
def LLVMRemarkStringGetData(object String):
    r"""(No short description, might be part of a group.)

    Returns the buffer holding the string.

    Since:
        REMARKS_API_VERSION=0

    Args:
        String (`~.LLVMRemarkOpaqueString`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.bytes`
    """
    cdef const char * _LLVMRemarkStringGetData__retval = cremarks.LLVMRemarkStringGetData(
        LLVMRemarkOpaqueString.from_pyobj(String)._ptr)    # fully specified
    return (_LLVMRemarkStringGetData__retval,)


@cython.embedsignature(True)
def LLVMRemarkStringGetLen(object String):
    r"""(No short description, might be part of a group.)

    Returns the size of the string.

    Since:
        REMARKS_API_VERSION=0

    Args:
        String (`~.LLVMRemarkOpaqueString`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef unsigned int _LLVMRemarkStringGetLen__retval = cremarks.LLVMRemarkStringGetLen(
        LLVMRemarkOpaqueString.from_pyobj(String)._ptr)    # fully specified
    return (_LLVMRemarkStringGetLen__retval,)


cdef class LLVMRemarkOpaqueDebugLoc:
    """Python wrapper for C type cremarks.LLVMRemarkOpaqueDebugLoc.
    
    Python wrapper for C type cremarks.LLVMRemarkOpaqueDebugLoc.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMRemarkOpaqueDebugLoc from_ptr(cremarks.LLVMRemarkOpaqueDebugLoc* ptr, bint owner=False):
        """Factory function to create ``LLVMRemarkOpaqueDebugLoc`` objects from
        given ``cremarks.LLVMRemarkOpaqueDebugLoc`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMRemarkOpaqueDebugLoc wrapper = LLVMRemarkOpaqueDebugLoc.__new__(LLVMRemarkOpaqueDebugLoc)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMRemarkOpaqueDebugLoc from_pyobj(object pyobj):
        """Derives a LLVMRemarkOpaqueDebugLoc from a Python object.

        Derives a LLVMRemarkOpaqueDebugLoc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMRemarkOpaqueDebugLoc`` reference, this method
        returns it directly. No new ``LLVMRemarkOpaqueDebugLoc`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMRemarkOpaqueDebugLoc`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMRemarkOpaqueDebugLoc!
        """
        cdef LLVMRemarkOpaqueDebugLoc wrapper = LLVMRemarkOpaqueDebugLoc.__new__(LLVMRemarkOpaqueDebugLoc)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMRemarkOpaqueDebugLoc):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueDebugLoc*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueDebugLoc*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueDebugLoc*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueDebugLoc*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMRemarkOpaqueDebugLoc object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMRemarkDebugLocRef = LLVMRemarkOpaqueDebugLoc

@cython.embedsignature(True)
def LLVMRemarkDebugLocGetSourceFilePath(object DL):
    r"""(No short description, might be part of a group.)

    Return the path to the source file for a debug location.

    Since:
        REMARKS_API_VERSION=0

    Args:
        DL (`~.LLVMRemarkOpaqueDebugLoc`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkDebugLocGetSourceFilePath__retval = LLVMRemarkStringRef.from_value(cremarks.LLVMRemarkDebugLocGetSourceFilePath(
        LLVMRemarkOpaqueDebugLoc.from_pyobj(DL)._ptr))    # fully specified
    return (_LLVMRemarkDebugLocGetSourceFilePath__retval,)


@cython.embedsignature(True)
def LLVMRemarkDebugLocGetSourceLine(object DL):
    r"""(No short description, might be part of a group.)

    Return the line in the source file for a debug location.

    Since:
        REMARKS_API_VERSION=0

    Args:
        DL (`~.LLVMRemarkOpaqueDebugLoc`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef unsigned int _LLVMRemarkDebugLocGetSourceLine__retval = cremarks.LLVMRemarkDebugLocGetSourceLine(
        LLVMRemarkOpaqueDebugLoc.from_pyobj(DL)._ptr)    # fully specified
    return (_LLVMRemarkDebugLocGetSourceLine__retval,)


@cython.embedsignature(True)
def LLVMRemarkDebugLocGetSourceColumn(object DL):
    r"""(No short description, might be part of a group.)

    Return the column in the source file for a debug location.

    Since:
        REMARKS_API_VERSION=0

    Args:
        DL (`~.LLVMRemarkOpaqueDebugLoc`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef unsigned int _LLVMRemarkDebugLocGetSourceColumn__retval = cremarks.LLVMRemarkDebugLocGetSourceColumn(
        LLVMRemarkOpaqueDebugLoc.from_pyobj(DL)._ptr)    # fully specified
    return (_LLVMRemarkDebugLocGetSourceColumn__retval,)


cdef class LLVMRemarkOpaqueArg:
    """Python wrapper for C type cremarks.LLVMRemarkOpaqueArg.
    
    Python wrapper for C type cremarks.LLVMRemarkOpaqueArg.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMRemarkOpaqueArg from_ptr(cremarks.LLVMRemarkOpaqueArg* ptr, bint owner=False):
        """Factory function to create ``LLVMRemarkOpaqueArg`` objects from
        given ``cremarks.LLVMRemarkOpaqueArg`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMRemarkOpaqueArg wrapper = LLVMRemarkOpaqueArg.__new__(LLVMRemarkOpaqueArg)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMRemarkOpaqueArg from_pyobj(object pyobj):
        """Derives a LLVMRemarkOpaqueArg from a Python object.

        Derives a LLVMRemarkOpaqueArg from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMRemarkOpaqueArg`` reference, this method
        returns it directly. No new ``LLVMRemarkOpaqueArg`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMRemarkOpaqueArg`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMRemarkOpaqueArg!
        """
        cdef LLVMRemarkOpaqueArg wrapper = LLVMRemarkOpaqueArg.__new__(LLVMRemarkOpaqueArg)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMRemarkOpaqueArg):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueArg*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueArg*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueArg*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueArg*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMRemarkOpaqueArg object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMRemarkArgRef = LLVMRemarkOpaqueArg

@cython.embedsignature(True)
def LLVMRemarkArgGetKey(object Arg):
    r"""(No short description, might be part of a group.)

    Returns the key of an argument. The key defines what the value is, and the
    same key can appear multiple times in the list of arguments.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Arg (`~.LLVMRemarkOpaqueArg`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkArgGetKey__retval = LLVMRemarkStringRef.from_value(cremarks.LLVMRemarkArgGetKey(
        LLVMRemarkOpaqueArg.from_pyobj(Arg)._ptr))    # fully specified
    return (_LLVMRemarkArgGetKey__retval,)


@cython.embedsignature(True)
def LLVMRemarkArgGetValue(object Arg):
    r"""(No short description, might be part of a group.)

    Returns the value of an argument. This is a string that can contain newlines.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Arg (`~.LLVMRemarkOpaqueArg`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkArgGetValue__retval = LLVMRemarkStringRef.from_value(cremarks.LLVMRemarkArgGetValue(
        LLVMRemarkOpaqueArg.from_pyobj(Arg)._ptr))    # fully specified
    return (_LLVMRemarkArgGetValue__retval,)


@cython.embedsignature(True)
def LLVMRemarkArgGetDebugLoc(object Arg):
    r"""(No short description, might be part of a group.)

    Returns the debug location that is attached to the value of this argument.

    If there is no debug location, the return value will be `NULL`.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Arg (`~.LLVMRemarkOpaqueArg`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkArgGetDebugLoc__retval = LLVMRemarkDebugLocRef.from_value(cremarks.LLVMRemarkArgGetDebugLoc(
        LLVMRemarkOpaqueArg.from_pyobj(Arg)._ptr))    # fully specified
    return (_LLVMRemarkArgGetDebugLoc__retval,)


cdef class LLVMRemarkOpaqueEntry:
    """Python wrapper for C type cremarks.LLVMRemarkOpaqueEntry.
    
    Python wrapper for C type cremarks.LLVMRemarkOpaqueEntry.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMRemarkOpaqueEntry from_ptr(cremarks.LLVMRemarkOpaqueEntry* ptr, bint owner=False):
        """Factory function to create ``LLVMRemarkOpaqueEntry`` objects from
        given ``cremarks.LLVMRemarkOpaqueEntry`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMRemarkOpaqueEntry wrapper = LLVMRemarkOpaqueEntry.__new__(LLVMRemarkOpaqueEntry)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMRemarkOpaqueEntry from_pyobj(object pyobj):
        """Derives a LLVMRemarkOpaqueEntry from a Python object.

        Derives a LLVMRemarkOpaqueEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMRemarkOpaqueEntry`` reference, this method
        returns it directly. No new ``LLVMRemarkOpaqueEntry`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMRemarkOpaqueEntry`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMRemarkOpaqueEntry!
        """
        cdef LLVMRemarkOpaqueEntry wrapper = LLVMRemarkOpaqueEntry.__new__(LLVMRemarkOpaqueEntry)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMRemarkOpaqueEntry):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueEntry*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueEntry*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueEntry*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueEntry*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMRemarkOpaqueEntry object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMRemarkEntryRef = LLVMRemarkOpaqueEntry

@cython.embedsignature(True)
def LLVMRemarkEntryDispose(object Remark):
    r"""(No short description, might be part of a group.)

    Free the resources used by the remark entry.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    cremarks.LLVMRemarkEntryDispose(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMRemarkEntryGetType(object Remark):
    r"""(No short description, might be part of a group.)

    The type of the remark. For example, it can allow users to only keep the
    missed optimizations from the compiler.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.LLVMRemarkType`
    """
    _LLVMRemarkEntryGetType__retval = LLVMRemarkType(cremarks.LLVMRemarkEntryGetType(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark)._ptr))    # fully specified
    return (_LLVMRemarkEntryGetType__retval,)


@cython.embedsignature(True)
def LLVMRemarkEntryGetPassName(object Remark):
    r"""(No short description, might be part of a group.)

    Get the name of the pass that emitted this remark.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkEntryGetPassName__retval = LLVMRemarkStringRef.from_value(cremarks.LLVMRemarkEntryGetPassName(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark)._ptr))    # fully specified
    return (_LLVMRemarkEntryGetPassName__retval,)


@cython.embedsignature(True)
def LLVMRemarkEntryGetRemarkName(object Remark):
    r"""(No short description, might be part of a group.)

    Get an identifier of the remark.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkEntryGetRemarkName__retval = LLVMRemarkStringRef.from_value(cremarks.LLVMRemarkEntryGetRemarkName(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark)._ptr))    # fully specified
    return (_LLVMRemarkEntryGetRemarkName__retval,)


@cython.embedsignature(True)
def LLVMRemarkEntryGetFunctionName(object Remark):
    r"""(No short description, might be part of a group.)

    Get the name of the function being processed when the remark was emitted.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkEntryGetFunctionName__retval = LLVMRemarkStringRef.from_value(cremarks.LLVMRemarkEntryGetFunctionName(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark)._ptr))    # fully specified
    return (_LLVMRemarkEntryGetFunctionName__retval,)


@cython.embedsignature(True)
def LLVMRemarkEntryGetDebugLoc(object Remark):
    r"""(No short description, might be part of a group.)

    Returns the debug location that is attached to this remark.

    If there is no debug location, the return value will be `NULL`.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkEntryGetDebugLoc__retval = LLVMRemarkDebugLocRef.from_value(cremarks.LLVMRemarkEntryGetDebugLoc(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark)._ptr))    # fully specified
    return (_LLVMRemarkEntryGetDebugLoc__retval,)


@cython.embedsignature(True)
def LLVMRemarkEntryGetHotness(object Remark):
    r"""(No short description, might be part of a group.)

    Return the hotness of the remark.

    A hotness of `0` means this value is not set.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef unsigned long _LLVMRemarkEntryGetHotness__retval = cremarks.LLVMRemarkEntryGetHotness(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark)._ptr)    # fully specified
    return (_LLVMRemarkEntryGetHotness__retval,)


@cython.embedsignature(True)
def LLVMRemarkEntryGetNumArgs(object Remark):
    r"""(No short description, might be part of a group.)

    The number of arguments the remark holds.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef unsigned int _LLVMRemarkEntryGetNumArgs__retval = cremarks.LLVMRemarkEntryGetNumArgs(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark)._ptr)    # fully specified
    return (_LLVMRemarkEntryGetNumArgs__retval,)


@cython.embedsignature(True)
def LLVMRemarkEntryGetFirstArg(object Remark):
    r"""(No short description, might be part of a group.)

    Get a new iterator to iterate over a remark's argument.

    If there are no arguments in ``Remark,`` the return value will be `NULL`.

    The lifetime of the returned value is bound to the lifetime of ``Remark.``

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkEntryGetFirstArg__retval = LLVMRemarkArgRef.from_value(cremarks.LLVMRemarkEntryGetFirstArg(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark)._ptr))    # fully specified
    return (_LLVMRemarkEntryGetFirstArg__retval,)


@cython.embedsignature(True)
def LLVMRemarkEntryGetNextArg(object It, object Remark):
    r"""(No short description, might be part of a group.)

    Get the next argument in ``Remark`` from the position of ``It.``

    Returns `NULL` if there are no more arguments available.

    The lifetime of the returned value is bound to the lifetime of ``Remark.``

    Since:
        REMARKS_API_VERSION=0

    Args:
        It (`~.LLVMRemarkOpaqueArg`/`~.object`):
            (undocumented)

        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkEntryGetNextArg__retval = LLVMRemarkArgRef.from_value(cremarks.LLVMRemarkEntryGetNextArg(
        LLVMRemarkOpaqueArg.from_pyobj(It)._ptr,
        LLVMRemarkOpaqueEntry.from_pyobj(Remark)._ptr))    # fully specified
    return (_LLVMRemarkEntryGetNextArg__retval,)


cdef class LLVMRemarkOpaqueParser:
    """Python wrapper for C type cremarks.LLVMRemarkOpaqueParser.
    
    Python wrapper for C type cremarks.LLVMRemarkOpaqueParser.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:
      
      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple 
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:
      
      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMRemarkOpaqueParser from_ptr(cremarks.LLVMRemarkOpaqueParser* ptr, bint owner=False):
        """Factory function to create ``LLVMRemarkOpaqueParser`` objects from
        given ``cremarks.LLVMRemarkOpaqueParser`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMRemarkOpaqueParser wrapper = LLVMRemarkOpaqueParser.__new__(LLVMRemarkOpaqueParser)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMRemarkOpaqueParser from_pyobj(object pyobj):
        """Derives a LLVMRemarkOpaqueParser from a Python object.

        Derives a LLVMRemarkOpaqueParser from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMRemarkOpaqueParser`` reference, this method
        returns it directly. No new ``LLVMRemarkOpaqueParser`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMRemarkOpaqueParser`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMRemarkOpaqueParser!
        """
        cdef LLVMRemarkOpaqueParser wrapper = LLVMRemarkOpaqueParser.__new__(LLVMRemarkOpaqueParser)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMRemarkOpaqueParser):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueParser*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueParser*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cuda_array_interface != None:
            if not "data" in cuda_array_interface:
                raise ValueError("input object has '__cuda_array_interface__' attribute but the dict has no 'data' key")
            ptr_as_int = cuda_array_interface["data"][0]
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueParser*>cpython.long.PyLong_AsVoidPtr(ptr_as_int)
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <cremarks.LLVMRemarkOpaqueParser*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMRemarkOpaqueParser object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMRemarkParserRef = LLVMRemarkOpaqueParser

@cython.embedsignature(True)
def LLVMRemarkParserCreateYAML(object Buf, unsigned long Size):
    r"""(No short description, might be part of a group.)

    Creates a remark parser that can be used to parse the buffer located in \p
    Buf of size ``Size`` bytes.

    ``Buf`` cannot be `NULL`.

    This function should be paired with LLVMRemarkParserDispose() to avoid
    leaking resources.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Buf (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)

        Size (`~.int`):
            (undocumented)
    """
    _LLVMRemarkParserCreateYAML__retval = LLVMRemarkParserRef.from_value(cremarks.LLVMRemarkParserCreateYAML(
        <const void *>rocm.llvm._util.Pointer.from_pyobj(Buf)._ptr,Size))    # fully specified
    return (_LLVMRemarkParserCreateYAML__retval,)


@cython.embedsignature(True)
def LLVMRemarkParserCreateBitstream(object Buf, unsigned long Size):
    r"""(No short description, might be part of a group.)

    Creates a remark parser that can be used to parse the buffer located in \p
    Buf of size ``Size`` bytes.

    ``Buf`` cannot be `NULL`.

    This function should be paired with LLVMRemarkParserDispose() to avoid
    leaking resources.

    Since:
        REMARKS_API_VERSION=1

    Args:
        Buf (`~.rocm.llvm._util.Pointer`/`~.object`):
            (undocumented)

        Size (`~.int`):
            (undocumented)
    """
    _LLVMRemarkParserCreateBitstream__retval = LLVMRemarkParserRef.from_value(cremarks.LLVMRemarkParserCreateBitstream(
        <const void *>rocm.llvm._util.Pointer.from_pyobj(Buf)._ptr,Size))    # fully specified
    return (_LLVMRemarkParserCreateBitstream__retval,)


@cython.embedsignature(True)
def LLVMRemarkParserGetNext(object Parser):
    r"""(No short description, might be part of a group.)

    Returns the next remark in the file.

    The value pointed to by the return value needs to be disposed using a call to
    LLVMRemarkEntryDispose().

    All the entries in the returned value that are of LLVMRemarkStringRef type
    will become invalidated once a call to LLVMRemarkParserDispose is made.

    If the parser reaches the end of the buffer, the return value will be `NULL`.

    In the case of an error, the return value will be `NULL`, and:

    1) LLVMRemarkParserHasError() will return `1`.

    2) LLVMRemarkParserGetErrorMessage() will return a descriptive error
       message.

    An error may occur if:

    1) An argument is invalid.

    2) There is a parsing error. This can occur on things like malformed YAML.

    3) There is a Remark semantic error. This can occur on well-formed files with
       missing or extra fields.

    Here is a quick example of the usage:

    ```
    LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);
    LLVMRemarkEntryRef Remark = NULL;
    while ((Remark = LLVMRemarkParserGetNext(Parser))) {
       // use Remark
       LLVMRemarkEntryDispose(Remark); // Release memory.
    }
    bool HasError = LLVMRemarkParserHasError(Parser);
    LLVMRemarkParserDispose(Parser);
    ```

    Since:
        REMARKS_API_VERSION=0

    Args:
        Parser (`~.LLVMRemarkOpaqueParser`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkParserGetNext__retval = LLVMRemarkEntryRef.from_value(cremarks.LLVMRemarkParserGetNext(
        LLVMRemarkOpaqueParser.from_pyobj(Parser)._ptr))    # fully specified
    return (_LLVMRemarkParserGetNext__retval,)


@cython.embedsignature(True)
def LLVMRemarkParserHasError(object Parser):
    r"""(No short description, might be part of a group.)

    Returns `1` if the parser encountered an error while parsing the buffer.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Parser (`~.LLVMRemarkOpaqueParser`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef int _LLVMRemarkParserHasError__retval = cremarks.LLVMRemarkParserHasError(
        LLVMRemarkOpaqueParser.from_pyobj(Parser)._ptr)    # fully specified
    return (_LLVMRemarkParserHasError__retval,)


@cython.embedsignature(True)
def LLVMRemarkParserGetErrorMessage(object Parser):
    r"""(No short description, might be part of a group.)

    Returns a null-terminated string containing an error message.

    In case of no error, the result is `NULL`.

    The memory of the string is bound to the lifetime of ``Parser.`` If
    LLVMRemarkParserDispose() is called, the memory of the string will be
    released.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Parser (`~.LLVMRemarkOpaqueParser`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.bytes`
    """
    cdef const char * _LLVMRemarkParserGetErrorMessage__retval = cremarks.LLVMRemarkParserGetErrorMessage(
        LLVMRemarkOpaqueParser.from_pyobj(Parser)._ptr)    # fully specified
    return (_LLVMRemarkParserGetErrorMessage__retval,)


@cython.embedsignature(True)
def LLVMRemarkParserDispose(object Parser):
    r"""(No short description, might be part of a group.)

    Releases all the resources used by ``Parser.``

    Since:
        REMARKS_API_VERSION=0

    Args:
        Parser (`~.LLVMRemarkOpaqueParser`/`~.object`):
            (undocumented)
    """
    cremarks.LLVMRemarkParserDispose(
        LLVMRemarkOpaqueParser.from_pyobj(Parser)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMRemarkVersion():
    r"""(No short description, might be part of a group.)

    Returns the version of the remarks library.

    Since:
        REMARKS_API_VERSION=0

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef unsigned int _LLVMRemarkVersion__retval = cremarks.LLVMRemarkVersion()    # fully specified
    return (_LLVMRemarkVersion__retval,)

__all__ = [
    "_LLVMRemarkType__Base",
    "LLVMRemarkType",
    "LLVMRemarkOpaqueString",
    "LLVMRemarkStringRef",
    "LLVMRemarkStringGetData",
    "LLVMRemarkStringGetLen",
    "LLVMRemarkOpaqueDebugLoc",
    "LLVMRemarkDebugLocRef",
    "LLVMRemarkDebugLocGetSourceFilePath",
    "LLVMRemarkDebugLocGetSourceLine",
    "LLVMRemarkDebugLocGetSourceColumn",
    "LLVMRemarkOpaqueArg",
    "LLVMRemarkArgRef",
    "LLVMRemarkArgGetKey",
    "LLVMRemarkArgGetValue",
    "LLVMRemarkArgGetDebugLoc",
    "LLVMRemarkOpaqueEntry",
    "LLVMRemarkEntryRef",
    "LLVMRemarkEntryDispose",
    "LLVMRemarkEntryGetType",
    "LLVMRemarkEntryGetPassName",
    "LLVMRemarkEntryGetRemarkName",
    "LLVMRemarkEntryGetFunctionName",
    "LLVMRemarkEntryGetDebugLoc",
    "LLVMRemarkEntryGetHotness",
    "LLVMRemarkEntryGetNumArgs",
    "LLVMRemarkEntryGetFirstArg",
    "LLVMRemarkEntryGetNextArg",
    "LLVMRemarkOpaqueParser",
    "LLVMRemarkParserRef",
    "LLVMRemarkParserCreateYAML",
    "LLVMRemarkParserCreateBitstream",
    "LLVMRemarkParserGetNext",
    "LLVMRemarkParserHasError",
    "LLVMRemarkParserGetErrorMessage",
    "LLVMRemarkParserDispose",
    "LLVMRemarkVersion",
]