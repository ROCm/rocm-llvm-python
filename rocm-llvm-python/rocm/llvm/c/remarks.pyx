# MIT License
# 
# Copyright (c) 2023 Advanced Micro Devices, Inc.
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    LLVMRemarkStringRef:
        alias of `~.LLVMRemarkOpaqueString`

    LLVMRemarkDebugLocRef:
        alias of `~.LLVMRemarkOpaqueDebugLoc`

    LLVMRemarkArgRef:
        alias of `~.LLVMRemarkOpaqueArg`

    LLVMRemarkEntryRef:
        alias of `~.LLVMRemarkOpaqueEntry`

    LLVMRemarkParserRef:
        alias of `~.LLVMRemarkOpaqueParser`

"""

import cython
import ctypes
import enum

from rocm.llvm.c.types import LLVMMemoryBufferRef
from rocm.llvm.c.types import LLVMContextRef
from rocm.llvm.c.types import LLVMModuleRef
from rocm.llvm.c.types import LLVMTypeRef
from rocm.llvm.c.types import LLVMValueRef
from rocm.llvm.c.types import LLVMBasicBlockRef
from rocm.llvm.c.types import LLVMMetadataRef
from rocm.llvm.c.types import LLVMNamedMDNodeRef
from rocm.llvm.c.types import LLVMValueMetadataEntry
from rocm.llvm.c.types import LLVMBuilderRef
from rocm.llvm.c.types import LLVMDIBuilderRef
from rocm.llvm.c.types import LLVMModuleProviderRef
from rocm.llvm.c.types import LLVMPassManagerRef
from rocm.llvm.c.types import LLVMPassRegistryRef
from rocm.llvm.c.types import LLVMUseRef
from rocm.llvm.c.types import LLVMAttributeRef
from rocm.llvm.c.types import LLVMDiagnosticInfoRef
from rocm.llvm.c.types import LLVMComdatRef
from rocm.llvm.c.types import LLVMModuleFlagEntry
from rocm.llvm.c.types import LLVMJITEventListenerRef
from rocm.llvm.c.types import LLVMBinaryRef

class _LLVMRemarkType__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class LLVMRemarkType(_LLVMRemarkType__Base):
    """The type of the emitted remark.

    Attributes:
        LLVMRemarkTypeUnknown:
            (undocumented)
        LLVMRemarkTypePassed:
            (undocumented)
        LLVMRemarkTypeMissed:
            (undocumented)
        LLVMRemarkTypeAnalysis:
            (undocumented)
        LLVMRemarkTypeAnalysisFPCommute:
            (undocumented)
        LLVMRemarkTypeAnalysisAliasing:
            (undocumented)
        LLVMRemarkTypeFailure:
            (undocumented)
    """
    LLVMRemarkTypeUnknown = cremarks.LLVMRemarkTypeUnknown
    LLVMRemarkTypePassed = cremarks.LLVMRemarkTypePassed
    LLVMRemarkTypeMissed = cremarks.LLVMRemarkTypeMissed
    LLVMRemarkTypeAnalysis = cremarks.LLVMRemarkTypeAnalysis
    LLVMRemarkTypeAnalysisFPCommute = cremarks.LLVMRemarkTypeAnalysisFPCommute
    LLVMRemarkTypeAnalysisAliasing = cremarks.LLVMRemarkTypeAnalysisAliasing
    LLVMRemarkTypeFailure = cremarks.LLVMRemarkTypeFailure
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint 


cdef class LLVMRemarkOpaqueString(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cremarks.LLVMRemarkOpaqueString.
    
    Python wrapper for cdef class cremarks.LLVMRemarkOpaqueString.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef cremarks.LLVMRemarkOpaqueString* get_element_ptr(self):
        return <cremarks.LLVMRemarkOpaqueString*>self._ptr
        
    @staticmethod
    cdef LLVMRemarkOpaqueString from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMRemarkOpaqueString`` objects from
        given ``cremarks.LLVMRemarkOpaqueString`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMRemarkOpaqueString wrapper = LLVMRemarkOpaqueString.__new__(LLVMRemarkOpaqueString)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMRemarkOpaqueString from_pyobj(object pyobj):
        """Derives a LLVMRemarkOpaqueString from a Python object.

        Derives a LLVMRemarkOpaqueString from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMRemarkOpaqueString`` reference, this method
        returns it directly. No new ``LLVMRemarkOpaqueString`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMRemarkOpaqueString`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMRemarkOpaqueString!
        """
        cdef LLVMRemarkOpaqueString wrapper = LLVMRemarkOpaqueString.__new__(LLVMRemarkOpaqueString)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMRemarkOpaqueString):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMRemarkOpaqueString object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMRemarkStringRef = LLVMRemarkOpaqueString

@cython.embedsignature(True)
def LLVMRemarkStringGetData(object String):
    r"""(No short description, might be part of a group.)

    Returns the buffer holding the string.

    Since:
        REMARKS_API_VERSION=0

    Args:
        String (`~.LLVMRemarkOpaqueString`/`~.object`):
            (undocumented)

    Returns:
        `~.bytes`
    """
    _LLVMRemarkStringGetData__retval = rocm.llvm._util.types.CStr.from_ptr(<void*>cremarks.LLVMRemarkStringGetData(
        LLVMRemarkOpaqueString.from_pyobj(String).get_element_ptr()))
    return None if _LLVMRemarkStringGetData__retval._ptr == NULL else _LLVMRemarkStringGetData__retval


@cython.embedsignature(True)
def LLVMRemarkStringGetLen(object String):
    r"""(No short description, might be part of a group.)

    Returns the size of the string.

    Since:
        REMARKS_API_VERSION=0

    Args:
        String (`~.LLVMRemarkOpaqueString`/`~.object`):
            (undocumented)

    Returns:
        `~.int`
    """
    cdef unsigned int _LLVMRemarkStringGetLen__retval = cremarks.LLVMRemarkStringGetLen(
        LLVMRemarkOpaqueString.from_pyobj(String).get_element_ptr())
    return _LLVMRemarkStringGetLen__retval


cdef class LLVMRemarkOpaqueDebugLoc(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cremarks.LLVMRemarkOpaqueDebugLoc.
    
    Python wrapper for cdef class cremarks.LLVMRemarkOpaqueDebugLoc.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef cremarks.LLVMRemarkOpaqueDebugLoc* get_element_ptr(self):
        return <cremarks.LLVMRemarkOpaqueDebugLoc*>self._ptr
        
    @staticmethod
    cdef LLVMRemarkOpaqueDebugLoc from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMRemarkOpaqueDebugLoc`` objects from
        given ``cremarks.LLVMRemarkOpaqueDebugLoc`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMRemarkOpaqueDebugLoc wrapper = LLVMRemarkOpaqueDebugLoc.__new__(LLVMRemarkOpaqueDebugLoc)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMRemarkOpaqueDebugLoc from_pyobj(object pyobj):
        """Derives a LLVMRemarkOpaqueDebugLoc from a Python object.

        Derives a LLVMRemarkOpaqueDebugLoc from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMRemarkOpaqueDebugLoc`` reference, this method
        returns it directly. No new ``LLVMRemarkOpaqueDebugLoc`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMRemarkOpaqueDebugLoc`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMRemarkOpaqueDebugLoc!
        """
        cdef LLVMRemarkOpaqueDebugLoc wrapper = LLVMRemarkOpaqueDebugLoc.__new__(LLVMRemarkOpaqueDebugLoc)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMRemarkOpaqueDebugLoc):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMRemarkOpaqueDebugLoc object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMRemarkDebugLocRef = LLVMRemarkOpaqueDebugLoc

@cython.embedsignature(True)
def LLVMRemarkDebugLocGetSourceFilePath(object DL):
    r"""(No short description, might be part of a group.)

    Return the path to the source file for a debug location.

    Since:
        REMARKS_API_VERSION=0

    Args:
        DL (`~.LLVMRemarkOpaqueDebugLoc`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkDebugLocGetSourceFilePath__retval = LLVMRemarkOpaqueString.from_ptr(cremarks.LLVMRemarkDebugLocGetSourceFilePath(
        LLVMRemarkOpaqueDebugLoc.from_pyobj(DL).get_element_ptr()))
    return None if _LLVMRemarkDebugLocGetSourceFilePath__retval._ptr == NULL else _LLVMRemarkDebugLocGetSourceFilePath__retval


@cython.embedsignature(True)
def LLVMRemarkDebugLocGetSourceLine(object DL):
    r"""(No short description, might be part of a group.)

    Return the line in the source file for a debug location.

    Since:
        REMARKS_API_VERSION=0

    Args:
        DL (`~.LLVMRemarkOpaqueDebugLoc`/`~.object`):
            (undocumented)

    Returns:
        `~.int`
    """
    cdef unsigned int _LLVMRemarkDebugLocGetSourceLine__retval = cremarks.LLVMRemarkDebugLocGetSourceLine(
        LLVMRemarkOpaqueDebugLoc.from_pyobj(DL).get_element_ptr())
    return _LLVMRemarkDebugLocGetSourceLine__retval


@cython.embedsignature(True)
def LLVMRemarkDebugLocGetSourceColumn(object DL):
    r"""(No short description, might be part of a group.)

    Return the column in the source file for a debug location.

    Since:
        REMARKS_API_VERSION=0

    Args:
        DL (`~.LLVMRemarkOpaqueDebugLoc`/`~.object`):
            (undocumented)

    Returns:
        `~.int`
    """
    cdef unsigned int _LLVMRemarkDebugLocGetSourceColumn__retval = cremarks.LLVMRemarkDebugLocGetSourceColumn(
        LLVMRemarkOpaqueDebugLoc.from_pyobj(DL).get_element_ptr())
    return _LLVMRemarkDebugLocGetSourceColumn__retval


cdef class LLVMRemarkOpaqueArg(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cremarks.LLVMRemarkOpaqueArg.
    
    Python wrapper for cdef class cremarks.LLVMRemarkOpaqueArg.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef cremarks.LLVMRemarkOpaqueArg* get_element_ptr(self):
        return <cremarks.LLVMRemarkOpaqueArg*>self._ptr
        
    @staticmethod
    cdef LLVMRemarkOpaqueArg from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMRemarkOpaqueArg`` objects from
        given ``cremarks.LLVMRemarkOpaqueArg`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMRemarkOpaqueArg wrapper = LLVMRemarkOpaqueArg.__new__(LLVMRemarkOpaqueArg)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMRemarkOpaqueArg from_pyobj(object pyobj):
        """Derives a LLVMRemarkOpaqueArg from a Python object.

        Derives a LLVMRemarkOpaqueArg from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMRemarkOpaqueArg`` reference, this method
        returns it directly. No new ``LLVMRemarkOpaqueArg`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMRemarkOpaqueArg`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMRemarkOpaqueArg!
        """
        cdef LLVMRemarkOpaqueArg wrapper = LLVMRemarkOpaqueArg.__new__(LLVMRemarkOpaqueArg)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMRemarkOpaqueArg):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMRemarkOpaqueArg object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMRemarkArgRef = LLVMRemarkOpaqueArg

@cython.embedsignature(True)
def LLVMRemarkArgGetKey(object Arg):
    r"""(No short description, might be part of a group.)

    Returns the key of an argument. The key defines what the value is, and the
    same key can appear multiple times in the list of arguments.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Arg (`~.LLVMRemarkOpaqueArg`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkArgGetKey__retval = LLVMRemarkOpaqueString.from_ptr(cremarks.LLVMRemarkArgGetKey(
        LLVMRemarkOpaqueArg.from_pyobj(Arg).get_element_ptr()))
    return None if _LLVMRemarkArgGetKey__retval._ptr == NULL else _LLVMRemarkArgGetKey__retval


@cython.embedsignature(True)
def LLVMRemarkArgGetValue(object Arg):
    r"""(No short description, might be part of a group.)

    Returns the value of an argument. This is a string that can contain newlines.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Arg (`~.LLVMRemarkOpaqueArg`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkArgGetValue__retval = LLVMRemarkOpaqueString.from_ptr(cremarks.LLVMRemarkArgGetValue(
        LLVMRemarkOpaqueArg.from_pyobj(Arg).get_element_ptr()))
    return None if _LLVMRemarkArgGetValue__retval._ptr == NULL else _LLVMRemarkArgGetValue__retval


@cython.embedsignature(True)
def LLVMRemarkArgGetDebugLoc(object Arg):
    r"""(No short description, might be part of a group.)

    Returns the debug location that is attached to the value of this argument.

    If there is no debug location, the return value will be `NULL`.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Arg (`~.LLVMRemarkOpaqueArg`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkArgGetDebugLoc__retval = LLVMRemarkOpaqueDebugLoc.from_ptr(cremarks.LLVMRemarkArgGetDebugLoc(
        LLVMRemarkOpaqueArg.from_pyobj(Arg).get_element_ptr()))
    return None if _LLVMRemarkArgGetDebugLoc__retval._ptr == NULL else _LLVMRemarkArgGetDebugLoc__retval


cdef class LLVMRemarkOpaqueEntry(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cremarks.LLVMRemarkOpaqueEntry.
    
    Python wrapper for cdef class cremarks.LLVMRemarkOpaqueEntry.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef cremarks.LLVMRemarkOpaqueEntry* get_element_ptr(self):
        return <cremarks.LLVMRemarkOpaqueEntry*>self._ptr
        
    @staticmethod
    cdef LLVMRemarkOpaqueEntry from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMRemarkOpaqueEntry`` objects from
        given ``cremarks.LLVMRemarkOpaqueEntry`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMRemarkOpaqueEntry wrapper = LLVMRemarkOpaqueEntry.__new__(LLVMRemarkOpaqueEntry)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMRemarkOpaqueEntry from_pyobj(object pyobj):
        """Derives a LLVMRemarkOpaqueEntry from a Python object.

        Derives a LLVMRemarkOpaqueEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMRemarkOpaqueEntry`` reference, this method
        returns it directly. No new ``LLVMRemarkOpaqueEntry`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMRemarkOpaqueEntry`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMRemarkOpaqueEntry!
        """
        cdef LLVMRemarkOpaqueEntry wrapper = LLVMRemarkOpaqueEntry.__new__(LLVMRemarkOpaqueEntry)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMRemarkOpaqueEntry):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMRemarkOpaqueEntry object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMRemarkEntryRef = LLVMRemarkOpaqueEntry

@cython.embedsignature(True)
def LLVMRemarkEntryDispose(object Remark):
    r"""(No short description, might be part of a group.)

    Free the resources used by the remark entry.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    cremarks.LLVMRemarkEntryDispose(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark).get_element_ptr())


@cython.embedsignature(True)
def LLVMRemarkEntryGetType(object Remark):
    r"""(No short description, might be part of a group.)

    The type of the remark. For example, it can allow users to only keep the
    missed optimizations from the compiler.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)

    Returns:
        `~.LLVMRemarkType`
    """
    _LLVMRemarkEntryGetType__retval = LLVMRemarkType(cremarks.LLVMRemarkEntryGetType(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark).get_element_ptr()))
    return _LLVMRemarkEntryGetType__retval


@cython.embedsignature(True)
def LLVMRemarkEntryGetPassName(object Remark):
    r"""(No short description, might be part of a group.)

    Get the name of the pass that emitted this remark.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkEntryGetPassName__retval = LLVMRemarkOpaqueString.from_ptr(cremarks.LLVMRemarkEntryGetPassName(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark).get_element_ptr()))
    return None if _LLVMRemarkEntryGetPassName__retval._ptr == NULL else _LLVMRemarkEntryGetPassName__retval


@cython.embedsignature(True)
def LLVMRemarkEntryGetRemarkName(object Remark):
    r"""(No short description, might be part of a group.)

    Get an identifier of the remark.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkEntryGetRemarkName__retval = LLVMRemarkOpaqueString.from_ptr(cremarks.LLVMRemarkEntryGetRemarkName(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark).get_element_ptr()))
    return None if _LLVMRemarkEntryGetRemarkName__retval._ptr == NULL else _LLVMRemarkEntryGetRemarkName__retval


@cython.embedsignature(True)
def LLVMRemarkEntryGetFunctionName(object Remark):
    r"""(No short description, might be part of a group.)

    Get the name of the function being processed when the remark was emitted.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkEntryGetFunctionName__retval = LLVMRemarkOpaqueString.from_ptr(cremarks.LLVMRemarkEntryGetFunctionName(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark).get_element_ptr()))
    return None if _LLVMRemarkEntryGetFunctionName__retval._ptr == NULL else _LLVMRemarkEntryGetFunctionName__retval


@cython.embedsignature(True)
def LLVMRemarkEntryGetDebugLoc(object Remark):
    r"""(No short description, might be part of a group.)

    Returns the debug location that is attached to this remark.

    If there is no debug location, the return value will be `NULL`.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkEntryGetDebugLoc__retval = LLVMRemarkOpaqueDebugLoc.from_ptr(cremarks.LLVMRemarkEntryGetDebugLoc(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark).get_element_ptr()))
    return None if _LLVMRemarkEntryGetDebugLoc__retval._ptr == NULL else _LLVMRemarkEntryGetDebugLoc__retval


@cython.embedsignature(True)
def LLVMRemarkEntryGetHotness(object Remark):
    r"""(No short description, might be part of a group.)

    Return the hotness of the remark.

    A hotness of `0` means this value is not set.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)

    Returns:
        `~.int`
    """
    cdef unsigned long _LLVMRemarkEntryGetHotness__retval = cremarks.LLVMRemarkEntryGetHotness(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark).get_element_ptr())
    return _LLVMRemarkEntryGetHotness__retval


@cython.embedsignature(True)
def LLVMRemarkEntryGetNumArgs(object Remark):
    r"""(No short description, might be part of a group.)

    The number of arguments the remark holds.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)

    Returns:
        `~.int`
    """
    cdef unsigned int _LLVMRemarkEntryGetNumArgs__retval = cremarks.LLVMRemarkEntryGetNumArgs(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark).get_element_ptr())
    return _LLVMRemarkEntryGetNumArgs__retval


@cython.embedsignature(True)
def LLVMRemarkEntryGetFirstArg(object Remark):
    r"""(No short description, might be part of a group.)

    Get a new iterator to iterate over a remark's argument.

    If there are no arguments in ``Remark,`` the return value will be `NULL`.

    The lifetime of the returned value is bound to the lifetime of ``Remark.``

    Since:
        REMARKS_API_VERSION=0

    Args:
        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkEntryGetFirstArg__retval = LLVMRemarkOpaqueArg.from_ptr(cremarks.LLVMRemarkEntryGetFirstArg(
        LLVMRemarkOpaqueEntry.from_pyobj(Remark).get_element_ptr()))
    return None if _LLVMRemarkEntryGetFirstArg__retval._ptr == NULL else _LLVMRemarkEntryGetFirstArg__retval


@cython.embedsignature(True)
def LLVMRemarkEntryGetNextArg(object It, object Remark):
    r"""(No short description, might be part of a group.)

    Get the next argument in ``Remark`` from the position of ``It.``

    Returns `NULL` if there are no more arguments available.

    The lifetime of the returned value is bound to the lifetime of ``Remark.``

    Since:
        REMARKS_API_VERSION=0

    Args:
        It (`~.LLVMRemarkOpaqueArg`/`~.object`):
            (undocumented)

        Remark (`~.LLVMRemarkOpaqueEntry`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkEntryGetNextArg__retval = LLVMRemarkOpaqueArg.from_ptr(cremarks.LLVMRemarkEntryGetNextArg(
        LLVMRemarkOpaqueArg.from_pyobj(It).get_element_ptr(),
        LLVMRemarkOpaqueEntry.from_pyobj(Remark).get_element_ptr()))
    return None if _LLVMRemarkEntryGetNextArg__retval._ptr == NULL else _LLVMRemarkEntryGetNextArg__retval


cdef class LLVMRemarkOpaqueParser(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cremarks.LLVMRemarkOpaqueParser.
    
    Python wrapper for cdef class cremarks.LLVMRemarkOpaqueParser.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef cremarks.LLVMRemarkOpaqueParser* get_element_ptr(self):
        return <cremarks.LLVMRemarkOpaqueParser*>self._ptr
        
    @staticmethod
    cdef LLVMRemarkOpaqueParser from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMRemarkOpaqueParser`` objects from
        given ``cremarks.LLVMRemarkOpaqueParser`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMRemarkOpaqueParser wrapper = LLVMRemarkOpaqueParser.__new__(LLVMRemarkOpaqueParser)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMRemarkOpaqueParser from_pyobj(object pyobj):
        """Derives a LLVMRemarkOpaqueParser from a Python object.

        Derives a LLVMRemarkOpaqueParser from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMRemarkOpaqueParser`` reference, this method
        returns it directly. No new ``LLVMRemarkOpaqueParser`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMRemarkOpaqueParser`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMRemarkOpaqueParser!
        """
        cdef LLVMRemarkOpaqueParser wrapper = LLVMRemarkOpaqueParser.__new__(LLVMRemarkOpaqueParser)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMRemarkOpaqueParser):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMRemarkOpaqueParser object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMRemarkParserRef = LLVMRemarkOpaqueParser

@cython.embedsignature(True)
def LLVMRemarkParserCreateYAML(object Buf, unsigned long Size):
    r"""(No short description, might be part of a group.)

    Creates a remark parser that can be used to parse the buffer located in \p
    Buf of size ``Size`` bytes.

    ``Buf`` cannot be `NULL`.

    This function should be paired with LLVMRemarkParserDispose() to avoid
    leaking resources.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Buf (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        Size (`~.int`):
            (undocumented)
    """
    _LLVMRemarkParserCreateYAML__retval = LLVMRemarkOpaqueParser.from_ptr(cremarks.LLVMRemarkParserCreateYAML(
        <const void *>rocm.llvm._util.types.Pointer.from_pyobj(Buf)._ptr,Size))
    return None if _LLVMRemarkParserCreateYAML__retval._ptr == NULL else _LLVMRemarkParserCreateYAML__retval


@cython.embedsignature(True)
def LLVMRemarkParserCreateBitstream(object Buf, unsigned long Size):
    r"""(No short description, might be part of a group.)

    Creates a remark parser that can be used to parse the buffer located in \p
    Buf of size ``Size`` bytes.

    ``Buf`` cannot be `NULL`.

    This function should be paired with LLVMRemarkParserDispose() to avoid
    leaking resources.

    Since:
        REMARKS_API_VERSION=1

    Args:
        Buf (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        Size (`~.int`):
            (undocumented)
    """
    _LLVMRemarkParserCreateBitstream__retval = LLVMRemarkOpaqueParser.from_ptr(cremarks.LLVMRemarkParserCreateBitstream(
        <const void *>rocm.llvm._util.types.Pointer.from_pyobj(Buf)._ptr,Size))
    return None if _LLVMRemarkParserCreateBitstream__retval._ptr == NULL else _LLVMRemarkParserCreateBitstream__retval


@cython.embedsignature(True)
def LLVMRemarkParserGetNext(object Parser):
    r"""(No short description, might be part of a group.)

    Returns the next remark in the file.

    The value pointed to by the return value needs to be disposed using a call to
    LLVMRemarkEntryDispose().

    All the entries in the returned value that are of LLVMRemarkStringRef type
    will become invalidated once a call to LLVMRemarkParserDispose is made.

    If the parser reaches the end of the buffer, the return value will be `NULL`.

    In the case of an error, the return value will be `NULL`, and:

    1) LLVMRemarkParserHasError() will return `1`.

    2) LLVMRemarkParserGetErrorMessage() will return a descriptive error
       message.

    An error may occur if:

    1) An argument is invalid.

    2) There is a parsing error. This can occur on things like malformed YAML.

    3) There is a Remark semantic error. This can occur on well-formed files with
       missing or extra fields.

    Here is a quick example of the usage:

    ```
    LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);
    LLVMRemarkEntryRef Remark = NULL;
    while ((Remark = LLVMRemarkParserGetNext(Parser))) {
       // use Remark
       LLVMRemarkEntryDispose(Remark); // Release memory.
    }
    bool HasError = LLVMRemarkParserHasError(Parser);
    LLVMRemarkParserDispose(Parser);
    ```

    Since:
        REMARKS_API_VERSION=0

    Args:
        Parser (`~.LLVMRemarkOpaqueParser`/`~.object`):
            (undocumented)
    """
    _LLVMRemarkParserGetNext__retval = LLVMRemarkOpaqueEntry.from_ptr(cremarks.LLVMRemarkParserGetNext(
        LLVMRemarkOpaqueParser.from_pyobj(Parser).get_element_ptr()))
    return None if _LLVMRemarkParserGetNext__retval._ptr == NULL else _LLVMRemarkParserGetNext__retval


@cython.embedsignature(True)
def LLVMRemarkParserHasError(object Parser):
    r"""(No short description, might be part of a group.)

    Returns `1` if the parser encountered an error while parsing the buffer.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Parser (`~.LLVMRemarkOpaqueParser`/`~.object`):
            (undocumented)

    Returns:
        `~.int`
    """
    cdef int _LLVMRemarkParserHasError__retval = cremarks.LLVMRemarkParserHasError(
        LLVMRemarkOpaqueParser.from_pyobj(Parser).get_element_ptr())
    return _LLVMRemarkParserHasError__retval


@cython.embedsignature(True)
def LLVMRemarkParserGetErrorMessage(object Parser):
    r"""(No short description, might be part of a group.)

    Returns a null-terminated string containing an error message.

    In case of no error, the result is `NULL`.

    The memory of the string is bound to the lifetime of ``Parser.`` If
    LLVMRemarkParserDispose() is called, the memory of the string will be
    released.

    Since:
        REMARKS_API_VERSION=0

    Args:
        Parser (`~.LLVMRemarkOpaqueParser`/`~.object`):
            (undocumented)

    Returns:
        `~.bytes`
    """
    _LLVMRemarkParserGetErrorMessage__retval = rocm.llvm._util.types.CStr.from_ptr(<void*>cremarks.LLVMRemarkParserGetErrorMessage(
        LLVMRemarkOpaqueParser.from_pyobj(Parser).get_element_ptr()))
    return None if _LLVMRemarkParserGetErrorMessage__retval._ptr == NULL else _LLVMRemarkParserGetErrorMessage__retval


@cython.embedsignature(True)
def LLVMRemarkParserDispose(object Parser):
    r"""(No short description, might be part of a group.)

    Releases all the resources used by ``Parser.``

    Since:
        REMARKS_API_VERSION=0

    Args:
        Parser (`~.LLVMRemarkOpaqueParser`/`~.object`):
            (undocumented)
    """
    cremarks.LLVMRemarkParserDispose(
        LLVMRemarkOpaqueParser.from_pyobj(Parser).get_element_ptr())


@cython.embedsignature(True)
def LLVMRemarkVersion():
    r"""(No short description, might be part of a group.)

    Returns the version of the remarks library.

    Since:
        REMARKS_API_VERSION=0

    Returns:
        `~.int`
    """
    cdef unsigned int _LLVMRemarkVersion__retval = cremarks.LLVMRemarkVersion()
    return _LLVMRemarkVersion__retval

__all__ = [
    "_LLVMRemarkType__Base",
    "LLVMRemarkType",
    "LLVMRemarkOpaqueString",
    "LLVMRemarkStringRef",
    "LLVMRemarkStringGetData",
    "LLVMRemarkStringGetLen",
    "LLVMRemarkOpaqueDebugLoc",
    "LLVMRemarkDebugLocRef",
    "LLVMRemarkDebugLocGetSourceFilePath",
    "LLVMRemarkDebugLocGetSourceLine",
    "LLVMRemarkDebugLocGetSourceColumn",
    "LLVMRemarkOpaqueArg",
    "LLVMRemarkArgRef",
    "LLVMRemarkArgGetKey",
    "LLVMRemarkArgGetValue",
    "LLVMRemarkArgGetDebugLoc",
    "LLVMRemarkOpaqueEntry",
    "LLVMRemarkEntryRef",
    "LLVMRemarkEntryDispose",
    "LLVMRemarkEntryGetType",
    "LLVMRemarkEntryGetPassName",
    "LLVMRemarkEntryGetRemarkName",
    "LLVMRemarkEntryGetFunctionName",
    "LLVMRemarkEntryGetDebugLoc",
    "LLVMRemarkEntryGetHotness",
    "LLVMRemarkEntryGetNumArgs",
    "LLVMRemarkEntryGetFirstArg",
    "LLVMRemarkEntryGetNextArg",
    "LLVMRemarkOpaqueParser",
    "LLVMRemarkParserRef",
    "LLVMRemarkParserCreateYAML",
    "LLVMRemarkParserCreateBitstream",
    "LLVMRemarkParserGetNext",
    "LLVMRemarkParserHasError",
    "LLVMRemarkParserGetErrorMessage",
    "LLVMRemarkParserDispose",
    "LLVMRemarkVersion",
]