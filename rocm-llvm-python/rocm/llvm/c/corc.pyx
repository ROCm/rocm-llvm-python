# MIT License
#
# Copyright (c) 2023-2024 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.

cimport rocm.llvm._util.posixloader as loader
cdef void* _lib_handle = NULL

DLL = b"librocmllvm.so"

cdef int __init() except 1 nogil:
    global DLL
    global _lib_handle
    cdef char* dll = NULL
    if _lib_handle == NULL:
        with gil:
            dll = DLL
        return loader.open_library(&_lib_handle,dll)
    return 0

cdef int __init_symbol(void** result, const char* name) except 1 nogil:
    global _lib_handle
    cdef int init_result = 0
    if _lib_handle == NULL:
        init_result = __init()
        if init_result > 0:
            return init_result
    if result[0] == NULL:
        return loader.load_symbol(result,_lib_handle, name)
    return 0


cdef void* _LLVMOrcExecutionSessionSetErrorReporter__funptr = NULL
# 
# Attach a custom error reporter function to the ExecutionSession.
# 
# The error reporter will be called to deliver failure notices that can not be
# directly reported to a caller. For example, failure to resolve symbols in
# the JIT linker is typically reported via the error reporter (callers
# requesting definitions from the JIT will typically be delivered a
# FailureToMaterialize error instead).
cdef void LLVMOrcExecutionSessionSetErrorReporter(LLVMOrcExecutionSessionRef ES,LLVMOrcErrorReporterFunction ReportError,void * Ctx):
    global _LLVMOrcExecutionSessionSetErrorReporter__funptr
    if __init_symbol(&_LLVMOrcExecutionSessionSetErrorReporter__funptr,"LLVMOrcExecutionSessionSetErrorReporter") > 0:
        pass
    (<void (*)(LLVMOrcExecutionSessionRef,LLVMOrcErrorReporterFunction,void *) noexcept nogil> _LLVMOrcExecutionSessionSetErrorReporter__funptr)(ES,ReportError,Ctx)


cdef void* _LLVMOrcExecutionSessionGetSymbolStringPool__funptr = NULL
# 
# Return a reference to the SymbolStringPool for an ExecutionSession.
# 
# Ownership of the pool remains with the ExecutionSession: The caller is
# not required to free the pool.
cdef LLVMOrcSymbolStringPoolRef LLVMOrcExecutionSessionGetSymbolStringPool(LLVMOrcExecutionSessionRef ES):
    global _LLVMOrcExecutionSessionGetSymbolStringPool__funptr
    if __init_symbol(&_LLVMOrcExecutionSessionGetSymbolStringPool__funptr,"LLVMOrcExecutionSessionGetSymbolStringPool") > 0:
        pass
    return (<LLVMOrcSymbolStringPoolRef (*)(LLVMOrcExecutionSessionRef) noexcept nogil> _LLVMOrcExecutionSessionGetSymbolStringPool__funptr)(ES)


cdef void* _LLVMOrcSymbolStringPoolClearDeadEntries__funptr = NULL
# 
# Clear all unreferenced symbol string pool entries.
# 
# This can be called at any time to release unused entries in the
# ExecutionSession's string pool. Since it locks the pool (preventing
# interning of any new strings) it is recommended that it only be called
# infrequently, ideally when the caller has reason to believe that some
# entries will have become unreferenced, e.g. after removing a module or
# closing a JITDylib.
cdef void LLVMOrcSymbolStringPoolClearDeadEntries(LLVMOrcSymbolStringPoolRef SSP):
    global _LLVMOrcSymbolStringPoolClearDeadEntries__funptr
    if __init_symbol(&_LLVMOrcSymbolStringPoolClearDeadEntries__funptr,"LLVMOrcSymbolStringPoolClearDeadEntries") > 0:
        pass
    (<void (*)(LLVMOrcSymbolStringPoolRef) noexcept nogil> _LLVMOrcSymbolStringPoolClearDeadEntries__funptr)(SSP)


cdef void* _LLVMOrcExecutionSessionIntern__funptr = NULL
# 
# Intern a string in the ExecutionSession's SymbolStringPool and return a
# reference to it. This increments the ref-count of the pool entry, and the
# returned value should be released once the client is done with it by
# calling LLVMOrReleaseSymbolStringPoolEntry.
# 
# Since strings are uniqued within the SymbolStringPool
# LLVMOrcSymbolStringPoolEntryRefs can be compared by value to test string
# equality.
# 
# Note that this function does not perform linker-mangling on the string.
cdef LLVMOrcSymbolStringPoolEntryRef LLVMOrcExecutionSessionIntern(LLVMOrcExecutionSessionRef ES,const char * Name):
    global _LLVMOrcExecutionSessionIntern__funptr
    if __init_symbol(&_LLVMOrcExecutionSessionIntern__funptr,"LLVMOrcExecutionSessionIntern") > 0:
        pass
    return (<LLVMOrcSymbolStringPoolEntryRef (*)(LLVMOrcExecutionSessionRef,const char *) noexcept nogil> _LLVMOrcExecutionSessionIntern__funptr)(ES,Name)


cdef void* _LLVMOrcExecutionSessionLookup__funptr = NULL
# 
# Look up symbols in an execution session.
# 
# This is a wrapper around the general ExecutionSession::lookup function.
# 
# The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags)
# pairs that describe the search order. The JITDylibs will be searched in the
# given order to try to find the symbols in the Symbols argument.
# 
# The Symbols argument should contain a null-terminated array of
# (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be
# searched for. This function takes ownership of the elements of the Symbols
# array. The Name fields of the Symbols elements are taken to have been
# retained by the client for this function. The client should *not* release the
# Name fields, but are still responsible for destroying the array itself.
# 
# The HandleResult function will be called once all searched for symbols have
# been found, or an error occurs. The HandleResult function will be passed an
# LLVMErrorRef indicating success or failure, and (on success) a
# null-terminated LLVMOrcCSymbolMapPairs array containing the function result,
# and the Ctx value passed to the lookup function.
# 
# The client is fully responsible for managing the lifetime of the Ctx object.
# A common idiom is to allocate the context prior to the lookup and deallocate
# it in the handler.
# 
# THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!
cdef void LLVMOrcExecutionSessionLookup(LLVMOrcExecutionSessionRef ES,LLVMOrcLookupKind K,LLVMOrcCJITDylibSearchOrder SearchOrder,unsigned long SearchOrderSize,LLVMOrcCLookupSet Symbols,unsigned long SymbolsSize,LLVMOrcExecutionSessionLookupHandleResultFunction HandleResult,void * Ctx):
    global _LLVMOrcExecutionSessionLookup__funptr
    if __init_symbol(&_LLVMOrcExecutionSessionLookup__funptr,"LLVMOrcExecutionSessionLookup") > 0:
        pass
    (<void (*)(LLVMOrcExecutionSessionRef,LLVMOrcLookupKind,LLVMOrcCJITDylibSearchOrder,unsigned long,LLVMOrcCLookupSet,unsigned long,LLVMOrcExecutionSessionLookupHandleResultFunction,void *) noexcept nogil> _LLVMOrcExecutionSessionLookup__funptr)(ES,K,SearchOrder,SearchOrderSize,Symbols,SymbolsSize,HandleResult,Ctx)


cdef void* _LLVMOrcRetainSymbolStringPoolEntry__funptr = NULL
# 
# Increments the ref-count for a SymbolStringPool entry.
cdef void LLVMOrcRetainSymbolStringPoolEntry(LLVMOrcSymbolStringPoolEntryRef S):
    global _LLVMOrcRetainSymbolStringPoolEntry__funptr
    if __init_symbol(&_LLVMOrcRetainSymbolStringPoolEntry__funptr,"LLVMOrcRetainSymbolStringPoolEntry") > 0:
        pass
    (<void (*)(LLVMOrcSymbolStringPoolEntryRef) noexcept nogil> _LLVMOrcRetainSymbolStringPoolEntry__funptr)(S)


cdef void* _LLVMOrcReleaseSymbolStringPoolEntry__funptr = NULL
# 
# Reduces the ref-count for of a SymbolStringPool entry.
cdef void LLVMOrcReleaseSymbolStringPoolEntry(LLVMOrcSymbolStringPoolEntryRef S):
    global _LLVMOrcReleaseSymbolStringPoolEntry__funptr
    if __init_symbol(&_LLVMOrcReleaseSymbolStringPoolEntry__funptr,"LLVMOrcReleaseSymbolStringPoolEntry") > 0:
        pass
    (<void (*)(LLVMOrcSymbolStringPoolEntryRef) noexcept nogil> _LLVMOrcReleaseSymbolStringPoolEntry__funptr)(S)


cdef void* _LLVMOrcSymbolStringPoolEntryStr__funptr = NULL
# 
# Return the c-string for the given symbol. This string will remain valid until
# the entry is freed (once all LLVMOrcSymbolStringPoolEntryRefs have been
# released).
cdef const char * LLVMOrcSymbolStringPoolEntryStr(LLVMOrcSymbolStringPoolEntryRef S):
    global _LLVMOrcSymbolStringPoolEntryStr__funptr
    if __init_symbol(&_LLVMOrcSymbolStringPoolEntryStr__funptr,"LLVMOrcSymbolStringPoolEntryStr") > 0:
        pass
    return (<const char * (*)(LLVMOrcSymbolStringPoolEntryRef) noexcept nogil> _LLVMOrcSymbolStringPoolEntryStr__funptr)(S)


cdef void* _LLVMOrcReleaseResourceTracker__funptr = NULL
# 
# Reduces the ref-count of a ResourceTracker.
cdef void LLVMOrcReleaseResourceTracker(LLVMOrcResourceTrackerRef RT):
    global _LLVMOrcReleaseResourceTracker__funptr
    if __init_symbol(&_LLVMOrcReleaseResourceTracker__funptr,"LLVMOrcReleaseResourceTracker") > 0:
        pass
    (<void (*)(LLVMOrcResourceTrackerRef) noexcept nogil> _LLVMOrcReleaseResourceTracker__funptr)(RT)


cdef void* _LLVMOrcResourceTrackerTransferTo__funptr = NULL
# 
# Transfers tracking of all resources associated with resource tracker SrcRT
# to resource tracker DstRT.
cdef void LLVMOrcResourceTrackerTransferTo(LLVMOrcResourceTrackerRef SrcRT,LLVMOrcResourceTrackerRef DstRT):
    global _LLVMOrcResourceTrackerTransferTo__funptr
    if __init_symbol(&_LLVMOrcResourceTrackerTransferTo__funptr,"LLVMOrcResourceTrackerTransferTo") > 0:
        pass
    (<void (*)(LLVMOrcResourceTrackerRef,LLVMOrcResourceTrackerRef) noexcept nogil> _LLVMOrcResourceTrackerTransferTo__funptr)(SrcRT,DstRT)


cdef void* _LLVMOrcResourceTrackerRemove__funptr = NULL
# 
# Remove all resources associated with the given tracker. See
# ResourceTracker::remove().
cdef LLVMErrorRef LLVMOrcResourceTrackerRemove(LLVMOrcResourceTrackerRef RT):
    global _LLVMOrcResourceTrackerRemove__funptr
    if __init_symbol(&_LLVMOrcResourceTrackerRemove__funptr,"LLVMOrcResourceTrackerRemove") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcResourceTrackerRef) noexcept nogil> _LLVMOrcResourceTrackerRemove__funptr)(RT)


cdef void* _LLVMOrcDisposeDefinitionGenerator__funptr = NULL
# 
# Dispose of a JITDylib::DefinitionGenerator. This should only be called if
# ownership has not been passed to a JITDylib (e.g. because some error
# prevented the client from calling LLVMOrcJITDylibAddGenerator).
cdef void LLVMOrcDisposeDefinitionGenerator(LLVMOrcDefinitionGeneratorRef DG):
    global _LLVMOrcDisposeDefinitionGenerator__funptr
    if __init_symbol(&_LLVMOrcDisposeDefinitionGenerator__funptr,"LLVMOrcDisposeDefinitionGenerator") > 0:
        pass
    (<void (*)(LLVMOrcDefinitionGeneratorRef) noexcept nogil> _LLVMOrcDisposeDefinitionGenerator__funptr)(DG)


cdef void* _LLVMOrcDisposeMaterializationUnit__funptr = NULL
# 
# Dispose of a MaterializationUnit.
cdef void LLVMOrcDisposeMaterializationUnit(LLVMOrcMaterializationUnitRef MU):
    global _LLVMOrcDisposeMaterializationUnit__funptr
    if __init_symbol(&_LLVMOrcDisposeMaterializationUnit__funptr,"LLVMOrcDisposeMaterializationUnit") > 0:
        pass
    (<void (*)(LLVMOrcMaterializationUnitRef) noexcept nogil> _LLVMOrcDisposeMaterializationUnit__funptr)(MU)


cdef void* _LLVMOrcCreateCustomMaterializationUnit__funptr = NULL
# 
# Create a custom MaterializationUnit.
# 
# Name is a name for this MaterializationUnit to be used for identification
# and logging purposes (e.g. if this MaterializationUnit produces an
# object buffer then the name of that buffer will be derived from this name).
# 
# The Syms list contains the names and linkages of the symbols provided by this
# unit. This function takes ownership of the elements of the Syms array. The
# Name fields of the array elements are taken to have been retained for this
# function. The client should *not* release the elements of the array, but is
# still responsible for destroying the array itself.
# 
# The InitSym argument indicates whether or not this MaterializationUnit
# contains static initializers. If three are no static initializers (the common
# case) then this argument should be null. If there are static initializers
# then InitSym should be set to a unique name that also appears in the Syms
# list with the LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly flag
# set. This function takes ownership of the InitSym, which should have been
# retained twice on behalf of this function: once for the Syms entry and once
# for InitSym. If clients wish to use the InitSym value after this function
# returns they must retain it once more for themselves.
# 
# If any of the symbols in the Syms list is looked up then the Materialize
# function will be called.
# 
# If any of the symbols in the Syms list is overridden then the Discard
# function will be called.
# 
# The caller owns the underling MaterializationUnit and is responsible for
# either passing it to a JITDylib (via LLVMOrcJITDylibDefine) or disposing
# of it by calling LLVMOrcDisposeMaterializationUnit.
cdef LLVMOrcMaterializationUnitRef LLVMOrcCreateCustomMaterializationUnit(const char * Name,void * Ctx,LLVMOrcCSymbolFlagsMapPairs Syms,unsigned long NumSyms,LLVMOrcSymbolStringPoolEntryRef InitSym,LLVMOrcMaterializationUnitMaterializeFunction Materialize,LLVMOrcMaterializationUnitDiscardFunction Discard,LLVMOrcMaterializationUnitDestroyFunction Destroy):
    global _LLVMOrcCreateCustomMaterializationUnit__funptr
    if __init_symbol(&_LLVMOrcCreateCustomMaterializationUnit__funptr,"LLVMOrcCreateCustomMaterializationUnit") > 0:
        pass
    return (<LLVMOrcMaterializationUnitRef (*)(const char *,void *,LLVMOrcCSymbolFlagsMapPairs,unsigned long,LLVMOrcSymbolStringPoolEntryRef,LLVMOrcMaterializationUnitMaterializeFunction,LLVMOrcMaterializationUnitDiscardFunction,LLVMOrcMaterializationUnitDestroyFunction) noexcept nogil> _LLVMOrcCreateCustomMaterializationUnit__funptr)(Name,Ctx,Syms,NumSyms,InitSym,Materialize,Discard,Destroy)


cdef void* _LLVMOrcAbsoluteSymbols__funptr = NULL
# 
# Create a MaterializationUnit to define the given symbols as pointing to
# the corresponding raw addresses.
# 
# This function takes ownership of the elements of the Syms array. The Name
# fields of the array elements are taken to have been retained for this
# function. This allows the following pattern...
# 
#   size_t NumPairs;
#   LLVMOrcCSymbolMapPairs Sym;
#   -- Build Syms array --
#   LLVMOrcMaterializationUnitRef MU =
#       LLVMOrcAbsoluteSymbols(Syms, NumPairs);
# 
# ... without requiring cleanup of the elements of the Sym array afterwards.
# 
# The client is still responsible for deleting the Sym array itself.
# 
# If a client wishes to reuse elements of the Sym array after this call they
# must explicitly retain each of the elements for themselves.
cdef LLVMOrcMaterializationUnitRef LLVMOrcAbsoluteSymbols(LLVMOrcCSymbolMapPairs Syms,unsigned long NumPairs):
    global _LLVMOrcAbsoluteSymbols__funptr
    if __init_symbol(&_LLVMOrcAbsoluteSymbols__funptr,"LLVMOrcAbsoluteSymbols") > 0:
        pass
    return (<LLVMOrcMaterializationUnitRef (*)(LLVMOrcCSymbolMapPairs,unsigned long) noexcept nogil> _LLVMOrcAbsoluteSymbols__funptr)(Syms,NumPairs)


cdef void* _LLVMOrcLazyReexports__funptr = NULL
# 
# Create a MaterializationUnit to define lazy re-expots. These are callable
# entry points that call through to the given symbols.
# 
# This function takes ownership of the CallableAliases array. The Name
# fields of the array elements are taken to have been retained for this
# function. This allows the following pattern...
# 
#   size_t NumPairs;
#   LLVMOrcCSymbolAliasMapPairs CallableAliases;
#   -- Build CallableAliases array --
#   LLVMOrcMaterializationUnitRef MU =
#      LLVMOrcLazyReexports(LCTM, ISM, JD, CallableAliases, NumPairs);
# 
# ... without requiring cleanup of the elements of the CallableAliases array afterwards.
# 
# The client is still responsible for deleting the CallableAliases array itself.
# 
# If a client wishes to reuse elements of the CallableAliases array after this call they
# must explicitly retain each of the elements for themselves.
cdef LLVMOrcMaterializationUnitRef LLVMOrcLazyReexports(LLVMOrcLazyCallThroughManagerRef LCTM,LLVMOrcIndirectStubsManagerRef ISM,LLVMOrcJITDylibRef SourceRef,LLVMOrcCSymbolAliasMapPairs CallableAliases,unsigned long NumPairs):
    global _LLVMOrcLazyReexports__funptr
    if __init_symbol(&_LLVMOrcLazyReexports__funptr,"LLVMOrcLazyReexports") > 0:
        pass
    return (<LLVMOrcMaterializationUnitRef (*)(LLVMOrcLazyCallThroughManagerRef,LLVMOrcIndirectStubsManagerRef,LLVMOrcJITDylibRef,LLVMOrcCSymbolAliasMapPairs,unsigned long) noexcept nogil> _LLVMOrcLazyReexports__funptr)(LCTM,ISM,SourceRef,CallableAliases,NumPairs)


cdef void* _LLVMOrcDisposeMaterializationResponsibility__funptr = NULL
# 
# Disposes of the passed MaterializationResponsibility object.
# 
# This should only be done after the symbols covered by the object have either
# been resolved and emitted (via
# LLVMOrcMaterializationResponsibilityNotifyResolved and
# LLVMOrcMaterializationResponsibilityNotifyEmitted) or failed (via
# LLVMOrcMaterializationResponsibilityFailMaterialization).
cdef void LLVMOrcDisposeMaterializationResponsibility(LLVMOrcMaterializationResponsibilityRef MR):
    global _LLVMOrcDisposeMaterializationResponsibility__funptr
    if __init_symbol(&_LLVMOrcDisposeMaterializationResponsibility__funptr,"LLVMOrcDisposeMaterializationResponsibility") > 0:
        pass
    (<void (*)(LLVMOrcMaterializationResponsibilityRef) noexcept nogil> _LLVMOrcDisposeMaterializationResponsibility__funptr)(MR)


cdef void* _LLVMOrcMaterializationResponsibilityGetTargetDylib__funptr = NULL
# 
# Returns the target JITDylib that these symbols are being materialized into.
cdef LLVMOrcJITDylibRef LLVMOrcMaterializationResponsibilityGetTargetDylib(LLVMOrcMaterializationResponsibilityRef MR):
    global _LLVMOrcMaterializationResponsibilityGetTargetDylib__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityGetTargetDylib__funptr,"LLVMOrcMaterializationResponsibilityGetTargetDylib") > 0:
        pass
    return (<LLVMOrcJITDylibRef (*)(LLVMOrcMaterializationResponsibilityRef) noexcept nogil> _LLVMOrcMaterializationResponsibilityGetTargetDylib__funptr)(MR)


cdef void* _LLVMOrcMaterializationResponsibilityGetExecutionSession__funptr = NULL
# 
# Returns the ExecutionSession for this MaterializationResponsibility.
cdef LLVMOrcExecutionSessionRef LLVMOrcMaterializationResponsibilityGetExecutionSession(LLVMOrcMaterializationResponsibilityRef MR):
    global _LLVMOrcMaterializationResponsibilityGetExecutionSession__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityGetExecutionSession__funptr,"LLVMOrcMaterializationResponsibilityGetExecutionSession") > 0:
        pass
    return (<LLVMOrcExecutionSessionRef (*)(LLVMOrcMaterializationResponsibilityRef) noexcept nogil> _LLVMOrcMaterializationResponsibilityGetExecutionSession__funptr)(MR)


cdef void* _LLVMOrcMaterializationResponsibilityGetSymbols__funptr = NULL
# 
# Returns the symbol flags map for this responsibility instance.
# 
# The length of the array is returned in NumPairs and the caller is responsible
# for the returned memory and needs to call LLVMOrcDisposeCSymbolFlagsMap.
# 
# To use the returned symbols beyond the livetime of the
# MaterializationResponsibility requires the caller to retain the symbols
# explicitly.
cdef LLVMOrcCSymbolFlagsMapPairs LLVMOrcMaterializationResponsibilityGetSymbols(LLVMOrcMaterializationResponsibilityRef MR,unsigned long * NumPairs):
    global _LLVMOrcMaterializationResponsibilityGetSymbols__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityGetSymbols__funptr,"LLVMOrcMaterializationResponsibilityGetSymbols") > 0:
        pass
    return (<LLVMOrcCSymbolFlagsMapPairs (*)(LLVMOrcMaterializationResponsibilityRef,unsigned long *) noexcept nogil> _LLVMOrcMaterializationResponsibilityGetSymbols__funptr)(MR,NumPairs)


cdef void* _LLVMOrcDisposeCSymbolFlagsMap__funptr = NULL
# 
# Disposes of the passed LLVMOrcCSymbolFlagsMap.
# 
# Does not release the entries themselves.
cdef void LLVMOrcDisposeCSymbolFlagsMap(LLVMOrcCSymbolFlagsMapPairs Pairs):
    global _LLVMOrcDisposeCSymbolFlagsMap__funptr
    if __init_symbol(&_LLVMOrcDisposeCSymbolFlagsMap__funptr,"LLVMOrcDisposeCSymbolFlagsMap") > 0:
        pass
    (<void (*)(LLVMOrcCSymbolFlagsMapPairs) noexcept nogil> _LLVMOrcDisposeCSymbolFlagsMap__funptr)(Pairs)


cdef void* _LLVMOrcMaterializationResponsibilityGetInitializerSymbol__funptr = NULL
# 
# Returns the initialization pseudo-symbol, if any. This symbol will also
# be present in the SymbolFlagsMap for this MaterializationResponsibility
# object.
# 
# The returned symbol is not retained over any mutating operation of the
# MaterializationResponsbility or beyond the lifetime thereof.
cdef LLVMOrcSymbolStringPoolEntryRef LLVMOrcMaterializationResponsibilityGetInitializerSymbol(LLVMOrcMaterializationResponsibilityRef MR):
    global _LLVMOrcMaterializationResponsibilityGetInitializerSymbol__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityGetInitializerSymbol__funptr,"LLVMOrcMaterializationResponsibilityGetInitializerSymbol") > 0:
        pass
    return (<LLVMOrcSymbolStringPoolEntryRef (*)(LLVMOrcMaterializationResponsibilityRef) noexcept nogil> _LLVMOrcMaterializationResponsibilityGetInitializerSymbol__funptr)(MR)


cdef void* _LLVMOrcMaterializationResponsibilityGetRequestedSymbols__funptr = NULL
# 
# Returns the names of any symbols covered by this
# MaterializationResponsibility object that have queries pending. This
# information can be used to return responsibility for unrequested symbols
# back to the JITDylib via the delegate method.
cdef LLVMOrcSymbolStringPoolEntryRef* LLVMOrcMaterializationResponsibilityGetRequestedSymbols(LLVMOrcMaterializationResponsibilityRef MR,unsigned long * NumSymbols):
    global _LLVMOrcMaterializationResponsibilityGetRequestedSymbols__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityGetRequestedSymbols__funptr,"LLVMOrcMaterializationResponsibilityGetRequestedSymbols") > 0:
        pass
    return (<LLVMOrcSymbolStringPoolEntryRef* (*)(LLVMOrcMaterializationResponsibilityRef,unsigned long *) noexcept nogil> _LLVMOrcMaterializationResponsibilityGetRequestedSymbols__funptr)(MR,NumSymbols)


cdef void* _LLVMOrcDisposeSymbols__funptr = NULL
# 
# Disposes of the passed LLVMOrcSymbolStringPoolEntryRef* .
# 
# Does not release the symbols themselves.
cdef void LLVMOrcDisposeSymbols(LLVMOrcSymbolStringPoolEntryRef* Symbols):
    global _LLVMOrcDisposeSymbols__funptr
    if __init_symbol(&_LLVMOrcDisposeSymbols__funptr,"LLVMOrcDisposeSymbols") > 0:
        pass
    (<void (*)(LLVMOrcSymbolStringPoolEntryRef*) noexcept nogil> _LLVMOrcDisposeSymbols__funptr)(Symbols)


cdef void* _LLVMOrcMaterializationResponsibilityNotifyResolved__funptr = NULL
# 
# Notifies the target JITDylib that the given symbols have been resolved.
# This will update the given symbols' addresses in the JITDylib, and notify
# any pending queries on the given symbols of their resolution. The given
# symbols must be ones covered by this MaterializationResponsibility
# instance. Individual calls to this method may resolve a subset of the
# symbols, but all symbols must have been resolved prior to calling emit.
# 
# This method will return an error if any symbols being resolved have been
# moved to the error state due to the failure of a dependency. If this
# method returns an error then clients should log it and call
# LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies
# have been registered for the symbols covered by this
# MaterializationResponsibiility then this method is guaranteed to return
# LLVMErrorSuccess.
cdef LLVMErrorRef LLVMOrcMaterializationResponsibilityNotifyResolved(LLVMOrcMaterializationResponsibilityRef MR,LLVMOrcCSymbolMapPairs Symbols,unsigned long NumPairs):
    global _LLVMOrcMaterializationResponsibilityNotifyResolved__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityNotifyResolved__funptr,"LLVMOrcMaterializationResponsibilityNotifyResolved") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcMaterializationResponsibilityRef,LLVMOrcCSymbolMapPairs,unsigned long) noexcept nogil> _LLVMOrcMaterializationResponsibilityNotifyResolved__funptr)(MR,Symbols,NumPairs)


cdef void* _LLVMOrcMaterializationResponsibilityNotifyEmitted__funptr = NULL
# 
# Notifies the target JITDylib (and any pending queries on that JITDylib)
# that all symbols covered by this MaterializationResponsibility instance
# have been emitted.
# 
# This method will return an error if any symbols being resolved have been
# moved to the error state due to the failure of a dependency. If this
# method returns an error then clients should log it and call
# LLVMOrcMaterializationResponsibilityFailMaterialization.
# If no dependencies have been registered for the symbols covered by this
# MaterializationResponsibiility then this method is guaranteed to return
# LLVMErrorSuccess.
cdef LLVMErrorRef LLVMOrcMaterializationResponsibilityNotifyEmitted(LLVMOrcMaterializationResponsibilityRef MR):
    global _LLVMOrcMaterializationResponsibilityNotifyEmitted__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityNotifyEmitted__funptr,"LLVMOrcMaterializationResponsibilityNotifyEmitted") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcMaterializationResponsibilityRef) noexcept nogil> _LLVMOrcMaterializationResponsibilityNotifyEmitted__funptr)(MR)


cdef void* _LLVMOrcMaterializationResponsibilityDefineMaterializing__funptr = NULL
# 
# Attempt to claim responsibility for new definitions. This method can be
# used to claim responsibility for symbols that are added to a
# materialization unit during the compilation process (e.g. literal pool
# symbols). Symbol linkage rules are the same as for symbols that are
# defined up front: duplicate strong definitions will result in errors.
# Duplicate weak definitions will be discarded (in which case they will
# not be added to this responsibility instance).
# 
# This method can be used by materialization units that want to add
# additional symbols at materialization time (e.g. stubs, compile
# callbacks, metadata)
cdef LLVMErrorRef LLVMOrcMaterializationResponsibilityDefineMaterializing(LLVMOrcMaterializationResponsibilityRef MR,LLVMOrcCSymbolFlagsMapPairs Pairs,unsigned long NumPairs):
    global _LLVMOrcMaterializationResponsibilityDefineMaterializing__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityDefineMaterializing__funptr,"LLVMOrcMaterializationResponsibilityDefineMaterializing") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcMaterializationResponsibilityRef,LLVMOrcCSymbolFlagsMapPairs,unsigned long) noexcept nogil> _LLVMOrcMaterializationResponsibilityDefineMaterializing__funptr)(MR,Pairs,NumPairs)


cdef void* _LLVMOrcMaterializationResponsibilityFailMaterialization__funptr = NULL
# 
# Notify all not-yet-emitted covered by this MaterializationResponsibility
# instance that an error has occurred.
# This will remove all symbols covered by this MaterializationResponsibilty
# from the target JITDylib, and send an error to any queries waiting on
# these symbols.
cdef void LLVMOrcMaterializationResponsibilityFailMaterialization(LLVMOrcMaterializationResponsibilityRef MR):
    global _LLVMOrcMaterializationResponsibilityFailMaterialization__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityFailMaterialization__funptr,"LLVMOrcMaterializationResponsibilityFailMaterialization") > 0:
        pass
    (<void (*)(LLVMOrcMaterializationResponsibilityRef) noexcept nogil> _LLVMOrcMaterializationResponsibilityFailMaterialization__funptr)(MR)


cdef void* _LLVMOrcMaterializationResponsibilityReplace__funptr = NULL
# 
# Transfers responsibility to the given MaterializationUnit for all
# symbols defined by that MaterializationUnit. This allows
# materializers to break up work based on run-time information (e.g.
# by introspecting which symbols have actually been looked up and
# materializing only those).
cdef LLVMErrorRef LLVMOrcMaterializationResponsibilityReplace(LLVMOrcMaterializationResponsibilityRef MR,LLVMOrcMaterializationUnitRef MU):
    global _LLVMOrcMaterializationResponsibilityReplace__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityReplace__funptr,"LLVMOrcMaterializationResponsibilityReplace") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcMaterializationResponsibilityRef,LLVMOrcMaterializationUnitRef) noexcept nogil> _LLVMOrcMaterializationResponsibilityReplace__funptr)(MR,MU)


cdef void* _LLVMOrcMaterializationResponsibilityDelegate__funptr = NULL
# 
# Delegates responsibility for the given symbols to the returned
# materialization responsibility. Useful for breaking up work between
# threads, or different kinds of materialization processes.
# 
# The caller retains responsibility of the the passed
# MaterializationResponsibility.
cdef LLVMErrorRef LLVMOrcMaterializationResponsibilityDelegate(LLVMOrcMaterializationResponsibilityRef MR,LLVMOrcSymbolStringPoolEntryRef* Symbols,unsigned long NumSymbols,LLVMOrcMaterializationResponsibilityRef* Result):
    global _LLVMOrcMaterializationResponsibilityDelegate__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityDelegate__funptr,"LLVMOrcMaterializationResponsibilityDelegate") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcMaterializationResponsibilityRef,LLVMOrcSymbolStringPoolEntryRef*,unsigned long,LLVMOrcMaterializationResponsibilityRef*) noexcept nogil> _LLVMOrcMaterializationResponsibilityDelegate__funptr)(MR,Symbols,NumSymbols,Result)


cdef void* _LLVMOrcMaterializationResponsibilityAddDependencies__funptr = NULL
# 
# Adds dependencies to a symbol that the MaterializationResponsibility is
# responsible for.
# 
# This function takes ownership of Dependencies struct. The Names
# array have been retained for this function. This allows the following
# pattern...
# 
#   LLVMOrcSymbolStringPoolEntryRef Names[] = {...};
#   LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}
#   LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,
# 1);
# 
# ... without requiring cleanup of the elements of the Names array afterwards.
# 
# The client is still responsible for deleting the Dependencies.Names array
# itself.
cdef void LLVMOrcMaterializationResponsibilityAddDependencies(LLVMOrcMaterializationResponsibilityRef MR,LLVMOrcSymbolStringPoolEntryRef Name,LLVMOrcCDependenceMapPairs Dependencies,unsigned long NumPairs):
    global _LLVMOrcMaterializationResponsibilityAddDependencies__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityAddDependencies__funptr,"LLVMOrcMaterializationResponsibilityAddDependencies") > 0:
        pass
    (<void (*)(LLVMOrcMaterializationResponsibilityRef,LLVMOrcSymbolStringPoolEntryRef,LLVMOrcCDependenceMapPairs,unsigned long) noexcept nogil> _LLVMOrcMaterializationResponsibilityAddDependencies__funptr)(MR,Name,Dependencies,NumPairs)


cdef void* _LLVMOrcMaterializationResponsibilityAddDependenciesForAll__funptr = NULL
# 
# Adds dependencies to all symbols that the MaterializationResponsibility is
# responsible for. See LLVMOrcMaterializationResponsibilityAddDependencies for
# notes about memory responsibility.
cdef void LLVMOrcMaterializationResponsibilityAddDependenciesForAll(LLVMOrcMaterializationResponsibilityRef MR,LLVMOrcCDependenceMapPairs Dependencies,unsigned long NumPairs):
    global _LLVMOrcMaterializationResponsibilityAddDependenciesForAll__funptr
    if __init_symbol(&_LLVMOrcMaterializationResponsibilityAddDependenciesForAll__funptr,"LLVMOrcMaterializationResponsibilityAddDependenciesForAll") > 0:
        pass
    (<void (*)(LLVMOrcMaterializationResponsibilityRef,LLVMOrcCDependenceMapPairs,unsigned long) noexcept nogil> _LLVMOrcMaterializationResponsibilityAddDependenciesForAll__funptr)(MR,Dependencies,NumPairs)


cdef void* _LLVMOrcExecutionSessionCreateBareJITDylib__funptr = NULL
# 
# Create a "bare" JITDylib.
# 
# The client is responsible for ensuring that the JITDylib's name is unique,
# e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.
# 
# This call does not install any library code or symbols into the newly
# created JITDylib. The client is responsible for all configuration.
cdef LLVMOrcJITDylibRef LLVMOrcExecutionSessionCreateBareJITDylib(LLVMOrcExecutionSessionRef ES,const char * Name):
    global _LLVMOrcExecutionSessionCreateBareJITDylib__funptr
    if __init_symbol(&_LLVMOrcExecutionSessionCreateBareJITDylib__funptr,"LLVMOrcExecutionSessionCreateBareJITDylib") > 0:
        pass
    return (<LLVMOrcJITDylibRef (*)(LLVMOrcExecutionSessionRef,const char *) noexcept nogil> _LLVMOrcExecutionSessionCreateBareJITDylib__funptr)(ES,Name)


cdef void* _LLVMOrcExecutionSessionCreateJITDylib__funptr = NULL
# 
# Create a JITDylib.
# 
# The client is responsible for ensuring that the JITDylib's name is unique,
# e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.
# 
# If a Platform is attached to the ExecutionSession then
# Platform::setupJITDylib will be called to install standard platform symbols
# (e.g. standard library interposes). If no Platform is installed then this
# call is equivalent to LLVMExecutionSessionRefCreateBareJITDylib and will
# always return success.
cdef LLVMErrorRef LLVMOrcExecutionSessionCreateJITDylib(LLVMOrcExecutionSessionRef ES,LLVMOrcJITDylibRef* Result,const char * Name):
    global _LLVMOrcExecutionSessionCreateJITDylib__funptr
    if __init_symbol(&_LLVMOrcExecutionSessionCreateJITDylib__funptr,"LLVMOrcExecutionSessionCreateJITDylib") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcExecutionSessionRef,LLVMOrcJITDylibRef*,const char *) noexcept nogil> _LLVMOrcExecutionSessionCreateJITDylib__funptr)(ES,Result,Name)


cdef void* _LLVMOrcExecutionSessionGetJITDylibByName__funptr = NULL
# 
# Returns the JITDylib with the given name, or NULL if no such JITDylib
# exists.
cdef LLVMOrcJITDylibRef LLVMOrcExecutionSessionGetJITDylibByName(LLVMOrcExecutionSessionRef ES,const char * Name):
    global _LLVMOrcExecutionSessionGetJITDylibByName__funptr
    if __init_symbol(&_LLVMOrcExecutionSessionGetJITDylibByName__funptr,"LLVMOrcExecutionSessionGetJITDylibByName") > 0:
        pass
    return (<LLVMOrcJITDylibRef (*)(LLVMOrcExecutionSessionRef,const char *) noexcept nogil> _LLVMOrcExecutionSessionGetJITDylibByName__funptr)(ES,Name)


cdef void* _LLVMOrcJITDylibCreateResourceTracker__funptr = NULL
# 
# Return a reference to a newly created resource tracker associated with JD.
# The tracker is returned with an initial ref-count of 1, and must be released
# with LLVMOrcReleaseResourceTracker when no longer needed.
cdef LLVMOrcResourceTrackerRef LLVMOrcJITDylibCreateResourceTracker(LLVMOrcJITDylibRef JD):
    global _LLVMOrcJITDylibCreateResourceTracker__funptr
    if __init_symbol(&_LLVMOrcJITDylibCreateResourceTracker__funptr,"LLVMOrcJITDylibCreateResourceTracker") > 0:
        pass
    return (<LLVMOrcResourceTrackerRef (*)(LLVMOrcJITDylibRef) noexcept nogil> _LLVMOrcJITDylibCreateResourceTracker__funptr)(JD)


cdef void* _LLVMOrcJITDylibGetDefaultResourceTracker__funptr = NULL
# 
# Return a reference to the default resource tracker for the given JITDylib.
# This operation will increase the retain count of the tracker: Clients should
# call LLVMOrcReleaseResourceTracker when the result is no longer needed.
cdef LLVMOrcResourceTrackerRef LLVMOrcJITDylibGetDefaultResourceTracker(LLVMOrcJITDylibRef JD):
    global _LLVMOrcJITDylibGetDefaultResourceTracker__funptr
    if __init_symbol(&_LLVMOrcJITDylibGetDefaultResourceTracker__funptr,"LLVMOrcJITDylibGetDefaultResourceTracker") > 0:
        pass
    return (<LLVMOrcResourceTrackerRef (*)(LLVMOrcJITDylibRef) noexcept nogil> _LLVMOrcJITDylibGetDefaultResourceTracker__funptr)(JD)


cdef void* _LLVMOrcJITDylibDefine__funptr = NULL
# 
# Add the given MaterializationUnit to the given JITDylib.
# 
# If this operation succeeds then JITDylib JD will take ownership of MU.
# If the operation fails then ownership remains with the caller who should
# call LLVMOrcDisposeMaterializationUnit to destroy it.
cdef LLVMErrorRef LLVMOrcJITDylibDefine(LLVMOrcJITDylibRef JD,LLVMOrcMaterializationUnitRef MU):
    global _LLVMOrcJITDylibDefine__funptr
    if __init_symbol(&_LLVMOrcJITDylibDefine__funptr,"LLVMOrcJITDylibDefine") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcJITDylibRef,LLVMOrcMaterializationUnitRef) noexcept nogil> _LLVMOrcJITDylibDefine__funptr)(JD,MU)


cdef void* _LLVMOrcJITDylibClear__funptr = NULL
# 
# Calls remove on all trackers associated with this JITDylib, see
# JITDylib::clear().
cdef LLVMErrorRef LLVMOrcJITDylibClear(LLVMOrcJITDylibRef JD):
    global _LLVMOrcJITDylibClear__funptr
    if __init_symbol(&_LLVMOrcJITDylibClear__funptr,"LLVMOrcJITDylibClear") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcJITDylibRef) noexcept nogil> _LLVMOrcJITDylibClear__funptr)(JD)


cdef void* _LLVMOrcJITDylibAddGenerator__funptr = NULL
# 
# Add a DefinitionGenerator to the given JITDylib.
# 
# The JITDylib will take ownership of the given generator: The client is no
# longer responsible for managing its memory.
cdef void LLVMOrcJITDylibAddGenerator(LLVMOrcJITDylibRef JD,LLVMOrcDefinitionGeneratorRef DG):
    global _LLVMOrcJITDylibAddGenerator__funptr
    if __init_symbol(&_LLVMOrcJITDylibAddGenerator__funptr,"LLVMOrcJITDylibAddGenerator") > 0:
        pass
    (<void (*)(LLVMOrcJITDylibRef,LLVMOrcDefinitionGeneratorRef) noexcept nogil> _LLVMOrcJITDylibAddGenerator__funptr)(JD,DG)


cdef void* _LLVMOrcCreateCustomCAPIDefinitionGenerator__funptr = NULL
# 
# Create a custom generator.
# 
# The F argument will be used to implement the DefinitionGenerator's
# tryToGenerate method (see
# LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction).
# 
# Ctx is a context object that will be passed to F. This argument is
# permitted to be null.
# 
# Dispose is the disposal function for Ctx. This argument is permitted to be
# null (in which case the client is responsible for the lifetime of Ctx).
cdef LLVMOrcDefinitionGeneratorRef LLVMOrcCreateCustomCAPIDefinitionGenerator(LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction F,void * Ctx,LLVMOrcDisposeCAPIDefinitionGeneratorFunction Dispose):
    global _LLVMOrcCreateCustomCAPIDefinitionGenerator__funptr
    if __init_symbol(&_LLVMOrcCreateCustomCAPIDefinitionGenerator__funptr,"LLVMOrcCreateCustomCAPIDefinitionGenerator") > 0:
        pass
    return (<LLVMOrcDefinitionGeneratorRef (*)(LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction,void *,LLVMOrcDisposeCAPIDefinitionGeneratorFunction) noexcept nogil> _LLVMOrcCreateCustomCAPIDefinitionGenerator__funptr)(F,Ctx,Dispose)


cdef void* _LLVMOrcLookupStateContinueLookup__funptr = NULL
# 
# Continue a lookup that was suspended in a generator (see
# LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction).
cdef void LLVMOrcLookupStateContinueLookup(LLVMOrcLookupStateRef S,LLVMErrorRef Err):
    global _LLVMOrcLookupStateContinueLookup__funptr
    if __init_symbol(&_LLVMOrcLookupStateContinueLookup__funptr,"LLVMOrcLookupStateContinueLookup") > 0:
        pass
    (<void (*)(LLVMOrcLookupStateRef,LLVMErrorRef) noexcept nogil> _LLVMOrcLookupStateContinueLookup__funptr)(S,Err)


cdef void* _LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess__funptr = NULL
# 
# Get a DynamicLibrarySearchGenerator that will reflect process symbols into
# the JITDylib. On success the resulting generator is owned by the client.
# Ownership is typically transferred by adding the instance to a JITDylib
# using LLVMOrcJITDylibAddGenerator,
# 
# The GlobalPrefix argument specifies the character that appears on the front
# of linker-mangled symbols for the target platform (e.g. '_' on MachO).
# If non-null, this character will be stripped from the start of all symbol
# strings before passing the remaining substring to dlsym.
# 
# The optional Filter and Ctx arguments can be used to supply a symbol name
# filter: Only symbols for which the filter returns true will be visible to
# JIT'd code. If the Filter argument is null then all process symbols will
# be visible to JIT'd code. Note that the symbol name passed to the Filter
# function is the full mangled symbol: The client is responsible for stripping
# the global prefix if present.
cdef LLVMErrorRef LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess(LLVMOrcDefinitionGeneratorRef* Result,char GlobalPrefx,LLVMOrcSymbolPredicate Filter,void * FilterCtx):
    global _LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess__funptr
    if __init_symbol(&_LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess__funptr,"LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcDefinitionGeneratorRef*,char,LLVMOrcSymbolPredicate,void *) noexcept nogil> _LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess__funptr)(Result,GlobalPrefx,Filter,FilterCtx)


cdef void* _LLVMOrcCreateDynamicLibrarySearchGeneratorForPath__funptr = NULL
# 
# Get a LLVMOrcCreateDynamicLibararySearchGeneratorForPath that will reflect
# library symbols into the JITDylib. On success the resulting generator is
# owned by the client. Ownership is typically transferred by adding the
# instance to a JITDylib using LLVMOrcJITDylibAddGenerator,
# 
# The GlobalPrefix argument specifies the character that appears on the front
# of linker-mangled symbols for the target platform (e.g. '_' on MachO).
# If non-null, this character will be stripped from the start of all symbol
# strings before passing the remaining substring to dlsym.
# 
# The optional Filter and Ctx arguments can be used to supply a symbol name
# filter: Only symbols for which the filter returns true will be visible to
# JIT'd code. If the Filter argument is null then all library symbols will
# be visible to JIT'd code. Note that the symbol name passed to the Filter
# function is the full mangled symbol: The client is responsible for stripping
# the global prefix if present.
# 
# THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!
#
cdef LLVMErrorRef LLVMOrcCreateDynamicLibrarySearchGeneratorForPath(LLVMOrcDefinitionGeneratorRef* Result,const char * FileName,char GlobalPrefix,LLVMOrcSymbolPredicate Filter,void * FilterCtx):
    global _LLVMOrcCreateDynamicLibrarySearchGeneratorForPath__funptr
    if __init_symbol(&_LLVMOrcCreateDynamicLibrarySearchGeneratorForPath__funptr,"LLVMOrcCreateDynamicLibrarySearchGeneratorForPath") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcDefinitionGeneratorRef*,const char *,char,LLVMOrcSymbolPredicate,void *) noexcept nogil> _LLVMOrcCreateDynamicLibrarySearchGeneratorForPath__funptr)(Result,FileName,GlobalPrefix,Filter,FilterCtx)


cdef void* _LLVMOrcCreateStaticLibrarySearchGeneratorForPath__funptr = NULL
# 
# Get a LLVMOrcCreateStaticLibrarySearchGeneratorForPath that will reflect
# static library symbols into the JITDylib. On success the resulting
# generator is owned by the client. Ownership is typically transferred by
# adding the instance to a JITDylib using LLVMOrcJITDylibAddGenerator,
# 
# Call with the optional TargetTriple argument will succeed if the file at
# the given path is a static library or a MachO universal binary containing a
# static library that is compatible with the given triple. Otherwise it will
# return an error.
# 
# THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!
#
cdef LLVMErrorRef LLVMOrcCreateStaticLibrarySearchGeneratorForPath(LLVMOrcDefinitionGeneratorRef* Result,LLVMOrcObjectLayerRef ObjLayer,const char * FileName,const char * TargetTriple):
    global _LLVMOrcCreateStaticLibrarySearchGeneratorForPath__funptr
    if __init_symbol(&_LLVMOrcCreateStaticLibrarySearchGeneratorForPath__funptr,"LLVMOrcCreateStaticLibrarySearchGeneratorForPath") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcDefinitionGeneratorRef*,LLVMOrcObjectLayerRef,const char *,const char *) noexcept nogil> _LLVMOrcCreateStaticLibrarySearchGeneratorForPath__funptr)(Result,ObjLayer,FileName,TargetTriple)


cdef void* _LLVMOrcCreateNewThreadSafeContext__funptr = NULL
# 
# Create a ThreadSafeContext containing a new LLVMContext.
# 
# Ownership of the underlying ThreadSafeContext data is shared: Clients
# can and should dispose of their ThreadSafeContext as soon as they no longer
# need to refer to it directly. Other references (e.g. from ThreadSafeModules)
# will keep the data alive as long as it is needed.
cdef LLVMOrcThreadSafeContextRef LLVMOrcCreateNewThreadSafeContext():
    global _LLVMOrcCreateNewThreadSafeContext__funptr
    if __init_symbol(&_LLVMOrcCreateNewThreadSafeContext__funptr,"LLVMOrcCreateNewThreadSafeContext") > 0:
        pass
    return (<LLVMOrcThreadSafeContextRef (*)() noexcept nogil> _LLVMOrcCreateNewThreadSafeContext__funptr)()


cdef void* _LLVMOrcThreadSafeContextGetContext__funptr = NULL
# 
# Get a reference to the wrapped LLVMContext.
cdef LLVMContextRef LLVMOrcThreadSafeContextGetContext(LLVMOrcThreadSafeContextRef TSCtx):
    global _LLVMOrcThreadSafeContextGetContext__funptr
    if __init_symbol(&_LLVMOrcThreadSafeContextGetContext__funptr,"LLVMOrcThreadSafeContextGetContext") > 0:
        pass
    return (<LLVMContextRef (*)(LLVMOrcThreadSafeContextRef) noexcept nogil> _LLVMOrcThreadSafeContextGetContext__funptr)(TSCtx)


cdef void* _LLVMOrcDisposeThreadSafeContext__funptr = NULL
# 
# Dispose of a ThreadSafeContext.
cdef void LLVMOrcDisposeThreadSafeContext(LLVMOrcThreadSafeContextRef TSCtx):
    global _LLVMOrcDisposeThreadSafeContext__funptr
    if __init_symbol(&_LLVMOrcDisposeThreadSafeContext__funptr,"LLVMOrcDisposeThreadSafeContext") > 0:
        pass
    (<void (*)(LLVMOrcThreadSafeContextRef) noexcept nogil> _LLVMOrcDisposeThreadSafeContext__funptr)(TSCtx)


cdef void* _LLVMOrcCreateNewThreadSafeModule__funptr = NULL
# 
# Create a ThreadSafeModule wrapper around the given LLVM module. This takes
# ownership of the M argument which should not be disposed of or referenced
# after this function returns.
# 
# Ownership of the ThreadSafeModule is unique: If it is transferred to the JIT
# (e.g. by LLVMOrcLLJITAddLLVMIRModule) then the client is no longer
# responsible for it. If it is not transferred to the JIT then the client
# should call LLVMOrcDisposeThreadSafeModule to dispose of it.
cdef LLVMOrcThreadSafeModuleRef LLVMOrcCreateNewThreadSafeModule(LLVMModuleRef M,LLVMOrcThreadSafeContextRef TSCtx):
    global _LLVMOrcCreateNewThreadSafeModule__funptr
    if __init_symbol(&_LLVMOrcCreateNewThreadSafeModule__funptr,"LLVMOrcCreateNewThreadSafeModule") > 0:
        pass
    return (<LLVMOrcThreadSafeModuleRef (*)(LLVMModuleRef,LLVMOrcThreadSafeContextRef) noexcept nogil> _LLVMOrcCreateNewThreadSafeModule__funptr)(M,TSCtx)


cdef void* _LLVMOrcDisposeThreadSafeModule__funptr = NULL
# 
# Dispose of a ThreadSafeModule. This should only be called if ownership has
# not been passed to LLJIT (e.g. because some error prevented the client from
# adding this to the JIT).
cdef void LLVMOrcDisposeThreadSafeModule(LLVMOrcThreadSafeModuleRef TSM):
    global _LLVMOrcDisposeThreadSafeModule__funptr
    if __init_symbol(&_LLVMOrcDisposeThreadSafeModule__funptr,"LLVMOrcDisposeThreadSafeModule") > 0:
        pass
    (<void (*)(LLVMOrcThreadSafeModuleRef) noexcept nogil> _LLVMOrcDisposeThreadSafeModule__funptr)(TSM)


cdef void* _LLVMOrcThreadSafeModuleWithModuleDo__funptr = NULL
# 
# Apply the given function to the module contained in this ThreadSafeModule.
cdef LLVMErrorRef LLVMOrcThreadSafeModuleWithModuleDo(LLVMOrcThreadSafeModuleRef TSM,LLVMOrcGenericIRModuleOperationFunction F,void * Ctx):
    global _LLVMOrcThreadSafeModuleWithModuleDo__funptr
    if __init_symbol(&_LLVMOrcThreadSafeModuleWithModuleDo__funptr,"LLVMOrcThreadSafeModuleWithModuleDo") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcThreadSafeModuleRef,LLVMOrcGenericIRModuleOperationFunction,void *) noexcept nogil> _LLVMOrcThreadSafeModuleWithModuleDo__funptr)(TSM,F,Ctx)


cdef void* _LLVMOrcJITTargetMachineBuilderDetectHost__funptr = NULL
# 
# Create a JITTargetMachineBuilder by detecting the host.
# 
# On success the client owns the resulting JITTargetMachineBuilder. It must be
# passed to a consuming operation (e.g.
# LLVMOrcLLJITBuilderSetJITTargetMachineBuilder) or disposed of by calling
# LLVMOrcDisposeJITTargetMachineBuilder.
cdef LLVMErrorRef LLVMOrcJITTargetMachineBuilderDetectHost(LLVMOrcJITTargetMachineBuilderRef* Result):
    global _LLVMOrcJITTargetMachineBuilderDetectHost__funptr
    if __init_symbol(&_LLVMOrcJITTargetMachineBuilderDetectHost__funptr,"LLVMOrcJITTargetMachineBuilderDetectHost") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcJITTargetMachineBuilderRef*) noexcept nogil> _LLVMOrcJITTargetMachineBuilderDetectHost__funptr)(Result)


cdef void* _LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine__funptr = NULL
# 
# Create a JITTargetMachineBuilder from the given TargetMachine template.
# 
# This operation takes ownership of the given TargetMachine and destroys it
# before returing. The resulting JITTargetMachineBuilder is owned by the client
# and must be passed to a consuming operation (e.g.
# LLVMOrcLLJITBuilderSetJITTargetMachineBuilder) or disposed of by calling
# LLVMOrcDisposeJITTargetMachineBuilder.
cdef LLVMOrcJITTargetMachineBuilderRef LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine(LLVMTargetMachineRef TM):
    global _LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine__funptr
    if __init_symbol(&_LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine__funptr,"LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine") > 0:
        pass
    return (<LLVMOrcJITTargetMachineBuilderRef (*)(LLVMTargetMachineRef) noexcept nogil> _LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine__funptr)(TM)


cdef void* _LLVMOrcDisposeJITTargetMachineBuilder__funptr = NULL
# 
# Dispose of a JITTargetMachineBuilder.
cdef void LLVMOrcDisposeJITTargetMachineBuilder(LLVMOrcJITTargetMachineBuilderRef JTMB):
    global _LLVMOrcDisposeJITTargetMachineBuilder__funptr
    if __init_symbol(&_LLVMOrcDisposeJITTargetMachineBuilder__funptr,"LLVMOrcDisposeJITTargetMachineBuilder") > 0:
        pass
    (<void (*)(LLVMOrcJITTargetMachineBuilderRef) noexcept nogil> _LLVMOrcDisposeJITTargetMachineBuilder__funptr)(JTMB)


cdef void* _LLVMOrcJITTargetMachineBuilderGetTargetTriple__funptr = NULL
# 
# Returns the target triple for the given JITTargetMachineBuilder as a string.
# 
# The caller owns the resulting string as must dispose of it by calling
# LLVMDisposeMessage
cdef char * LLVMOrcJITTargetMachineBuilderGetTargetTriple(LLVMOrcJITTargetMachineBuilderRef JTMB):
    global _LLVMOrcJITTargetMachineBuilderGetTargetTriple__funptr
    if __init_symbol(&_LLVMOrcJITTargetMachineBuilderGetTargetTriple__funptr,"LLVMOrcJITTargetMachineBuilderGetTargetTriple") > 0:
        pass
    return (<char * (*)(LLVMOrcJITTargetMachineBuilderRef) noexcept nogil> _LLVMOrcJITTargetMachineBuilderGetTargetTriple__funptr)(JTMB)


cdef void* _LLVMOrcJITTargetMachineBuilderSetTargetTriple__funptr = NULL
# 
# Sets the target triple for the given JITTargetMachineBuilder to the given
# string.
cdef void LLVMOrcJITTargetMachineBuilderSetTargetTriple(LLVMOrcJITTargetMachineBuilderRef JTMB,const char * TargetTriple):
    global _LLVMOrcJITTargetMachineBuilderSetTargetTriple__funptr
    if __init_symbol(&_LLVMOrcJITTargetMachineBuilderSetTargetTriple__funptr,"LLVMOrcJITTargetMachineBuilderSetTargetTriple") > 0:
        pass
    (<void (*)(LLVMOrcJITTargetMachineBuilderRef,const char *) noexcept nogil> _LLVMOrcJITTargetMachineBuilderSetTargetTriple__funptr)(JTMB,TargetTriple)


cdef void* _LLVMOrcObjectLayerAddObjectFile__funptr = NULL
# 
# Add an object to an ObjectLayer to the given JITDylib.
# 
# Adds a buffer representing an object file to the given JITDylib using the
# given ObjectLayer instance. This operation transfers ownership of the buffer
# to the ObjectLayer instance. The buffer should not be disposed of or
# referenced once this function returns.
# 
# Resources associated with the given object will be tracked by the given
# JITDylib's default ResourceTracker.
cdef LLVMErrorRef LLVMOrcObjectLayerAddObjectFile(LLVMOrcObjectLayerRef ObjLayer,LLVMOrcJITDylibRef JD,LLVMMemoryBufferRef ObjBuffer):
    global _LLVMOrcObjectLayerAddObjectFile__funptr
    if __init_symbol(&_LLVMOrcObjectLayerAddObjectFile__funptr,"LLVMOrcObjectLayerAddObjectFile") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcObjectLayerRef,LLVMOrcJITDylibRef,LLVMMemoryBufferRef) noexcept nogil> _LLVMOrcObjectLayerAddObjectFile__funptr)(ObjLayer,JD,ObjBuffer)


cdef void* _LLVMOrcObjectLayerAddObjectFileWithRT__funptr = NULL
# 
# Add an object to an ObjectLayer using the given ResourceTracker.
# 
# Adds a buffer representing an object file to the given ResourceTracker's
# JITDylib using the given ObjectLayer instance. This operation transfers
# ownership of the buffer to the ObjectLayer instance. The buffer should not
# be disposed of or referenced once this function returns.
# 
# Resources associated with the given object will be tracked by
# ResourceTracker RT.
cdef LLVMErrorRef LLVMOrcObjectLayerAddObjectFileWithRT(LLVMOrcObjectLayerRef ObjLayer,LLVMOrcResourceTrackerRef RT,LLVMMemoryBufferRef ObjBuffer):
    global _LLVMOrcObjectLayerAddObjectFileWithRT__funptr
    if __init_symbol(&_LLVMOrcObjectLayerAddObjectFileWithRT__funptr,"LLVMOrcObjectLayerAddObjectFileWithRT") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcObjectLayerRef,LLVMOrcResourceTrackerRef,LLVMMemoryBufferRef) noexcept nogil> _LLVMOrcObjectLayerAddObjectFileWithRT__funptr)(ObjLayer,RT,ObjBuffer)


cdef void* _LLVMOrcObjectLayerEmit__funptr = NULL
# 
# Emit an object buffer to an ObjectLayer.
# 
# Ownership of the responsibility object and object buffer pass to this
# function. The client is not responsible for cleanup.
cdef void LLVMOrcObjectLayerEmit(LLVMOrcObjectLayerRef ObjLayer,LLVMOrcMaterializationResponsibilityRef R,LLVMMemoryBufferRef ObjBuffer):
    global _LLVMOrcObjectLayerEmit__funptr
    if __init_symbol(&_LLVMOrcObjectLayerEmit__funptr,"LLVMOrcObjectLayerEmit") > 0:
        pass
    (<void (*)(LLVMOrcObjectLayerRef,LLVMOrcMaterializationResponsibilityRef,LLVMMemoryBufferRef) noexcept nogil> _LLVMOrcObjectLayerEmit__funptr)(ObjLayer,R,ObjBuffer)


cdef void* _LLVMOrcDisposeObjectLayer__funptr = NULL
# 
# Dispose of an ObjectLayer.
cdef void LLVMOrcDisposeObjectLayer(LLVMOrcObjectLayerRef ObjLayer):
    global _LLVMOrcDisposeObjectLayer__funptr
    if __init_symbol(&_LLVMOrcDisposeObjectLayer__funptr,"LLVMOrcDisposeObjectLayer") > 0:
        pass
    (<void (*)(LLVMOrcObjectLayerRef) noexcept nogil> _LLVMOrcDisposeObjectLayer__funptr)(ObjLayer)


cdef void* _LLVMOrcIRTransformLayerEmit__funptr = NULL
cdef void LLVMOrcIRTransformLayerEmit(LLVMOrcIRTransformLayerRef IRTransformLayer,LLVMOrcMaterializationResponsibilityRef MR,LLVMOrcThreadSafeModuleRef TSM):
    global _LLVMOrcIRTransformLayerEmit__funptr
    if __init_symbol(&_LLVMOrcIRTransformLayerEmit__funptr,"LLVMOrcIRTransformLayerEmit") > 0:
        pass
    (<void (*)(LLVMOrcIRTransformLayerRef,LLVMOrcMaterializationResponsibilityRef,LLVMOrcThreadSafeModuleRef) noexcept nogil> _LLVMOrcIRTransformLayerEmit__funptr)(IRTransformLayer,MR,TSM)


cdef void* _LLVMOrcIRTransformLayerSetTransform__funptr = NULL
# 
# Set the transform function of the provided transform layer, passing through a
# pointer to user provided context.
cdef void LLVMOrcIRTransformLayerSetTransform(LLVMOrcIRTransformLayerRef IRTransformLayer,LLVMOrcIRTransformLayerTransformFunction TransformFunction,void * Ctx):
    global _LLVMOrcIRTransformLayerSetTransform__funptr
    if __init_symbol(&_LLVMOrcIRTransformLayerSetTransform__funptr,"LLVMOrcIRTransformLayerSetTransform") > 0:
        pass
    (<void (*)(LLVMOrcIRTransformLayerRef,LLVMOrcIRTransformLayerTransformFunction,void *) noexcept nogil> _LLVMOrcIRTransformLayerSetTransform__funptr)(IRTransformLayer,TransformFunction,Ctx)


cdef void* _LLVMOrcObjectTransformLayerSetTransform__funptr = NULL
# 
# Set the transform function on an LLVMOrcObjectTransformLayer.
cdef void LLVMOrcObjectTransformLayerSetTransform(LLVMOrcObjectTransformLayerRef ObjTransformLayer,LLVMOrcObjectTransformLayerTransformFunction TransformFunction,void * Ctx):
    global _LLVMOrcObjectTransformLayerSetTransform__funptr
    if __init_symbol(&_LLVMOrcObjectTransformLayerSetTransform__funptr,"LLVMOrcObjectTransformLayerSetTransform") > 0:
        pass
    (<void (*)(LLVMOrcObjectTransformLayerRef,LLVMOrcObjectTransformLayerTransformFunction,void *) noexcept nogil> _LLVMOrcObjectTransformLayerSetTransform__funptr)(ObjTransformLayer,TransformFunction,Ctx)


cdef void* _LLVMOrcCreateLocalIndirectStubsManager__funptr = NULL
# 
# Create a LocalIndirectStubsManager from the given target triple.
# 
# The resulting IndirectStubsManager is owned by the client
# and must be disposed of by calling LLVMOrcDisposeDisposeIndirectStubsManager.
cdef LLVMOrcIndirectStubsManagerRef LLVMOrcCreateLocalIndirectStubsManager(const char * TargetTriple):
    global _LLVMOrcCreateLocalIndirectStubsManager__funptr
    if __init_symbol(&_LLVMOrcCreateLocalIndirectStubsManager__funptr,"LLVMOrcCreateLocalIndirectStubsManager") > 0:
        pass
    return (<LLVMOrcIndirectStubsManagerRef (*)(const char *) noexcept nogil> _LLVMOrcCreateLocalIndirectStubsManager__funptr)(TargetTriple)


cdef void* _LLVMOrcDisposeIndirectStubsManager__funptr = NULL
# 
# Dispose of an IndirectStubsManager.
cdef void LLVMOrcDisposeIndirectStubsManager(LLVMOrcIndirectStubsManagerRef ISM):
    global _LLVMOrcDisposeIndirectStubsManager__funptr
    if __init_symbol(&_LLVMOrcDisposeIndirectStubsManager__funptr,"LLVMOrcDisposeIndirectStubsManager") > 0:
        pass
    (<void (*)(LLVMOrcIndirectStubsManagerRef) noexcept nogil> _LLVMOrcDisposeIndirectStubsManager__funptr)(ISM)


cdef void* _LLVMOrcCreateLocalLazyCallThroughManager__funptr = NULL
cdef LLVMErrorRef LLVMOrcCreateLocalLazyCallThroughManager(const char * TargetTriple,LLVMOrcExecutionSessionRef ES,unsigned long ErrorHandlerAddr,LLVMOrcLazyCallThroughManagerRef* LCTM):
    global _LLVMOrcCreateLocalLazyCallThroughManager__funptr
    if __init_symbol(&_LLVMOrcCreateLocalLazyCallThroughManager__funptr,"LLVMOrcCreateLocalLazyCallThroughManager") > 0:
        pass
    return (<LLVMErrorRef (*)(const char *,LLVMOrcExecutionSessionRef,unsigned long,LLVMOrcLazyCallThroughManagerRef*) noexcept nogil> _LLVMOrcCreateLocalLazyCallThroughManager__funptr)(TargetTriple,ES,ErrorHandlerAddr,LCTM)


cdef void* _LLVMOrcDisposeLazyCallThroughManager__funptr = NULL
# 
# Dispose of an LazyCallThroughManager.
cdef void LLVMOrcDisposeLazyCallThroughManager(LLVMOrcLazyCallThroughManagerRef LCTM):
    global _LLVMOrcDisposeLazyCallThroughManager__funptr
    if __init_symbol(&_LLVMOrcDisposeLazyCallThroughManager__funptr,"LLVMOrcDisposeLazyCallThroughManager") > 0:
        pass
    (<void (*)(LLVMOrcLazyCallThroughManagerRef) noexcept nogil> _LLVMOrcDisposeLazyCallThroughManager__funptr)(LCTM)


cdef void* _LLVMOrcCreateDumpObjects__funptr = NULL
# 
# Create a DumpObjects instance.
# 
# DumpDir specifies the path to write dumped objects to. DumpDir may be empty
# in which case files will be dumped to the working directory.
# 
# IdentifierOverride specifies a file name stem to use when dumping objects.
# If empty then each MemoryBuffer's identifier will be used (with a .o suffix
# added if not already present). If an identifier override is supplied it will
# be used instead, along with an incrementing counter (since all buffers will
# use the same identifier, the resulting files will be named <ident>.o,
# <ident>.2.o, <ident>.3.o, and so on). IdentifierOverride should not contain
# an extension, as a .o suffix will be added by DumpObjects.
cdef LLVMOrcDumpObjectsRef LLVMOrcCreateDumpObjects(const char * DumpDir,const char * IdentifierOverride):
    global _LLVMOrcCreateDumpObjects__funptr
    if __init_symbol(&_LLVMOrcCreateDumpObjects__funptr,"LLVMOrcCreateDumpObjects") > 0:
        pass
    return (<LLVMOrcDumpObjectsRef (*)(const char *,const char *) noexcept nogil> _LLVMOrcCreateDumpObjects__funptr)(DumpDir,IdentifierOverride)


cdef void* _LLVMOrcDisposeDumpObjects__funptr = NULL
# 
# Dispose of a DumpObjects instance.
cdef void LLVMOrcDisposeDumpObjects(LLVMOrcDumpObjectsRef DumpObjects):
    global _LLVMOrcDisposeDumpObjects__funptr
    if __init_symbol(&_LLVMOrcDisposeDumpObjects__funptr,"LLVMOrcDisposeDumpObjects") > 0:
        pass
    (<void (*)(LLVMOrcDumpObjectsRef) noexcept nogil> _LLVMOrcDisposeDumpObjects__funptr)(DumpObjects)


cdef void* _LLVMOrcDumpObjects_CallOperator__funptr = NULL
# 
# Dump the contents of the given MemoryBuffer.
cdef LLVMErrorRef LLVMOrcDumpObjects_CallOperator(LLVMOrcDumpObjectsRef DumpObjects,LLVMMemoryBufferRef* ObjBuffer):
    global _LLVMOrcDumpObjects_CallOperator__funptr
    if __init_symbol(&_LLVMOrcDumpObjects_CallOperator__funptr,"LLVMOrcDumpObjects_CallOperator") > 0:
        pass
    return (<LLVMErrorRef (*)(LLVMOrcDumpObjectsRef,LLVMMemoryBufferRef*) noexcept nogil> _LLVMOrcDumpObjects_CallOperator__funptr)(DumpObjects,ObjBuffer)
