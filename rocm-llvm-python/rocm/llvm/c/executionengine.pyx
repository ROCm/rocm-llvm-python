# MIT License
#
# Copyright (c) 2023-2024 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    LLVMGenericValueRef:
        alias of `~.LLVMOpaqueGenericValue`

    LLVMExecutionEngineRef:
        alias of `~.LLVMOpaqueExecutionEngine`

    LLVMMCJITMemoryManagerRef:
        alias of `~.LLVMOpaqueMCJITMemoryManager`

"""

import cython
import ctypes
import enum

from rocm.llvm.c.target import LLVMByteOrdering
from rocm.llvm.c.target import LLVMTargetDataRef
from rocm.llvm.c.target import LLVMTargetLibraryInfoRef
from rocm.llvm.c.target import LLVMInitializeAllTargetInfos
from rocm.llvm.c.target import LLVMInitializeAllTargets
from rocm.llvm.c.target import LLVMInitializeAllTargetMCs
from rocm.llvm.c.target import LLVMInitializeAllAsmPrinters
from rocm.llvm.c.target import LLVMInitializeAllAsmParsers
from rocm.llvm.c.target import LLVMInitializeAllDisassemblers
from rocm.llvm.c.target import LLVMInitializeNativeTarget
from rocm.llvm.c.target import LLVMInitializeNativeAsmParser
from rocm.llvm.c.target import LLVMInitializeNativeAsmPrinter
from rocm.llvm.c.target import LLVMInitializeNativeDisassembler
from rocm.llvm.c.target import LLVMGetModuleDataLayout
from rocm.llvm.c.target import LLVMSetModuleDataLayout
from rocm.llvm.c.target import LLVMCreateTargetData
from rocm.llvm.c.target import LLVMDisposeTargetData
from rocm.llvm.c.target import LLVMAddTargetLibraryInfo
from rocm.llvm.c.target import LLVMCopyStringRepOfTargetData
from rocm.llvm.c.target import LLVMByteOrder
from rocm.llvm.c.target import LLVMPointerSize
from rocm.llvm.c.target import LLVMPointerSizeForAS
from rocm.llvm.c.target import LLVMIntPtrType
from rocm.llvm.c.target import LLVMIntPtrTypeForAS
from rocm.llvm.c.target import LLVMIntPtrTypeInContext
from rocm.llvm.c.target import LLVMIntPtrTypeForASInContext
from rocm.llvm.c.target import LLVMSizeOfTypeInBits
from rocm.llvm.c.target import LLVMStoreSizeOfType
from rocm.llvm.c.target import LLVMABISizeOfType
from rocm.llvm.c.target import LLVMABIAlignmentOfType
from rocm.llvm.c.target import LLVMCallFrameAlignmentOfType
from rocm.llvm.c.target import LLVMPreferredAlignmentOfType
from rocm.llvm.c.target import LLVMPreferredAlignmentOfGlobal
from rocm.llvm.c.target import LLVMElementAtOffset
from rocm.llvm.c.target import LLVMOffsetOfElement


from rocm.llvm.c.targetmachine import LLVMTargetMachineRef
from rocm.llvm.c.targetmachine import LLVMTargetRef
from rocm.llvm.c.targetmachine import LLVMCodeGenOptLevel
from rocm.llvm.c.targetmachine import LLVMRelocMode
from rocm.llvm.c.targetmachine import LLVMCodeModel
from rocm.llvm.c.targetmachine import LLVMCodeGenFileType
from rocm.llvm.c.targetmachine import LLVMGetFirstTarget
from rocm.llvm.c.targetmachine import LLVMGetNextTarget
from rocm.llvm.c.targetmachine import LLVMGetTargetFromName
from rocm.llvm.c.targetmachine import LLVMGetTargetFromTriple
from rocm.llvm.c.targetmachine import LLVMGetTargetName
from rocm.llvm.c.targetmachine import LLVMGetTargetDescription
from rocm.llvm.c.targetmachine import LLVMTargetHasJIT
from rocm.llvm.c.targetmachine import LLVMTargetHasTargetMachine
from rocm.llvm.c.targetmachine import LLVMTargetHasAsmBackend
from rocm.llvm.c.targetmachine import LLVMCreateTargetMachine
from rocm.llvm.c.targetmachine import LLVMDisposeTargetMachine
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineTarget
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineTriple
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineCPU
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineFeatureString
from rocm.llvm.c.targetmachine import LLVMCreateTargetDataLayout
from rocm.llvm.c.targetmachine import LLVMSetTargetMachineAsmVerbosity
from rocm.llvm.c.targetmachine import LLVMTargetMachineEmitToFile
from rocm.llvm.c.targetmachine import LLVMTargetMachineEmitToMemoryBuffer
from rocm.llvm.c.targetmachine import LLVMGetDefaultTargetTriple
from rocm.llvm.c.targetmachine import LLVMNormalizeTargetTriple
from rocm.llvm.c.targetmachine import LLVMGetHostCPUName
from rocm.llvm.c.targetmachine import LLVMGetHostCPUFeatures
from rocm.llvm.c.targetmachine import LLVMAddAnalysisPasses


from rocm.llvm.c.types import LLVMMemoryBufferRef
from rocm.llvm.c.types import LLVMContextRef
from rocm.llvm.c.types import LLVMModuleRef
from rocm.llvm.c.types import LLVMTypeRef
from rocm.llvm.c.types import LLVMValueRef
from rocm.llvm.c.types import LLVMBasicBlockRef
from rocm.llvm.c.types import LLVMMetadataRef
from rocm.llvm.c.types import LLVMNamedMDNodeRef
from rocm.llvm.c.types import LLVMValueMetadataEntry
from rocm.llvm.c.types import LLVMBuilderRef
from rocm.llvm.c.types import LLVMDIBuilderRef
from rocm.llvm.c.types import LLVMModuleProviderRef
from rocm.llvm.c.types import LLVMPassManagerRef
from rocm.llvm.c.types import LLVMPassRegistryRef
from rocm.llvm.c.types import LLVMUseRef
from rocm.llvm.c.types import LLVMAttributeRef
from rocm.llvm.c.types import LLVMDiagnosticInfoRef
from rocm.llvm.c.types import LLVMComdatRef
from rocm.llvm.c.types import LLVMModuleFlagEntry
from rocm.llvm.c.types import LLVMJITEventListenerRef
from rocm.llvm.c.types import LLVMBinaryRef

@cython.embedsignature(True)
def LLVMLinkInMCJIT():
    r"""(No short description, might be part of a group.)

    @{
    """
    cexecutionengine.LLVMLinkInMCJIT()


@cython.embedsignature(True)
def LLVMLinkInInterpreter():
    r"""(No short description, might be part of a group.)
    """
    cexecutionengine.LLVMLinkInInterpreter()


cdef class LLVMOpaqueGenericValue(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cexecutionengine.LLVMOpaqueGenericValue.

    Python wrapper for cdef class cexecutionengine.LLVMOpaqueGenericValue.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef cexecutionengine.LLVMOpaqueGenericValue* getElementPtr(self):
        return <cexecutionengine.LLVMOpaqueGenericValue*>self._ptr

    @staticmethod
    cdef LLVMOpaqueGenericValue fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueGenericValue`` objects from
        given ``cexecutionengine.LLVMOpaqueGenericValue`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueGenericValue wrapper = LLVMOpaqueGenericValue.__new__(LLVMOpaqueGenericValue)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueGenericValue from a Python object.

        Derives a LLVMOpaqueGenericValue from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueGenericValue`` reference, this method
        returns it directly. No new ``LLVMOpaqueGenericValue`` is created in this case.
        """
        return LLVMOpaqueGenericValue.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueGenericValue fromPyobj(object pyobj):
        """Creates a LLVMOpaqueGenericValue from a Python object.

        Derives a LLVMOpaqueGenericValue from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueGenericValue`` reference, this method
        returns it directly. No new ``LLVMOpaqueGenericValue`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueGenericValue`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueGenericValue!
        """
        cdef LLVMOpaqueGenericValue wrapper

        if isinstance(pyobj,LLVMOpaqueGenericValue):
            return pyobj
        else:
            wrapper = LLVMOpaqueGenericValue.__new__(LLVMOpaqueGenericValue)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueGenericValue object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMGenericValueRef = LLVMOpaqueGenericValue

cdef class LLVMOpaqueExecutionEngine(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cexecutionengine.LLVMOpaqueExecutionEngine.

    Python wrapper for cdef class cexecutionengine.LLVMOpaqueExecutionEngine.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef cexecutionengine.LLVMOpaqueExecutionEngine* getElementPtr(self):
        return <cexecutionengine.LLVMOpaqueExecutionEngine*>self._ptr

    @staticmethod
    cdef LLVMOpaqueExecutionEngine fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueExecutionEngine`` objects from
        given ``cexecutionengine.LLVMOpaqueExecutionEngine`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueExecutionEngine wrapper = LLVMOpaqueExecutionEngine.__new__(LLVMOpaqueExecutionEngine)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueExecutionEngine from a Python object.

        Derives a LLVMOpaqueExecutionEngine from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueExecutionEngine`` reference, this method
        returns it directly. No new ``LLVMOpaqueExecutionEngine`` is created in this case.
        """
        return LLVMOpaqueExecutionEngine.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueExecutionEngine fromPyobj(object pyobj):
        """Creates a LLVMOpaqueExecutionEngine from a Python object.

        Derives a LLVMOpaqueExecutionEngine from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueExecutionEngine`` reference, this method
        returns it directly. No new ``LLVMOpaqueExecutionEngine`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueExecutionEngine`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueExecutionEngine!
        """
        cdef LLVMOpaqueExecutionEngine wrapper

        if isinstance(pyobj,LLVMOpaqueExecutionEngine):
            return pyobj
        else:
            wrapper = LLVMOpaqueExecutionEngine.__new__(LLVMOpaqueExecutionEngine)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueExecutionEngine object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMExecutionEngineRef = LLVMOpaqueExecutionEngine

cdef class LLVMOpaqueMCJITMemoryManager(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cexecutionengine.LLVMOpaqueMCJITMemoryManager.

    Python wrapper for cdef class cexecutionengine.LLVMOpaqueMCJITMemoryManager.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef cexecutionengine.LLVMOpaqueMCJITMemoryManager* getElementPtr(self):
        return <cexecutionengine.LLVMOpaqueMCJITMemoryManager*>self._ptr

    @staticmethod
    cdef LLVMOpaqueMCJITMemoryManager fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueMCJITMemoryManager`` objects from
        given ``cexecutionengine.LLVMOpaqueMCJITMemoryManager`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueMCJITMemoryManager wrapper = LLVMOpaqueMCJITMemoryManager.__new__(LLVMOpaqueMCJITMemoryManager)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueMCJITMemoryManager from a Python object.

        Derives a LLVMOpaqueMCJITMemoryManager from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueMCJITMemoryManager`` reference, this method
        returns it directly. No new ``LLVMOpaqueMCJITMemoryManager`` is created in this case.
        """
        return LLVMOpaqueMCJITMemoryManager.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueMCJITMemoryManager fromPyobj(object pyobj):
        """Creates a LLVMOpaqueMCJITMemoryManager from a Python object.

        Derives a LLVMOpaqueMCJITMemoryManager from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueMCJITMemoryManager`` reference, this method
        returns it directly. No new ``LLVMOpaqueMCJITMemoryManager`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueMCJITMemoryManager`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueMCJITMemoryManager!
        """
        cdef LLVMOpaqueMCJITMemoryManager wrapper

        if isinstance(pyobj,LLVMOpaqueMCJITMemoryManager):
            return pyobj
        else:
            wrapper = LLVMOpaqueMCJITMemoryManager.__new__(LLVMOpaqueMCJITMemoryManager)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueMCJITMemoryManager object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMMCJITMemoryManagerRef = LLVMOpaqueMCJITMemoryManager

cdef class LLVMMCJITCompilerOptions(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cexecutionengine.LLVMMCJITCompilerOptions.

    Python wrapper for cdef class cexecutionengine.LLVMMCJITCompilerOptions.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef cexecutionengine.LLVMMCJITCompilerOptions* getElementPtr(self):
        return <cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr

    @staticmethod
    cdef LLVMMCJITCompilerOptions fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMMCJITCompilerOptions`` objects from
        given ``cexecutionengine.LLVMMCJITCompilerOptions`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMMCJITCompilerOptions wrapper = LLVMMCJITCompilerOptions.__new__(LLVMMCJITCompilerOptions)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMMCJITCompilerOptions from a Python object.

        Derives a LLVMMCJITCompilerOptions from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMCJITCompilerOptions`` reference, this method
        returns it directly. No new ``LLVMMCJITCompilerOptions`` is created in this case.
        """
        return LLVMMCJITCompilerOptions.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMMCJITCompilerOptions fromPyobj(object pyobj):
        """Creates a LLVMMCJITCompilerOptions from a Python object.

        Derives a LLVMMCJITCompilerOptions from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMCJITCompilerOptions`` reference, this method
        returns it directly. No new ``LLVMMCJITCompilerOptions`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMMCJITCompilerOptions`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMMCJITCompilerOptions!
        """
        cdef LLVMMCJITCompilerOptions wrapper

        if isinstance(pyobj,LLVMMCJITCompilerOptions):
            return pyobj
        else:
            wrapper = LLVMMCJITCompilerOptions.__new__(LLVMMCJITCompilerOptions)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(cexecutionengine.LLVMMCJITCompilerOptions))
        string.memset(<void*>ptr[0], 0, sizeof(cexecutionengine.LLVMMCJITCompilerOptions))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMMCJITCompilerOptions new():
        """Factory function to create LLVMMCJITCompilerOptions objects with
        newly allocated cexecutionengine.LLVMMCJITCompilerOptions"""
        cdef void* ptr
        LLVMMCJITCompilerOptions.__allocate(&ptr)
        return LLVMMCJITCompilerOptions.fromPtr(ptr, owner=True)

    @staticmethod
    cdef LLVMMCJITCompilerOptions fromValue(cexecutionengine.LLVMMCJITCompilerOptions other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMMCJITCompilerOptions.new()
        string.memcpy(wrapper._ptr, &other, sizeof(cexecutionengine.LLVMMCJITCompilerOptions))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(cexecutionengine.LLVMMCJITCompilerOptions)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMMCJITCompilerOptions object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,**kwargs):
        """Constructor type LLVMMCJITCompilerOptions.

        Constructor for type LLVMMCJITCompilerOptions.

        Args:
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMMCJITCompilerOptions.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_OptLevel(self, i):
        """Get value ``OptLevel`` of ``(<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i]``.
        """
        return (<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i].OptLevel
    def set_OptLevel(self, i, unsigned int value):
        """Set value ``OptLevel`` of ``(<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i]``.
        """
        (<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i].OptLevel = value
    @property
    def OptLevel(self):
        """(undocumented)"""
        return self.get_OptLevel(0)
    @OptLevel.setter
    def OptLevel(self, unsigned int value):
        self.set_OptLevel(0,value)

    def get_CodeModel(self, i):
        """Get value of ``CodeModel`` of ``(<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i]``.
        """
        return LLVMCodeModel((<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i].CodeModel)
    def set_CodeModel(self, i, value):
        """Set value ``CodeModel`` of ``(<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i]``.
        """
        if not isinstance(value, LLVMCodeModel):
            raise TypeError("'value' must be of type 'LLVMCodeModel'")
        (<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i].CodeModel = value.value
    @property
    def CodeModel(self):
        """(undocumented)"""
        return self.get_CodeModel(0)
    @CodeModel.setter
    def CodeModel(self, value):
        self.set_CodeModel(0,value)

    def get_NoFramePointerElim(self, i):
        """Get value ``NoFramePointerElim`` of ``(<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i]``.
        """
        return (<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i].NoFramePointerElim
    def set_NoFramePointerElim(self, i, int value):
        """Set value ``NoFramePointerElim`` of ``(<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i]``.
        """
        (<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i].NoFramePointerElim = value
    @property
    def NoFramePointerElim(self):
        """(undocumented)"""
        return self.get_NoFramePointerElim(0)
    @NoFramePointerElim.setter
    def NoFramePointerElim(self, int value):
        self.set_NoFramePointerElim(0,value)

    def get_EnableFastISel(self, i):
        """Get value ``EnableFastISel`` of ``(<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i]``.
        """
        return (<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i].EnableFastISel
    def set_EnableFastISel(self, i, int value):
        """Set value ``EnableFastISel`` of ``(<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i]``.
        """
        (<cexecutionengine.LLVMMCJITCompilerOptions*>self._ptr)[i].EnableFastISel = value
    @property
    def EnableFastISel(self):
        """(undocumented)"""
        return self.get_EnableFastISel(0)
    @EnableFastISel.setter
    def EnableFastISel(self, int value):
        self.set_EnableFastISel(0,value)

    @staticmethod
    def PROPERTIES():
        return ["OptLevel","CodeModel","NoFramePointerElim","EnableFastISel"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


@cython.embedsignature(True)
def LLVMCreateGenericValueOfInt(object Ty, unsigned long long N, int IsSigned):
    r"""(No short description, might be part of a group.)

    Args:
        Ty (`~.LLVMOpaqueType`/`~.object`):
            (undocumented)

        N (`~.int`):
            (undocumented)

        IsSigned (`~.int`):
            (undocumented)
    """
    _LLVMCreateGenericValueOfInt__retval = LLVMOpaqueGenericValue.fromPtr(cexecutionengine.LLVMCreateGenericValueOfInt(
        LLVMOpaqueType.fromPyobj(Ty).getElementPtr(),N,IsSigned))
    return None if _LLVMCreateGenericValueOfInt__retval._ptr == NULL else _LLVMCreateGenericValueOfInt__retval


@cython.embedsignature(True)
def LLVMCreateGenericValueOfPointer(object P):
    r"""(No short description, might be part of a group.)

    Args:
        P (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMCreateGenericValueOfPointer__retval = LLVMOpaqueGenericValue.fromPtr(cexecutionengine.LLVMCreateGenericValueOfPointer(
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(P)._ptr))
    return None if _LLVMCreateGenericValueOfPointer__retval._ptr == NULL else _LLVMCreateGenericValueOfPointer__retval


@cython.embedsignature(True)
def LLVMCreateGenericValueOfFloat(object Ty, double N):
    r"""(No short description, might be part of a group.)

    Args:
        Ty (`~.LLVMOpaqueType`/`~.object`):
            (undocumented)

        N (`~.float`/`~.int`):
            (undocumented)
    """
    _LLVMCreateGenericValueOfFloat__retval = LLVMOpaqueGenericValue.fromPtr(cexecutionengine.LLVMCreateGenericValueOfFloat(
        LLVMOpaqueType.fromPyobj(Ty).getElementPtr(),N))
    return None if _LLVMCreateGenericValueOfFloat__retval._ptr == NULL else _LLVMCreateGenericValueOfFloat__retval


@cython.embedsignature(True)
def LLVMGenericValueIntWidth(object GenValRef):
    r"""(No short description, might be part of a group.)

    Args:
        GenValRef (`~.LLVMOpaqueGenericValue`/`~.object`):
            (undocumented)
    """
    cdef unsigned int _LLVMGenericValueIntWidth__retval = cexecutionengine.LLVMGenericValueIntWidth(
        LLVMOpaqueGenericValue.fromPyobj(GenValRef).getElementPtr())
    return _LLVMGenericValueIntWidth__retval


@cython.embedsignature(True)
def LLVMGenericValueToInt(object GenVal, int IsSigned):
    r"""(No short description, might be part of a group.)

    Args:
        GenVal (`~.LLVMOpaqueGenericValue`/`~.object`):
            (undocumented)

        IsSigned (`~.int`):
            (undocumented)
    """
    cdef unsigned long long _LLVMGenericValueToInt__retval = cexecutionengine.LLVMGenericValueToInt(
        LLVMOpaqueGenericValue.fromPyobj(GenVal).getElementPtr(),IsSigned)
    return _LLVMGenericValueToInt__retval


@cython.embedsignature(True)
def LLVMGenericValueToPointer(object GenVal):
    r"""(No short description, might be part of a group.)

    Args:
        GenVal (`~.LLVMOpaqueGenericValue`/`~.object`):
            (undocumented)
    """
    _LLVMGenericValueToPointer__retval = rocm.llvm._util.types.Pointer.fromPtr(<void*>cexecutionengine.LLVMGenericValueToPointer(
        LLVMOpaqueGenericValue.fromPyobj(GenVal).getElementPtr()))
    return None if _LLVMGenericValueToPointer__retval._ptr == NULL else _LLVMGenericValueToPointer__retval


@cython.embedsignature(True)
def LLVMGenericValueToFloat(object TyRef, object GenVal):
    r"""(No short description, might be part of a group.)

    Args:
        TyRef (`~.LLVMOpaqueType`/`~.object`):
            (undocumented)

        GenVal (`~.LLVMOpaqueGenericValue`/`~.object`):
            (undocumented)
    """
    cdef double _LLVMGenericValueToFloat__retval = cexecutionengine.LLVMGenericValueToFloat(
        LLVMOpaqueType.fromPyobj(TyRef).getElementPtr(),
        LLVMOpaqueGenericValue.fromPyobj(GenVal).getElementPtr())
    return _LLVMGenericValueToFloat__retval


@cython.embedsignature(True)
def LLVMDisposeGenericValue(object GenVal):
    r"""(No short description, might be part of a group.)

    Args:
        GenVal (`~.LLVMOpaqueGenericValue`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMDisposeGenericValue(
        LLVMOpaqueGenericValue.fromPyobj(GenVal).getElementPtr())


@cython.embedsignature(True)
def LLVMCreateExecutionEngineForModule(object M):
    r"""(No short description, might be part of a group.)

    Args:
        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * OutEE (`~.LLVMOpaqueExecutionEngine`):
            (undocumented)
        * OutError (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    OutEE = LLVMOpaqueExecutionEngine.fromPtr(NULL)
    OutError = rocm.llvm._util.types.CStr.fromPtr(NULL)
    cdef int _LLVMCreateExecutionEngineForModule__retval = cexecutionengine.LLVMCreateExecutionEngineForModule(<cexecutionengine.LLVMOpaqueExecutionEngine**>&OutEE._ptr,
        LLVMOpaqueModule.fromPyobj(M).getElementPtr(),
        <char **>&OutError._ptr)
    return (_LLVMCreateExecutionEngineForModule__retval,None if OutEE._ptr == NULL else OutEE,None if OutError._ptr == NULL else OutError)


@cython.embedsignature(True)
def LLVMCreateInterpreterForModule(object M):
    r"""(No short description, might be part of a group.)

    Args:
        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * OutInterp (`~.LLVMOpaqueExecutionEngine`):
            (undocumented)
        * OutError (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    OutInterp = LLVMOpaqueExecutionEngine.fromPtr(NULL)
    OutError = rocm.llvm._util.types.CStr.fromPtr(NULL)
    cdef int _LLVMCreateInterpreterForModule__retval = cexecutionengine.LLVMCreateInterpreterForModule(<cexecutionengine.LLVMOpaqueExecutionEngine**>&OutInterp._ptr,
        LLVMOpaqueModule.fromPyobj(M).getElementPtr(),
        <char **>&OutError._ptr)
    return (_LLVMCreateInterpreterForModule__retval,None if OutInterp._ptr == NULL else OutInterp,None if OutError._ptr == NULL else OutError)


@cython.embedsignature(True)
def LLVMCreateJITCompilerForModule(object M, unsigned int OptLevel):
    r"""(No short description, might be part of a group.)

    Args:
        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)

        OptLevel (`~.int`):
            (undocumented)

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * OutJIT (`~.LLVMOpaqueExecutionEngine`):
            (undocumented)
        * OutError (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    OutJIT = LLVMOpaqueExecutionEngine.fromPtr(NULL)
    OutError = rocm.llvm._util.types.CStr.fromPtr(NULL)
    cdef int _LLVMCreateJITCompilerForModule__retval = cexecutionengine.LLVMCreateJITCompilerForModule(<cexecutionengine.LLVMOpaqueExecutionEngine**>&OutJIT._ptr,
        LLVMOpaqueModule.fromPyobj(M).getElementPtr(),OptLevel,
        <char **>&OutError._ptr)
    return (_LLVMCreateJITCompilerForModule__retval,None if OutJIT._ptr == NULL else OutJIT,None if OutError._ptr == NULL else OutError)


@cython.embedsignature(True)
def LLVMInitializeMCJITCompilerOptions(object Options, unsigned long SizeOfOptions):
    r"""(No short description, might be part of a group.)

    Args:
        Options (`~.LLVMMCJITCompilerOptions`/`~.object`):
            (undocumented)

        SizeOfOptions (`~.int`):
            (undocumented)
    """
    cexecutionengine.LLVMInitializeMCJITCompilerOptions(
        LLVMMCJITCompilerOptions.fromPyobj(Options).getElementPtr(),SizeOfOptions)


@cython.embedsignature(True)
def LLVMCreateMCJITCompilerForModule(object M, object Options, unsigned long SizeOfOptions):
    r"""(No short description, might be part of a group.)

    Create an MCJIT execution engine for a module, with the given options. It is
    the responsibility of the caller to ensure that all fields in Options up to
    the given SizeOfOptions are initialized. It is correct to pass a smaller
    value of SizeOfOptions that omits some fields. The canonical way of using
    this is:

    LLVMMCJITCompilerOptions options;
    LLVMInitializeMCJITCompilerOptions(&options, sizeof(options));
    ... fill in those options you care about
    LLVMCreateMCJITCompilerForModule(&jit, mod, &options, sizeof(options),
                                     &error);

    Note that this is also correct, though possibly suboptimal:

    LLVMCreateMCJITCompilerForModule(&jit, mod, 0, 0, &error);

    Args:
        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)

        Options (`~.LLVMMCJITCompilerOptions`/`~.object`):
            (undocumented)

        SizeOfOptions (`~.int`):
            (undocumented)

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * OutJIT (`~.LLVMOpaqueExecutionEngine`):
            (undocumented)
        * OutError (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    OutJIT = LLVMOpaqueExecutionEngine.fromPtr(NULL)
    OutError = rocm.llvm._util.types.CStr.fromPtr(NULL)
    cdef int _LLVMCreateMCJITCompilerForModule__retval = cexecutionengine.LLVMCreateMCJITCompilerForModule(<cexecutionengine.LLVMOpaqueExecutionEngine**>&OutJIT._ptr,
        LLVMOpaqueModule.fromPyobj(M).getElementPtr(),
        LLVMMCJITCompilerOptions.fromPyobj(Options).getElementPtr(),SizeOfOptions,
        <char **>&OutError._ptr)
    return (_LLVMCreateMCJITCompilerForModule__retval,None if OutJIT._ptr == NULL else OutJIT,None if OutError._ptr == NULL else OutError)


@cython.embedsignature(True)
def LLVMDisposeExecutionEngine(object EE):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMDisposeExecutionEngine(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr())


@cython.embedsignature(True)
def LLVMRunStaticConstructors(object EE):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMRunStaticConstructors(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr())


@cython.embedsignature(True)
def LLVMRunStaticDestructors(object EE):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMRunStaticDestructors(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr())


@cython.embedsignature(True)
def LLVMRunFunctionAsMain(object EE, object F, unsigned int ArgC, object ArgV, object EnvP):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        F (`~.LLVMOpaqueValue`/`~.object`):
            (undocumented)

        ArgC (`~.int`):
            (undocumented)

        ArgV (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

        EnvP (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    cdef int _LLVMRunFunctionAsMain__retval = cexecutionengine.LLVMRunFunctionAsMain(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr(),
        LLVMOpaqueValue.fromPyobj(F).getElementPtr(),ArgC,
        <const char *const *>rocm.llvm._util.types.CStr.fromPyobj(ArgV)._ptr,
        <const char *const *>rocm.llvm._util.types.CStr.fromPyobj(EnvP)._ptr)
    return _LLVMRunFunctionAsMain__retval


@cython.embedsignature(True)
def LLVMRunFunction(object EE, object F, unsigned int NumArgs, object Args):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        F (`~.LLVMOpaqueValue`/`~.object`):
            (undocumented)

        NumArgs (`~.int`):
            (undocumented)

        Args (`~.rocm.llvm._util.types.ListOfPointer`/`~.object`):
            (undocumented)
    """
    _LLVMRunFunction__retval = LLVMOpaqueGenericValue.fromPtr(cexecutionengine.LLVMRunFunction(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr(),
        LLVMOpaqueValue.fromPyobj(F).getElementPtr(),NumArgs,
        <cexecutionengine.LLVMGenericValueRef*>rocm.llvm._util.types.ListOfPointer.fromPyobj(Args)._ptr))
    return None if _LLVMRunFunction__retval._ptr == NULL else _LLVMRunFunction__retval


@cython.embedsignature(True)
def LLVMFreeMachineCodeForFunction(object EE, object F):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        F (`~.LLVMOpaqueValue`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMFreeMachineCodeForFunction(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr(),
        LLVMOpaqueValue.fromPyobj(F).getElementPtr())


@cython.embedsignature(True)
def LLVMAddModule(object EE, object M):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMAddModule(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr(),
        LLVMOpaqueModule.fromPyobj(M).getElementPtr())


@cython.embedsignature(True)
def LLVMRemoveModule(object EE, object M):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 2 that contains (in that order):

        * OutMod (`~.LLVMOpaqueModule`):
            (undocumented)
        * OutError (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    OutMod = LLVMOpaqueModule.fromPtr(NULL)
    OutError = rocm.llvm._util.types.CStr.fromPtr(NULL)
    cdef int _LLVMRemoveModule__retval = cexecutionengine.LLVMRemoveModule(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr(),
        LLVMOpaqueModule.fromPyobj(M).getElementPtr(),<cexecutionengine.LLVMOpaqueModule**>&OutMod._ptr,
        <char **>&OutError._ptr)
    return (_LLVMRemoveModule__retval,None if OutMod._ptr == NULL else OutMod,None if OutError._ptr == NULL else OutError)


@cython.embedsignature(True)
def LLVMFindFunction(object EE, object Name):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        Name (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)

    Returns:
        OutFn (`~.LLVMOpaqueValue`):
            (undocumented)
    """
    OutFn = LLVMOpaqueValue.fromPtr(NULL)
    cdef int _LLVMFindFunction__retval = cexecutionengine.LLVMFindFunction(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(Name)._ptr,<cexecutionengine.LLVMOpaqueValue**>&OutFn._ptr)
    return (_LLVMFindFunction__retval,None if OutFn._ptr == NULL else OutFn)


@cython.embedsignature(True)
def LLVMRecompileAndRelinkFunction(object EE, object Fn):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        Fn (`~.LLVMOpaqueValue`/`~.object`):
            (undocumented)
    """
    _LLVMRecompileAndRelinkFunction__retval = rocm.llvm._util.types.Pointer.fromPtr(<void*>cexecutionengine.LLVMRecompileAndRelinkFunction(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr(),
        LLVMOpaqueValue.fromPyobj(Fn).getElementPtr()))
    return None if _LLVMRecompileAndRelinkFunction__retval._ptr == NULL else _LLVMRecompileAndRelinkFunction__retval


@cython.embedsignature(True)
def LLVMGetExecutionEngineTargetData(object EE):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)
    """
    _LLVMGetExecutionEngineTargetData__retval = LLVMOpaqueTargetData.fromPtr(cexecutionengine.LLVMGetExecutionEngineTargetData(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr()))
    return None if _LLVMGetExecutionEngineTargetData__retval._ptr == NULL else _LLVMGetExecutionEngineTargetData__retval


@cython.embedsignature(True)
def LLVMGetExecutionEngineTargetMachine(object EE):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)
    """
    _LLVMGetExecutionEngineTargetMachine__retval = LLVMOpaqueTargetMachine.fromPtr(cexecutionengine.LLVMGetExecutionEngineTargetMachine(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr()))
    return None if _LLVMGetExecutionEngineTargetMachine__retval._ptr == NULL else _LLVMGetExecutionEngineTargetMachine__retval


@cython.embedsignature(True)
def LLVMAddGlobalMapping(object EE, object Global, object Addr):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        Global (`~.LLVMOpaqueValue`/`~.object`):
            (undocumented)

        Addr (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMAddGlobalMapping(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr(),
        LLVMOpaqueValue.fromPyobj(Global).getElementPtr(),
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(Addr)._ptr)


@cython.embedsignature(True)
def LLVMGetPointerToGlobal(object EE, object Global):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        Global (`~.LLVMOpaqueValue`/`~.object`):
            (undocumented)
    """
    _LLVMGetPointerToGlobal__retval = rocm.llvm._util.types.Pointer.fromPtr(<void*>cexecutionengine.LLVMGetPointerToGlobal(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr(),
        LLVMOpaqueValue.fromPyobj(Global).getElementPtr()))
    return None if _LLVMGetPointerToGlobal__retval._ptr == NULL else _LLVMGetPointerToGlobal__retval


@cython.embedsignature(True)
def LLVMGetGlobalValueAddress(object EE, object Name):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        Name (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    cdef unsigned long _LLVMGetGlobalValueAddress__retval = cexecutionengine.LLVMGetGlobalValueAddress(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(Name)._ptr)
    return _LLVMGetGlobalValueAddress__retval


@cython.embedsignature(True)
def LLVMGetFunctionAddress(object EE, object Name):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        Name (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    cdef unsigned long _LLVMGetFunctionAddress__retval = cexecutionengine.LLVMGetFunctionAddress(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr(),
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(Name)._ptr)
    return _LLVMGetFunctionAddress__retval


@cython.embedsignature(True)
def LLVMExecutionEngineGetErrMsg(object EE):
    r"""(No short description, might be part of a group.)

    Returns true on error, false on success. If true is returned then the error
    message is copied to OutStr and cleared in the ExecutionEngine instance.

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

    Returns:
        OutError (`~.rocm.llvm._util.types.CStr`/`~.object`):
            (undocumented)
    """
    OutError = rocm.llvm._util.types.CStr.fromPtr(NULL)
    cdef int _LLVMExecutionEngineGetErrMsg__retval = cexecutionengine.LLVMExecutionEngineGetErrMsg(
        LLVMOpaqueExecutionEngine.fromPyobj(EE).getElementPtr(),
        <char **>&OutError._ptr)
    return (_LLVMExecutionEngineGetErrMsg__retval,None if OutError._ptr == NULL else OutError)


cdef class LLVMMemoryManagerAllocateCodeSectionCallback(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cexecutionengine.LLVMMemoryManagerAllocateCodeSectionCallback.

    Python wrapper for cdef class cexecutionengine.LLVMMemoryManagerAllocateCodeSectionCallback.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef cexecutionengine.LLVMMemoryManagerAllocateCodeSectionCallback getElementPtr(self):
        return <cexecutionengine.LLVMMemoryManagerAllocateCodeSectionCallback>self._ptr

    @staticmethod
    cdef LLVMMemoryManagerAllocateCodeSectionCallback fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMMemoryManagerAllocateCodeSectionCallback`` objects from
        given ``cexecutionengine.LLVMMemoryManagerAllocateCodeSectionCallback`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMMemoryManagerAllocateCodeSectionCallback wrapper = LLVMMemoryManagerAllocateCodeSectionCallback.__new__(LLVMMemoryManagerAllocateCodeSectionCallback)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMMemoryManagerAllocateCodeSectionCallback from a Python object.

        Derives a LLVMMemoryManagerAllocateCodeSectionCallback from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMemoryManagerAllocateCodeSectionCallback`` reference, this method
        returns it directly. No new ``LLVMMemoryManagerAllocateCodeSectionCallback`` is created in this case.
        """
        return LLVMMemoryManagerAllocateCodeSectionCallback.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMMemoryManagerAllocateCodeSectionCallback fromPyobj(object pyobj):
        """Creates a LLVMMemoryManagerAllocateCodeSectionCallback from a Python object.

        Derives a LLVMMemoryManagerAllocateCodeSectionCallback from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMemoryManagerAllocateCodeSectionCallback`` reference, this method
        returns it directly. No new ``LLVMMemoryManagerAllocateCodeSectionCallback`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMMemoryManagerAllocateCodeSectionCallback`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMMemoryManagerAllocateCodeSectionCallback!
        """
        cdef LLVMMemoryManagerAllocateCodeSectionCallback wrapper

        if isinstance(pyobj,LLVMMemoryManagerAllocateCodeSectionCallback):
            return pyobj
        else:
            wrapper = LLVMMemoryManagerAllocateCodeSectionCallback.__new__(LLVMMemoryManagerAllocateCodeSectionCallback)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMMemoryManagerAllocateCodeSectionCallback object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMMemoryManagerAllocateDataSectionCallback(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cexecutionengine.LLVMMemoryManagerAllocateDataSectionCallback.

    Python wrapper for cdef class cexecutionengine.LLVMMemoryManagerAllocateDataSectionCallback.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef cexecutionengine.LLVMMemoryManagerAllocateDataSectionCallback getElementPtr(self):
        return <cexecutionengine.LLVMMemoryManagerAllocateDataSectionCallback>self._ptr

    @staticmethod
    cdef LLVMMemoryManagerAllocateDataSectionCallback fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMMemoryManagerAllocateDataSectionCallback`` objects from
        given ``cexecutionengine.LLVMMemoryManagerAllocateDataSectionCallback`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMMemoryManagerAllocateDataSectionCallback wrapper = LLVMMemoryManagerAllocateDataSectionCallback.__new__(LLVMMemoryManagerAllocateDataSectionCallback)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMMemoryManagerAllocateDataSectionCallback from a Python object.

        Derives a LLVMMemoryManagerAllocateDataSectionCallback from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMemoryManagerAllocateDataSectionCallback`` reference, this method
        returns it directly. No new ``LLVMMemoryManagerAllocateDataSectionCallback`` is created in this case.
        """
        return LLVMMemoryManagerAllocateDataSectionCallback.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMMemoryManagerAllocateDataSectionCallback fromPyobj(object pyobj):
        """Creates a LLVMMemoryManagerAllocateDataSectionCallback from a Python object.

        Derives a LLVMMemoryManagerAllocateDataSectionCallback from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMemoryManagerAllocateDataSectionCallback`` reference, this method
        returns it directly. No new ``LLVMMemoryManagerAllocateDataSectionCallback`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMMemoryManagerAllocateDataSectionCallback`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMMemoryManagerAllocateDataSectionCallback!
        """
        cdef LLVMMemoryManagerAllocateDataSectionCallback wrapper

        if isinstance(pyobj,LLVMMemoryManagerAllocateDataSectionCallback):
            return pyobj
        else:
            wrapper = LLVMMemoryManagerAllocateDataSectionCallback.__new__(LLVMMemoryManagerAllocateDataSectionCallback)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMMemoryManagerAllocateDataSectionCallback object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMMemoryManagerFinalizeMemoryCallback(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cexecutionengine.LLVMMemoryManagerFinalizeMemoryCallback.

    Python wrapper for cdef class cexecutionengine.LLVMMemoryManagerFinalizeMemoryCallback.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef cexecutionengine.LLVMMemoryManagerFinalizeMemoryCallback getElementPtr(self):
        return <cexecutionengine.LLVMMemoryManagerFinalizeMemoryCallback>self._ptr

    @staticmethod
    cdef LLVMMemoryManagerFinalizeMemoryCallback fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMMemoryManagerFinalizeMemoryCallback`` objects from
        given ``cexecutionengine.LLVMMemoryManagerFinalizeMemoryCallback`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMMemoryManagerFinalizeMemoryCallback wrapper = LLVMMemoryManagerFinalizeMemoryCallback.__new__(LLVMMemoryManagerFinalizeMemoryCallback)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMMemoryManagerFinalizeMemoryCallback from a Python object.

        Derives a LLVMMemoryManagerFinalizeMemoryCallback from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMemoryManagerFinalizeMemoryCallback`` reference, this method
        returns it directly. No new ``LLVMMemoryManagerFinalizeMemoryCallback`` is created in this case.
        """
        return LLVMMemoryManagerFinalizeMemoryCallback.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMMemoryManagerFinalizeMemoryCallback fromPyobj(object pyobj):
        """Creates a LLVMMemoryManagerFinalizeMemoryCallback from a Python object.

        Derives a LLVMMemoryManagerFinalizeMemoryCallback from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMemoryManagerFinalizeMemoryCallback`` reference, this method
        returns it directly. No new ``LLVMMemoryManagerFinalizeMemoryCallback`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMMemoryManagerFinalizeMemoryCallback`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMMemoryManagerFinalizeMemoryCallback!
        """
        cdef LLVMMemoryManagerFinalizeMemoryCallback wrapper

        if isinstance(pyobj,LLVMMemoryManagerFinalizeMemoryCallback):
            return pyobj
        else:
            wrapper = LLVMMemoryManagerFinalizeMemoryCallback.__new__(LLVMMemoryManagerFinalizeMemoryCallback)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMMemoryManagerFinalizeMemoryCallback object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMMemoryManagerDestroyCallback(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class cexecutionengine.LLVMMemoryManagerDestroyCallback.

    Python wrapper for cdef class cexecutionengine.LLVMMemoryManagerDestroyCallback.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef cexecutionengine.LLVMMemoryManagerDestroyCallback getElementPtr(self):
        return <cexecutionengine.LLVMMemoryManagerDestroyCallback>self._ptr

    @staticmethod
    cdef LLVMMemoryManagerDestroyCallback fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMMemoryManagerDestroyCallback`` objects from
        given ``cexecutionengine.LLVMMemoryManagerDestroyCallback`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMMemoryManagerDestroyCallback wrapper = LLVMMemoryManagerDestroyCallback.__new__(LLVMMemoryManagerDestroyCallback)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMMemoryManagerDestroyCallback from a Python object.

        Derives a LLVMMemoryManagerDestroyCallback from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMemoryManagerDestroyCallback`` reference, this method
        returns it directly. No new ``LLVMMemoryManagerDestroyCallback`` is created in this case.
        """
        return LLVMMemoryManagerDestroyCallback.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMMemoryManagerDestroyCallback fromPyobj(object pyobj):
        """Creates a LLVMMemoryManagerDestroyCallback from a Python object.

        Derives a LLVMMemoryManagerDestroyCallback from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMemoryManagerDestroyCallback`` reference, this method
        returns it directly. No new ``LLVMMemoryManagerDestroyCallback`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMMemoryManagerDestroyCallback`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMMemoryManagerDestroyCallback!
        """
        cdef LLVMMemoryManagerDestroyCallback wrapper

        if isinstance(pyobj,LLVMMemoryManagerDestroyCallback):
            return pyobj
        else:
            wrapper = LLVMMemoryManagerDestroyCallback.__new__(LLVMMemoryManagerDestroyCallback)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMMemoryManagerDestroyCallback object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def LLVMCreateSimpleMCJITMemoryManager(object Opaque, object AllocateCodeSection, object AllocateDataSection, object FinalizeMemory, object Destroy):
    r"""(No short description, might be part of a group.)

    Create a simple custom MCJIT memory manager. This memory manager can
    intercept allocations in a module-oblivious way. This will return NULL
    if any of the passed functions are NULL.

    Args:
        Opaque (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            An opaque client object to pass back to the callbacks.

        AllocateCodeSection (`~.LLVMMemoryManagerAllocateCodeSectionCallback`/`~.object`):
            Allocate a block of memory for executable code.

        AllocateDataSection (`~.LLVMMemoryManagerAllocateDataSectionCallback`/`~.object`):
            Allocate a block of memory for data.

        FinalizeMemory (`~.LLVMMemoryManagerFinalizeMemoryCallback`/`~.object`):
            Set page permissions and flush cache. Return 0 on
            success, 1 on error.

        Destroy (`~.LLVMMemoryManagerDestroyCallback`/`~.object`):
            (undocumented)
    """
    _LLVMCreateSimpleMCJITMemoryManager__retval = LLVMOpaqueMCJITMemoryManager.fromPtr(cexecutionengine.LLVMCreateSimpleMCJITMemoryManager(
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(Opaque)._ptr,
        LLVMMemoryManagerAllocateCodeSectionCallback.fromPyobj(AllocateCodeSection).getElementPtr(),
        LLVMMemoryManagerAllocateDataSectionCallback.fromPyobj(AllocateDataSection).getElementPtr(),
        LLVMMemoryManagerFinalizeMemoryCallback.fromPyobj(FinalizeMemory).getElementPtr(),
        LLVMMemoryManagerDestroyCallback.fromPyobj(Destroy).getElementPtr()))
    return None if _LLVMCreateSimpleMCJITMemoryManager__retval._ptr == NULL else _LLVMCreateSimpleMCJITMemoryManager__retval


@cython.embedsignature(True)
def LLVMDisposeMCJITMemoryManager(object MM):
    r"""(No short description, might be part of a group.)

    Args:
        MM (`~.LLVMOpaqueMCJITMemoryManager`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMDisposeMCJITMemoryManager(
        LLVMOpaqueMCJITMemoryManager.fromPyobj(MM).getElementPtr())


@cython.embedsignature(True)
def LLVMCreateGDBRegistrationListener():
    r"""(No short description, might be part of a group.)
    """
    _LLVMCreateGDBRegistrationListener__retval = LLVMOpaqueJITEventListener.fromPtr(cexecutionengine.LLVMCreateGDBRegistrationListener())
    return None if _LLVMCreateGDBRegistrationListener__retval._ptr == NULL else _LLVMCreateGDBRegistrationListener__retval


@cython.embedsignature(True)
def LLVMCreateIntelJITEventListener():
    r"""(No short description, might be part of a group.)
    """
    _LLVMCreateIntelJITEventListener__retval = LLVMOpaqueJITEventListener.fromPtr(cexecutionengine.LLVMCreateIntelJITEventListener())
    return None if _LLVMCreateIntelJITEventListener__retval._ptr == NULL else _LLVMCreateIntelJITEventListener__retval


@cython.embedsignature(True)
def LLVMCreateOProfileJITEventListener():
    r"""(No short description, might be part of a group.)
    """
    _LLVMCreateOProfileJITEventListener__retval = LLVMOpaqueJITEventListener.fromPtr(cexecutionengine.LLVMCreateOProfileJITEventListener())
    return None if _LLVMCreateOProfileJITEventListener__retval._ptr == NULL else _LLVMCreateOProfileJITEventListener__retval


@cython.embedsignature(True)
def LLVMCreatePerfJITEventListener():
    r"""(No short description, might be part of a group.)
    """
    _LLVMCreatePerfJITEventListener__retval = LLVMOpaqueJITEventListener.fromPtr(cexecutionengine.LLVMCreatePerfJITEventListener())
    return None if _LLVMCreatePerfJITEventListener__retval._ptr == NULL else _LLVMCreatePerfJITEventListener__retval

__all__ = [
    "LLVMLinkInMCJIT",
    "LLVMLinkInInterpreter",
    "LLVMOpaqueGenericValue",
    "LLVMGenericValueRef",
    "LLVMOpaqueExecutionEngine",
    "LLVMExecutionEngineRef",
    "LLVMOpaqueMCJITMemoryManager",
    "LLVMMCJITMemoryManagerRef",
    "LLVMMCJITCompilerOptions",
    "LLVMCreateGenericValueOfInt",
    "LLVMCreateGenericValueOfPointer",
    "LLVMCreateGenericValueOfFloat",
    "LLVMGenericValueIntWidth",
    "LLVMGenericValueToInt",
    "LLVMGenericValueToPointer",
    "LLVMGenericValueToFloat",
    "LLVMDisposeGenericValue",
    "LLVMCreateExecutionEngineForModule",
    "LLVMCreateInterpreterForModule",
    "LLVMCreateJITCompilerForModule",
    "LLVMInitializeMCJITCompilerOptions",
    "LLVMCreateMCJITCompilerForModule",
    "LLVMDisposeExecutionEngine",
    "LLVMRunStaticConstructors",
    "LLVMRunStaticDestructors",
    "LLVMRunFunctionAsMain",
    "LLVMRunFunction",
    "LLVMFreeMachineCodeForFunction",
    "LLVMAddModule",
    "LLVMRemoveModule",
    "LLVMFindFunction",
    "LLVMRecompileAndRelinkFunction",
    "LLVMGetExecutionEngineTargetData",
    "LLVMGetExecutionEngineTargetMachine",
    "LLVMAddGlobalMapping",
    "LLVMGetPointerToGlobal",
    "LLVMGetGlobalValueAddress",
    "LLVMGetFunctionAddress",
    "LLVMExecutionEngineGetErrMsg",
    "LLVMMemoryManagerAllocateCodeSectionCallback",
    "LLVMMemoryManagerAllocateDataSectionCallback",
    "LLVMMemoryManagerFinalizeMemoryCallback",
    "LLVMMemoryManagerDestroyCallback",
    "LLVMCreateSimpleMCJITMemoryManager",
    "LLVMDisposeMCJITMemoryManager",
    "LLVMCreateGDBRegistrationListener",
    "LLVMCreateIntelJITEventListener",
    "LLVMCreateOProfileJITEventListener",
    "LLVMCreatePerfJITEventListener",
]