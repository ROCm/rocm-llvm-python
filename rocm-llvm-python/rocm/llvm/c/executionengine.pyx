# MIT License
# 
# Copyright (c) 2023 Advanced Micro Devices, Inc.
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    LLVMGenericValueRef:
        alias of `~.LLVMOpaqueGenericValue`

    LLVMExecutionEngineRef:
        alias of `~.LLVMOpaqueExecutionEngine`

    LLVMMCJITMemoryManagerRef:
        alias of `~.LLVMOpaqueMCJITMemoryManager`

"""

import cython
import ctypes
import enum

from rocm.llvm.c.target import LLVMByteOrdering
from rocm.llvm.c.target import LLVMTargetDataRef
from rocm.llvm.c.target import LLVMTargetLibraryInfoRef
from rocm.llvm.c.target import LLVMInitializeAllTargetInfos
from rocm.llvm.c.target import LLVMInitializeAllTargets
from rocm.llvm.c.target import LLVMInitializeAllTargetMCs
from rocm.llvm.c.target import LLVMInitializeAllAsmPrinters
from rocm.llvm.c.target import LLVMInitializeAllAsmParsers
from rocm.llvm.c.target import LLVMInitializeAllDisassemblers
from rocm.llvm.c.target import LLVMInitializeNativeTarget
from rocm.llvm.c.target import LLVMInitializeNativeAsmParser
from rocm.llvm.c.target import LLVMInitializeNativeAsmPrinter
from rocm.llvm.c.target import LLVMInitializeNativeDisassembler
from rocm.llvm.c.target import LLVMGetModuleDataLayout
from rocm.llvm.c.target import LLVMSetModuleDataLayout
from rocm.llvm.c.target import LLVMCreateTargetData
from rocm.llvm.c.target import LLVMDisposeTargetData
from rocm.llvm.c.target import LLVMAddTargetLibraryInfo
from rocm.llvm.c.target import LLVMCopyStringRepOfTargetData
from rocm.llvm.c.target import LLVMByteOrder
from rocm.llvm.c.target import LLVMPointerSize
from rocm.llvm.c.target import LLVMPointerSizeForAS
from rocm.llvm.c.target import LLVMIntPtrType
from rocm.llvm.c.target import LLVMIntPtrTypeForAS
from rocm.llvm.c.target import LLVMIntPtrTypeInContext
from rocm.llvm.c.target import LLVMIntPtrTypeForASInContext
from rocm.llvm.c.target import LLVMSizeOfTypeInBits
from rocm.llvm.c.target import LLVMStoreSizeOfType
from rocm.llvm.c.target import LLVMABISizeOfType
from rocm.llvm.c.target import LLVMABIAlignmentOfType
from rocm.llvm.c.target import LLVMCallFrameAlignmentOfType
from rocm.llvm.c.target import LLVMPreferredAlignmentOfType
from rocm.llvm.c.target import LLVMPreferredAlignmentOfGlobal
from rocm.llvm.c.target import LLVMElementAtOffset
from rocm.llvm.c.target import LLVMOffsetOfElement


from rocm.llvm.c.targetmachine import LLVMTargetMachineRef
from rocm.llvm.c.targetmachine import LLVMTargetRef
from rocm.llvm.c.targetmachine import LLVMCodeGenOptLevel
from rocm.llvm.c.targetmachine import LLVMRelocMode
from rocm.llvm.c.targetmachine import LLVMCodeModel
from rocm.llvm.c.targetmachine import LLVMCodeGenFileType
from rocm.llvm.c.targetmachine import LLVMGetFirstTarget
from rocm.llvm.c.targetmachine import LLVMGetNextTarget
from rocm.llvm.c.targetmachine import LLVMGetTargetFromName
from rocm.llvm.c.targetmachine import LLVMGetTargetFromTriple
from rocm.llvm.c.targetmachine import LLVMGetTargetName
from rocm.llvm.c.targetmachine import LLVMGetTargetDescription
from rocm.llvm.c.targetmachine import LLVMTargetHasJIT
from rocm.llvm.c.targetmachine import LLVMTargetHasTargetMachine
from rocm.llvm.c.targetmachine import LLVMTargetHasAsmBackend
from rocm.llvm.c.targetmachine import LLVMCreateTargetMachine
from rocm.llvm.c.targetmachine import LLVMDisposeTargetMachine
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineTarget
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineTriple
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineCPU
from rocm.llvm.c.targetmachine import LLVMGetTargetMachineFeatureString
from rocm.llvm.c.targetmachine import LLVMCreateTargetDataLayout
from rocm.llvm.c.targetmachine import LLVMSetTargetMachineAsmVerbosity
from rocm.llvm.c.targetmachine import LLVMTargetMachineEmitToFile
from rocm.llvm.c.targetmachine import LLVMTargetMachineEmitToMemoryBuffer
from rocm.llvm.c.targetmachine import LLVMGetDefaultTargetTriple
from rocm.llvm.c.targetmachine import LLVMNormalizeTargetTriple
from rocm.llvm.c.targetmachine import LLVMGetHostCPUName
from rocm.llvm.c.targetmachine import LLVMGetHostCPUFeatures
from rocm.llvm.c.targetmachine import LLVMAddAnalysisPasses


from rocm.llvm.c.types import LLVMMemoryBufferRef
from rocm.llvm.c.types import LLVMContextRef
from rocm.llvm.c.types import LLVMModuleRef
from rocm.llvm.c.types import LLVMTypeRef
from rocm.llvm.c.types import LLVMValueRef
from rocm.llvm.c.types import LLVMBasicBlockRef
from rocm.llvm.c.types import LLVMMetadataRef
from rocm.llvm.c.types import LLVMNamedMDNodeRef
from rocm.llvm.c.types import LLVMValueMetadataEntry
from rocm.llvm.c.types import LLVMBuilderRef
from rocm.llvm.c.types import LLVMDIBuilderRef
from rocm.llvm.c.types import LLVMModuleProviderRef
from rocm.llvm.c.types import LLVMPassManagerRef
from rocm.llvm.c.types import LLVMPassRegistryRef
from rocm.llvm.c.types import LLVMUseRef
from rocm.llvm.c.types import LLVMAttributeRef
from rocm.llvm.c.types import LLVMDiagnosticInfoRef
from rocm.llvm.c.types import LLVMComdatRef
from rocm.llvm.c.types import LLVMModuleFlagEntry
from rocm.llvm.c.types import LLVMJITEventListenerRef
from rocm.llvm.c.types import LLVMBinaryRef

@cython.embedsignature(True)
def LLVMLinkInMCJIT():
    r"""(No short description, might be part of a group.)

    @{
    """
    cexecutionengine.LLVMLinkInMCJIT()    # fully specified


@cython.embedsignature(True)
def LLVMLinkInInterpreter():
    r"""(No short description, might be part of a group.)
    """
    cexecutionengine.LLVMLinkInInterpreter()    # fully specified


cdef class LLVMOpaqueGenericValue:
    """Python wrapper for C type cexecutionengine.LLVMOpaqueGenericValue.
    
    Python wrapper for C type cexecutionengine.LLVMOpaqueGenericValue.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOpaqueGenericValue from_ptr(cexecutionengine.LLVMOpaqueGenericValue* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueGenericValue`` objects from
        given ``cexecutionengine.LLVMOpaqueGenericValue`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueGenericValue wrapper = LLVMOpaqueGenericValue.__new__(LLVMOpaqueGenericValue)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueGenericValue from_pyobj(object pyobj):
        """Derives a LLVMOpaqueGenericValue from a Python object.

        Derives a LLVMOpaqueGenericValue from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueGenericValue`` reference, this method
        returns it directly. No new ``LLVMOpaqueGenericValue`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOpaqueGenericValue`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueGenericValue!
        """
        cdef LLVMOpaqueGenericValue wrapper = LLVMOpaqueGenericValue.__new__(LLVMOpaqueGenericValue)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueGenericValue):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cexecutionengine.LLVMOpaqueGenericValue*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cexecutionengine.LLVMOpaqueGenericValue*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <cexecutionengine.LLVMOpaqueGenericValue*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueGenericValue object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMGenericValueRef = LLVMOpaqueGenericValue

cdef class LLVMOpaqueExecutionEngine:
    """Python wrapper for C type cexecutionengine.LLVMOpaqueExecutionEngine.
    
    Python wrapper for C type cexecutionengine.LLVMOpaqueExecutionEngine.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOpaqueExecutionEngine from_ptr(cexecutionengine.LLVMOpaqueExecutionEngine* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueExecutionEngine`` objects from
        given ``cexecutionengine.LLVMOpaqueExecutionEngine`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueExecutionEngine wrapper = LLVMOpaqueExecutionEngine.__new__(LLVMOpaqueExecutionEngine)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueExecutionEngine from_pyobj(object pyobj):
        """Derives a LLVMOpaqueExecutionEngine from a Python object.

        Derives a LLVMOpaqueExecutionEngine from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueExecutionEngine`` reference, this method
        returns it directly. No new ``LLVMOpaqueExecutionEngine`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOpaqueExecutionEngine`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueExecutionEngine!
        """
        cdef LLVMOpaqueExecutionEngine wrapper = LLVMOpaqueExecutionEngine.__new__(LLVMOpaqueExecutionEngine)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueExecutionEngine):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cexecutionengine.LLVMOpaqueExecutionEngine*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cexecutionengine.LLVMOpaqueExecutionEngine*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <cexecutionengine.LLVMOpaqueExecutionEngine*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueExecutionEngine object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMExecutionEngineRef = LLVMOpaqueExecutionEngine

cdef class LLVMOpaqueMCJITMemoryManager:
    """Python wrapper for C type cexecutionengine.LLVMOpaqueMCJITMemoryManager.
    
    Python wrapper for C type cexecutionengine.LLVMOpaqueMCJITMemoryManager.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMOpaqueMCJITMemoryManager from_ptr(cexecutionengine.LLVMOpaqueMCJITMemoryManager* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueMCJITMemoryManager`` objects from
        given ``cexecutionengine.LLVMOpaqueMCJITMemoryManager`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueMCJITMemoryManager wrapper = LLVMOpaqueMCJITMemoryManager.__new__(LLVMOpaqueMCJITMemoryManager)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueMCJITMemoryManager from_pyobj(object pyobj):
        """Derives a LLVMOpaqueMCJITMemoryManager from a Python object.

        Derives a LLVMOpaqueMCJITMemoryManager from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueMCJITMemoryManager`` reference, this method
        returns it directly. No new ``LLVMOpaqueMCJITMemoryManager`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMOpaqueMCJITMemoryManager`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueMCJITMemoryManager!
        """
        cdef LLVMOpaqueMCJITMemoryManager wrapper = LLVMOpaqueMCJITMemoryManager.__new__(LLVMOpaqueMCJITMemoryManager)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueMCJITMemoryManager):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cexecutionengine.LLVMOpaqueMCJITMemoryManager*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cexecutionengine.LLVMOpaqueMCJITMemoryManager*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <cexecutionengine.LLVMOpaqueMCJITMemoryManager*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueMCJITMemoryManager object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMMCJITMemoryManagerRef = LLVMOpaqueMCJITMemoryManager

cdef class LLVMMCJITCompilerOptions:
    """Python wrapper for C type cexecutionengine.LLVMMCJITCompilerOptions.
    
    Python wrapper for C type cexecutionengine.LLVMMCJITCompilerOptions.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMMCJITCompilerOptions from_ptr(cexecutionengine.LLVMMCJITCompilerOptions* ptr, bint owner=False):
        """Factory function to create ``LLVMMCJITCompilerOptions`` objects from
        given ``cexecutionengine.LLVMMCJITCompilerOptions`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMMCJITCompilerOptions wrapper = LLVMMCJITCompilerOptions.__new__(LLVMMCJITCompilerOptions)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMMCJITCompilerOptions from_pyobj(object pyobj):
        """Derives a LLVMMCJITCompilerOptions from a Python object.

        Derives a LLVMMCJITCompilerOptions from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMCJITCompilerOptions`` reference, this method
        returns it directly. No new ``LLVMMCJITCompilerOptions`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMMCJITCompilerOptions`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMMCJITCompilerOptions!
        """
        cdef LLVMMCJITCompilerOptions wrapper = LLVMMCJITCompilerOptions.__new__(LLVMMCJITCompilerOptions)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMMCJITCompilerOptions):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cexecutionengine.LLVMMCJITCompilerOptions*>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cexecutionengine.LLVMMCJITCompilerOptions*>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = <cexecutionengine.LLVMMCJITCompilerOptions*>wrapper._py_buffer.buf
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self.ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(cexecutionengine.LLVMMCJITCompilerOptions** ptr):
        ptr[0] = <cexecutionengine.LLVMMCJITCompilerOptions*>stdlib.malloc(sizeof(cexecutionengine.LLVMMCJITCompilerOptions))
        string.memset(<void*>ptr[0], 0, sizeof(cexecutionengine.LLVMMCJITCompilerOptions))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef LLVMMCJITCompilerOptions new():
        """Factory function to create LLVMMCJITCompilerOptions objects with
        newly allocated cexecutionengine.LLVMMCJITCompilerOptions"""
        cdef cexecutionengine.LLVMMCJITCompilerOptions* ptr
        LLVMMCJITCompilerOptions.__allocate(&ptr)
        return LLVMMCJITCompilerOptions.from_ptr(ptr, owner=True)

    @staticmethod
    cdef LLVMMCJITCompilerOptions from_value(cexecutionengine.LLVMMCJITCompilerOptions other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = LLVMMCJITCompilerOptions.new()
        string.memcpy(wrapper._ptr, &other, sizeof(cexecutionengine.LLVMMCJITCompilerOptions))
        return wrapper
   
    def __init__(self,**kwargs):
        """Constructor type LLVMMCJITCompilerOptions.

        Constructor for type LLVMMCJITCompilerOptions.

        Args:
            **kwargs: 
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        LLVMMCJITCompilerOptions.__allocate(&self._ptr)
        self.ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMMCJITCompilerOptions object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return sizeof(cexecutionengine.LLVMMCJITCompilerOptions)
    def get_OptLevel(self, i):
        """Get value ``OptLevel`` of ``self._ptr[i]``.
        """
        return self._ptr[i].OptLevel
    def set_OptLevel(self, i, unsigned int value):
        """Set value ``OptLevel`` of ``self._ptr[i]``.
        """
        self._ptr[i].OptLevel = value
    @property
    def OptLevel(self):
        """(undocumented)"""
        return self.get_OptLevel(0)
    @OptLevel.setter
    def OptLevel(self, unsigned int value):
        self.set_OptLevel(0,value)

    def get_CodeModel(self, i):
        """Get value of ``CodeModel`` of ``self._ptr[i]``.
        """
        return LLVMCodeModel(self._ptr[i].CodeModel)
    def set_CodeModel(self, i, value):
        """Set value ``CodeModel`` of ``self._ptr[i]``.
        """
        if not isinstance(value, LLVMCodeModel):
            raise TypeError("'value' must be of type 'LLVMCodeModel'")
        self._ptr[i].CodeModel = value.value
    @property
    def CodeModel(self):
        """(undocumented)"""
        return self.get_CodeModel(0)
    @CodeModel.setter
    def CodeModel(self, value):
        self.set_CodeModel(0,value)

    def get_NoFramePointerElim(self, i):
        """Get value ``NoFramePointerElim`` of ``self._ptr[i]``.
        """
        return self._ptr[i].NoFramePointerElim
    def set_NoFramePointerElim(self, i, int value):
        """Set value ``NoFramePointerElim`` of ``self._ptr[i]``.
        """
        self._ptr[i].NoFramePointerElim = value
    @property
    def NoFramePointerElim(self):
        """(undocumented)"""
        return self.get_NoFramePointerElim(0)
    @NoFramePointerElim.setter
    def NoFramePointerElim(self, int value):
        self.set_NoFramePointerElim(0,value)

    def get_EnableFastISel(self, i):
        """Get value ``EnableFastISel`` of ``self._ptr[i]``.
        """
        return self._ptr[i].EnableFastISel
    def set_EnableFastISel(self, i, int value):
        """Set value ``EnableFastISel`` of ``self._ptr[i]``.
        """
        self._ptr[i].EnableFastISel = value
    @property
    def EnableFastISel(self):
        """(undocumented)"""
        return self.get_EnableFastISel(0)
    @EnableFastISel.setter
    def EnableFastISel(self, int value):
        self.set_EnableFastISel(0,value)

    @staticmethod
    def PROPERTIES():
        return ["OptLevel","CodeModel","NoFramePointerElim","EnableFastISel"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


@cython.embedsignature(True)
def LLVMCreateGenericValueOfInt(object Ty, unsigned long long N, int IsSigned):
    r"""(No short description, might be part of a group.)

    Args:
        Ty (`~.LLVMOpaqueType`/`~.object`):
            (undocumented)

        N (`~.int`):
            (undocumented)

        IsSigned (`~.int`):
            (undocumented)
    """
    _LLVMCreateGenericValueOfInt__retval = LLVMOpaqueGenericValue.from_ptr(cexecutionengine.LLVMCreateGenericValueOfInt(
        LLVMOpaqueType.from_pyobj(Ty)._ptr,N,IsSigned))    # fully specified
    return (_LLVMCreateGenericValueOfInt__retval,)


@cython.embedsignature(True)
def LLVMCreateGenericValueOfPointer(object P):
    r"""(No short description, might be part of a group.)

    Args:
        P (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMCreateGenericValueOfPointer__retval = LLVMOpaqueGenericValue.from_ptr(cexecutionengine.LLVMCreateGenericValueOfPointer(
        <void *>rocm.llvm._util.types.Pointer.from_pyobj(P)._ptr))    # fully specified
    return (_LLVMCreateGenericValueOfPointer__retval,)


@cython.embedsignature(True)
def LLVMCreateGenericValueOfFloat(object Ty, double N):
    r"""(No short description, might be part of a group.)

    Args:
        Ty (`~.LLVMOpaqueType`/`~.object`):
            (undocumented)

        N (`~.float`/`~.int`):
            (undocumented)
    """
    _LLVMCreateGenericValueOfFloat__retval = LLVMOpaqueGenericValue.from_ptr(cexecutionengine.LLVMCreateGenericValueOfFloat(
        LLVMOpaqueType.from_pyobj(Ty)._ptr,N))    # fully specified
    return (_LLVMCreateGenericValueOfFloat__retval,)


@cython.embedsignature(True)
def LLVMGenericValueIntWidth(object GenValRef):
    r"""(No short description, might be part of a group.)

    Args:
        GenValRef (`~.LLVMOpaqueGenericValue`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef unsigned int _LLVMGenericValueIntWidth__retval = cexecutionengine.LLVMGenericValueIntWidth(
        LLVMOpaqueGenericValue.from_pyobj(GenValRef)._ptr)    # fully specified
    return (_LLVMGenericValueIntWidth__retval,)


@cython.embedsignature(True)
def LLVMGenericValueToInt(object GenVal, int IsSigned):
    r"""(No short description, might be part of a group.)

    Args:
        GenVal (`~.LLVMOpaqueGenericValue`/`~.object`):
            (undocumented)

        IsSigned (`~.int`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef unsigned long long _LLVMGenericValueToInt__retval = cexecutionengine.LLVMGenericValueToInt(
        LLVMOpaqueGenericValue.from_pyobj(GenVal)._ptr,IsSigned)    # fully specified
    return (_LLVMGenericValueToInt__retval,)


@cython.embedsignature(True)
def LLVMGenericValueToPointer(object GenVal):
    r"""(No short description, might be part of a group.)

    Args:
        GenVal (`~.LLVMOpaqueGenericValue`/`~.object`):
            (undocumented)
    """
    _LLVMGenericValueToPointer__retval = rocm.llvm._util.types.Pointer.from_ptr(cexecutionengine.LLVMGenericValueToPointer(
        LLVMOpaqueGenericValue.from_pyobj(GenVal)._ptr))    # fully specified
    return (_LLVMGenericValueToPointer__retval,)


@cython.embedsignature(True)
def LLVMGenericValueToFloat(object TyRef, object GenVal):
    r"""(No short description, might be part of a group.)

    Args:
        TyRef (`~.LLVMOpaqueType`/`~.object`):
            (undocumented)

        GenVal (`~.LLVMOpaqueGenericValue`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.float`
    """
    cdef double _LLVMGenericValueToFloat__retval = cexecutionengine.LLVMGenericValueToFloat(
        LLVMOpaqueType.from_pyobj(TyRef)._ptr,
        LLVMOpaqueGenericValue.from_pyobj(GenVal)._ptr)    # fully specified
    return (_LLVMGenericValueToFloat__retval,)


@cython.embedsignature(True)
def LLVMDisposeGenericValue(object GenVal):
    r"""(No short description, might be part of a group.)

    Args:
        GenVal (`~.LLVMOpaqueGenericValue`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMDisposeGenericValue(
        LLVMOpaqueGenericValue.from_pyobj(GenVal)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMCreateExecutionEngineForModule(object OutEE, object M, object OutError):
    r"""(No short description, might be part of a group.)

    Args:
        OutEE (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)

        OutError (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef int _LLVMCreateExecutionEngineForModule__retval = cexecutionengine.LLVMCreateExecutionEngineForModule(
        <cexecutionengine.LLVMExecutionEngineRef*>rocm.llvm._util.types.Pointer.from_pyobj(OutEE)._ptr,
        LLVMOpaqueModule.from_pyobj(M)._ptr,
        <char **>rocm.llvm._util.types.Pointer.from_pyobj(OutError)._ptr)    # fully specified
    return (_LLVMCreateExecutionEngineForModule__retval,)


@cython.embedsignature(True)
def LLVMCreateInterpreterForModule(object OutInterp, object M, object OutError):
    r"""(No short description, might be part of a group.)

    Args:
        OutInterp (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)

        OutError (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef int _LLVMCreateInterpreterForModule__retval = cexecutionengine.LLVMCreateInterpreterForModule(
        <cexecutionengine.LLVMExecutionEngineRef*>rocm.llvm._util.types.Pointer.from_pyobj(OutInterp)._ptr,
        LLVMOpaqueModule.from_pyobj(M)._ptr,
        <char **>rocm.llvm._util.types.Pointer.from_pyobj(OutError)._ptr)    # fully specified
    return (_LLVMCreateInterpreterForModule__retval,)


@cython.embedsignature(True)
def LLVMCreateJITCompilerForModule(object OutJIT, object M, unsigned int OptLevel, object OutError):
    r"""(No short description, might be part of a group.)

    Args:
        OutJIT (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)

        OptLevel (`~.int`):
            (undocumented)

        OutError (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef int _LLVMCreateJITCompilerForModule__retval = cexecutionengine.LLVMCreateJITCompilerForModule(
        <cexecutionengine.LLVMExecutionEngineRef*>rocm.llvm._util.types.Pointer.from_pyobj(OutJIT)._ptr,
        LLVMOpaqueModule.from_pyobj(M)._ptr,OptLevel,
        <char **>rocm.llvm._util.types.Pointer.from_pyobj(OutError)._ptr)    # fully specified
    return (_LLVMCreateJITCompilerForModule__retval,)


@cython.embedsignature(True)
def LLVMInitializeMCJITCompilerOptions(object Options, unsigned long SizeOfOptions):
    r"""(No short description, might be part of a group.)

    Args:
        Options (`~.LLVMMCJITCompilerOptions`/`~.object`):
            (undocumented)

        SizeOfOptions (`~.int`):
            (undocumented)
    """
    cexecutionengine.LLVMInitializeMCJITCompilerOptions(
        LLVMMCJITCompilerOptions.from_pyobj(Options)._ptr,SizeOfOptions)    # fully specified


@cython.embedsignature(True)
def LLVMCreateMCJITCompilerForModule(object OutJIT, object M, object Options, unsigned long SizeOfOptions, object OutError):
    r"""(No short description, might be part of a group.)

    Create an MCJIT execution engine for a module, with the given options. It is
    the responsibility of the caller to ensure that all fields in Options up to
    the given SizeOfOptions are initialized. It is correct to pass a smaller
    value of SizeOfOptions that omits some fields. The canonical way of using
    this is:

    LLVMMCJITCompilerOptions options;
    LLVMInitializeMCJITCompilerOptions(&options, sizeof(options));
    ... fill in those options you care about
    LLVMCreateMCJITCompilerForModule(&jit, mod, &options, sizeof(options),
                                     &error);

    Note that this is also correct, though possibly suboptimal:

    LLVMCreateMCJITCompilerForModule(&jit, mod, 0, 0, &error);

    Args:
        OutJIT (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)

        Options (`~.LLVMMCJITCompilerOptions`/`~.object`):
            (undocumented)

        SizeOfOptions (`~.int`):
            (undocumented)

        OutError (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef int _LLVMCreateMCJITCompilerForModule__retval = cexecutionengine.LLVMCreateMCJITCompilerForModule(
        <cexecutionengine.LLVMExecutionEngineRef*>rocm.llvm._util.types.Pointer.from_pyobj(OutJIT)._ptr,
        LLVMOpaqueModule.from_pyobj(M)._ptr,
        LLVMMCJITCompilerOptions.from_pyobj(Options)._ptr,SizeOfOptions,
        <char **>rocm.llvm._util.types.Pointer.from_pyobj(OutError)._ptr)    # fully specified
    return (_LLVMCreateMCJITCompilerForModule__retval,)


@cython.embedsignature(True)
def LLVMDisposeExecutionEngine(object EE):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMDisposeExecutionEngine(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMRunStaticConstructors(object EE):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMRunStaticConstructors(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMRunStaticDestructors(object EE):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMRunStaticDestructors(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMRunFunctionAsMain(object EE, object F, unsigned int ArgC, object ArgV, object EnvP):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        F (`~.LLVMOpaqueValue`/`~.object`):
            (undocumented)

        ArgC (`~.int`):
            (undocumented)

        ArgV (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        EnvP (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef int _LLVMRunFunctionAsMain__retval = cexecutionengine.LLVMRunFunctionAsMain(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr,
        LLVMOpaqueValue.from_pyobj(F)._ptr,ArgC,
        <const char *const *>rocm.llvm._util.types.Pointer.from_pyobj(ArgV)._ptr,
        <const char *const *>rocm.llvm._util.types.Pointer.from_pyobj(EnvP)._ptr)    # fully specified
    return (_LLVMRunFunctionAsMain__retval,)


@cython.embedsignature(True)
def LLVMRunFunction(object EE, object F, unsigned int NumArgs, object Args):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        F (`~.LLVMOpaqueValue`/`~.object`):
            (undocumented)

        NumArgs (`~.int`):
            (undocumented)

        Args (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _LLVMRunFunction__retval = LLVMOpaqueGenericValue.from_ptr(cexecutionengine.LLVMRunFunction(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr,
        LLVMOpaqueValue.from_pyobj(F)._ptr,NumArgs,
        <cexecutionengine.LLVMGenericValueRef*>rocm.llvm._util.types.Pointer.from_pyobj(Args)._ptr))    # fully specified
    return (_LLVMRunFunction__retval,)


@cython.embedsignature(True)
def LLVMFreeMachineCodeForFunction(object EE, object F):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        F (`~.LLVMOpaqueValue`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMFreeMachineCodeForFunction(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr,
        LLVMOpaqueValue.from_pyobj(F)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMAddModule(object EE, object M):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMAddModule(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr,
        LLVMOpaqueModule.from_pyobj(M)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMRemoveModule(object EE, object M, object OutMod, object OutError):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        M (`~.LLVMOpaqueModule`/`~.object`):
            (undocumented)

        OutMod (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

        OutError (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef int _LLVMRemoveModule__retval = cexecutionengine.LLVMRemoveModule(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr,
        LLVMOpaqueModule.from_pyobj(M)._ptr,
        <cexecutionengine.LLVMModuleRef*>rocm.llvm._util.types.Pointer.from_pyobj(OutMod)._ptr,
        <char **>rocm.llvm._util.types.Pointer.from_pyobj(OutError)._ptr)    # fully specified
    return (_LLVMRemoveModule__retval,)


@cython.embedsignature(True)
def LLVMFindFunction(object EE, const char * Name, object OutFn):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        Name (`~.bytes`):
            (undocumented)

        OutFn (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef int _LLVMFindFunction__retval = cexecutionengine.LLVMFindFunction(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr,Name,
        <cexecutionengine.LLVMValueRef*>rocm.llvm._util.types.Pointer.from_pyobj(OutFn)._ptr)    # fully specified
    return (_LLVMFindFunction__retval,)


@cython.embedsignature(True)
def LLVMRecompileAndRelinkFunction(object EE, object Fn):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        Fn (`~.LLVMOpaqueValue`/`~.object`):
            (undocumented)
    """
    _LLVMRecompileAndRelinkFunction__retval = rocm.llvm._util.types.Pointer.from_ptr(cexecutionengine.LLVMRecompileAndRelinkFunction(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr,
        LLVMOpaqueValue.from_pyobj(Fn)._ptr))    # fully specified
    return (_LLVMRecompileAndRelinkFunction__retval,)


@cython.embedsignature(True)
def LLVMGetExecutionEngineTargetData(object EE):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)
    """
    _LLVMGetExecutionEngineTargetData__retval = LLVMOpaqueTargetData.from_ptr(cexecutionengine.LLVMGetExecutionEngineTargetData(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr))    # fully specified
    return (_LLVMGetExecutionEngineTargetData__retval,)


@cython.embedsignature(True)
def LLVMGetExecutionEngineTargetMachine(object EE):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)
    """
    _LLVMGetExecutionEngineTargetMachine__retval = LLVMOpaqueTargetMachine.from_ptr(cexecutionengine.LLVMGetExecutionEngineTargetMachine(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr))    # fully specified
    return (_LLVMGetExecutionEngineTargetMachine__retval,)


@cython.embedsignature(True)
def LLVMAddGlobalMapping(object EE, object Global, object Addr):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        Global (`~.LLVMOpaqueValue`/`~.object`):
            (undocumented)

        Addr (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMAddGlobalMapping(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr,
        LLVMOpaqueValue.from_pyobj(Global)._ptr,
        <void *>rocm.llvm._util.types.Pointer.from_pyobj(Addr)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMGetPointerToGlobal(object EE, object Global):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        Global (`~.LLVMOpaqueValue`/`~.object`):
            (undocumented)
    """
    _LLVMGetPointerToGlobal__retval = rocm.llvm._util.types.Pointer.from_ptr(cexecutionengine.LLVMGetPointerToGlobal(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr,
        LLVMOpaqueValue.from_pyobj(Global)._ptr))    # fully specified
    return (_LLVMGetPointerToGlobal__retval,)


@cython.embedsignature(True)
def LLVMGetGlobalValueAddress(object EE, const char * Name):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        Name (`~.bytes`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef unsigned long _LLVMGetGlobalValueAddress__retval = cexecutionengine.LLVMGetGlobalValueAddress(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr,Name)    # fully specified
    return (_LLVMGetGlobalValueAddress__retval,)


@cython.embedsignature(True)
def LLVMGetFunctionAddress(object EE, const char * Name):
    r"""(No short description, might be part of a group.)

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        Name (`~.bytes`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef unsigned long _LLVMGetFunctionAddress__retval = cexecutionengine.LLVMGetFunctionAddress(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr,Name)    # fully specified
    return (_LLVMGetFunctionAddress__retval,)


@cython.embedsignature(True)
def LLVMExecutionEngineGetErrMsg(object EE, object OutError):
    r"""(No short description, might be part of a group.)

    Returns true on error, false on success. If true is returned then the error
    message is copied to OutStr and cleared in the ExecutionEngine instance.

    Args:
        EE (`~.LLVMOpaqueExecutionEngine`/`~.object`):
            (undocumented)

        OutError (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`
    """
    cdef int _LLVMExecutionEngineGetErrMsg__retval = cexecutionengine.LLVMExecutionEngineGetErrMsg(
        LLVMOpaqueExecutionEngine.from_pyobj(EE)._ptr,
        <char **>rocm.llvm._util.types.Pointer.from_pyobj(OutError)._ptr)    # fully specified
    return (_LLVMExecutionEngineGetErrMsg__retval,)


cdef class LLVMMemoryManagerAllocateCodeSectionCallback:
    """Python wrapper for C type cexecutionengine.LLVMMemoryManagerAllocateCodeSectionCallback.
    
    Python wrapper for C type cexecutionengine.LLVMMemoryManagerAllocateCodeSectionCallback.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMMemoryManagerAllocateCodeSectionCallback from_ptr(cexecutionengine.LLVMMemoryManagerAllocateCodeSectionCallback ptr, bint owner=False):
        """Factory function to create ``LLVMMemoryManagerAllocateCodeSectionCallback`` objects from
        given ``cexecutionengine.LLVMMemoryManagerAllocateCodeSectionCallback`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMMemoryManagerAllocateCodeSectionCallback wrapper = LLVMMemoryManagerAllocateCodeSectionCallback.__new__(LLVMMemoryManagerAllocateCodeSectionCallback)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMMemoryManagerAllocateCodeSectionCallback from_pyobj(object pyobj):
        """Derives a LLVMMemoryManagerAllocateCodeSectionCallback from a Python object.

        Derives a LLVMMemoryManagerAllocateCodeSectionCallback from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMemoryManagerAllocateCodeSectionCallback`` reference, this method
        returns it directly. No new ``LLVMMemoryManagerAllocateCodeSectionCallback`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMMemoryManagerAllocateCodeSectionCallback`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMMemoryManagerAllocateCodeSectionCallback!
        """
        cdef LLVMMemoryManagerAllocateCodeSectionCallback wrapper = LLVMMemoryManagerAllocateCodeSectionCallback.__new__(LLVMMemoryManagerAllocateCodeSectionCallback)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMMemoryManagerAllocateCodeSectionCallback):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cexecutionengine.LLVMMemoryManagerAllocateCodeSectionCallback>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cexecutionengine.LLVMMemoryManagerAllocateCodeSectionCallback>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <cexecutionengine.LLVMMemoryManagerAllocateCodeSectionCallback>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMMemoryManagerAllocateCodeSectionCallback object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMMemoryManagerAllocateDataSectionCallback:
    """Python wrapper for C type cexecutionengine.LLVMMemoryManagerAllocateDataSectionCallback.
    
    Python wrapper for C type cexecutionengine.LLVMMemoryManagerAllocateDataSectionCallback.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMMemoryManagerAllocateDataSectionCallback from_ptr(cexecutionengine.LLVMMemoryManagerAllocateDataSectionCallback ptr, bint owner=False):
        """Factory function to create ``LLVMMemoryManagerAllocateDataSectionCallback`` objects from
        given ``cexecutionengine.LLVMMemoryManagerAllocateDataSectionCallback`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMMemoryManagerAllocateDataSectionCallback wrapper = LLVMMemoryManagerAllocateDataSectionCallback.__new__(LLVMMemoryManagerAllocateDataSectionCallback)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMMemoryManagerAllocateDataSectionCallback from_pyobj(object pyobj):
        """Derives a LLVMMemoryManagerAllocateDataSectionCallback from a Python object.

        Derives a LLVMMemoryManagerAllocateDataSectionCallback from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMemoryManagerAllocateDataSectionCallback`` reference, this method
        returns it directly. No new ``LLVMMemoryManagerAllocateDataSectionCallback`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMMemoryManagerAllocateDataSectionCallback`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMMemoryManagerAllocateDataSectionCallback!
        """
        cdef LLVMMemoryManagerAllocateDataSectionCallback wrapper = LLVMMemoryManagerAllocateDataSectionCallback.__new__(LLVMMemoryManagerAllocateDataSectionCallback)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMMemoryManagerAllocateDataSectionCallback):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cexecutionengine.LLVMMemoryManagerAllocateDataSectionCallback>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cexecutionengine.LLVMMemoryManagerAllocateDataSectionCallback>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <cexecutionengine.LLVMMemoryManagerAllocateDataSectionCallback>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMMemoryManagerAllocateDataSectionCallback object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMMemoryManagerFinalizeMemoryCallback:
    """Python wrapper for C type cexecutionengine.LLVMMemoryManagerFinalizeMemoryCallback.
    
    Python wrapper for C type cexecutionengine.LLVMMemoryManagerFinalizeMemoryCallback.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMMemoryManagerFinalizeMemoryCallback from_ptr(cexecutionengine.LLVMMemoryManagerFinalizeMemoryCallback ptr, bint owner=False):
        """Factory function to create ``LLVMMemoryManagerFinalizeMemoryCallback`` objects from
        given ``cexecutionengine.LLVMMemoryManagerFinalizeMemoryCallback`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMMemoryManagerFinalizeMemoryCallback wrapper = LLVMMemoryManagerFinalizeMemoryCallback.__new__(LLVMMemoryManagerFinalizeMemoryCallback)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMMemoryManagerFinalizeMemoryCallback from_pyobj(object pyobj):
        """Derives a LLVMMemoryManagerFinalizeMemoryCallback from a Python object.

        Derives a LLVMMemoryManagerFinalizeMemoryCallback from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMemoryManagerFinalizeMemoryCallback`` reference, this method
        returns it directly. No new ``LLVMMemoryManagerFinalizeMemoryCallback`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMMemoryManagerFinalizeMemoryCallback`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMMemoryManagerFinalizeMemoryCallback!
        """
        cdef LLVMMemoryManagerFinalizeMemoryCallback wrapper = LLVMMemoryManagerFinalizeMemoryCallback.__new__(LLVMMemoryManagerFinalizeMemoryCallback)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMMemoryManagerFinalizeMemoryCallback):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cexecutionengine.LLVMMemoryManagerFinalizeMemoryCallback>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cexecutionengine.LLVMMemoryManagerFinalizeMemoryCallback>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <cexecutionengine.LLVMMemoryManagerFinalizeMemoryCallback>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMMemoryManagerFinalizeMemoryCallback object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class LLVMMemoryManagerDestroyCallback:
    """Python wrapper for C type cexecutionengine.LLVMMemoryManagerDestroyCallback.
    
    Python wrapper for C type cexecutionengine.LLVMMemoryManagerDestroyCallback.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.

    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    @staticmethod
    cdef LLVMMemoryManagerDestroyCallback from_ptr(cexecutionengine.LLVMMemoryManagerDestroyCallback ptr, bint owner=False):
        """Factory function to create ``LLVMMemoryManagerDestroyCallback`` objects from
        given ``cexecutionengine.LLVMMemoryManagerDestroyCallback`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMMemoryManagerDestroyCallback wrapper = LLVMMemoryManagerDestroyCallback.__new__(LLVMMemoryManagerDestroyCallback)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMMemoryManagerDestroyCallback from_pyobj(object pyobj):
        """Derives a LLVMMemoryManagerDestroyCallback from a Python object.

        Derives a LLVMMemoryManagerDestroyCallback from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMMemoryManagerDestroyCallback`` reference, this method
        returns it directly. No new ``LLVMMemoryManagerDestroyCallback`` is created in this case.

        Args:
            pyobj (object): Must be either `None`, a simple, contiguous buffer according to the buffer protocol,
                            or of type `LLVMMemoryManagerDestroyCallback`, `int`, or `ctypes.c_void_p`

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMMemoryManagerDestroyCallback!
        """
        cdef LLVMMemoryManagerDestroyCallback wrapper = LLVMMemoryManagerDestroyCallback.__new__(LLVMMemoryManagerDestroyCallback)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMMemoryManagerDestroyCallback):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = <cexecutionengine.LLVMMemoryManagerDestroyCallback>cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = <cexecutionengine.LLVMMemoryManagerDestroyCallback>cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif str(type(pyobj)).startswith("<class 'ctypes.CFUNCTYPE.") and str(type(pyobj)).endswith(".CFunctionType'>" ):
            wrapper._ptr = <cexecutionengine.LLVMMemoryManagerDestroyCallback>cpython.long.PyLong_AsVoidPtr(ctypes.cast(pyobj, ctypes.c_void_p).value)
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMMemoryManagerDestroyCallback object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implements as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def LLVMCreateSimpleMCJITMemoryManager(object Opaque, object AllocateCodeSection, object AllocateDataSection, object FinalizeMemory, object Destroy):
    r"""(No short description, might be part of a group.)

    Create a simple custom MCJIT memory manager. This memory manager can
    intercept allocations in a module-oblivious way. This will return NULL
    if any of the passed functions are NULL.

    Args:
        Opaque (`~.rocm.llvm._util.types.Pointer`/`~.object`):
            An opaque client object to pass back to the callbacks.

        AllocateCodeSection (`~.LLVMMemoryManagerAllocateCodeSectionCallback`/`~.object`):
            Allocate a block of memory for executable code.

        AllocateDataSection (`~.LLVMMemoryManagerAllocateDataSectionCallback`/`~.object`):
            Allocate a block of memory for data.

        FinalizeMemory (`~.LLVMMemoryManagerFinalizeMemoryCallback`/`~.object`):
            Set page permissions and flush cache. Return 0 on
            success, 1 on error.

        Destroy (`~.LLVMMemoryManagerDestroyCallback`/`~.object`):
            (undocumented)
    """
    _LLVMCreateSimpleMCJITMemoryManager__retval = LLVMOpaqueMCJITMemoryManager.from_ptr(cexecutionengine.LLVMCreateSimpleMCJITMemoryManager(
        <void *>rocm.llvm._util.types.Pointer.from_pyobj(Opaque)._ptr,
        LLVMMemoryManagerAllocateCodeSectionCallback.from_pyobj(AllocateCodeSection)._ptr,
        LLVMMemoryManagerAllocateDataSectionCallback.from_pyobj(AllocateDataSection)._ptr,
        LLVMMemoryManagerFinalizeMemoryCallback.from_pyobj(FinalizeMemory)._ptr,
        LLVMMemoryManagerDestroyCallback.from_pyobj(Destroy)._ptr))    # fully specified
    return (_LLVMCreateSimpleMCJITMemoryManager__retval,)


@cython.embedsignature(True)
def LLVMDisposeMCJITMemoryManager(object MM):
    r"""(No short description, might be part of a group.)

    Args:
        MM (`~.LLVMOpaqueMCJITMemoryManager`/`~.object`):
            (undocumented)
    """
    cexecutionengine.LLVMDisposeMCJITMemoryManager(
        LLVMOpaqueMCJITMemoryManager.from_pyobj(MM)._ptr)    # fully specified


@cython.embedsignature(True)
def LLVMCreateGDBRegistrationListener():
    r"""(No short description, might be part of a group.)
    """
    _LLVMCreateGDBRegistrationListener__retval = LLVMOpaqueJITEventListener.from_ptr(cexecutionengine.LLVMCreateGDBRegistrationListener())    # fully specified
    return (_LLVMCreateGDBRegistrationListener__retval,)


@cython.embedsignature(True)
def LLVMCreateIntelJITEventListener():
    r"""(No short description, might be part of a group.)
    """
    _LLVMCreateIntelJITEventListener__retval = LLVMOpaqueJITEventListener.from_ptr(cexecutionengine.LLVMCreateIntelJITEventListener())    # fully specified
    return (_LLVMCreateIntelJITEventListener__retval,)


@cython.embedsignature(True)
def LLVMCreateOProfileJITEventListener():
    r"""(No short description, might be part of a group.)
    """
    _LLVMCreateOProfileJITEventListener__retval = LLVMOpaqueJITEventListener.from_ptr(cexecutionengine.LLVMCreateOProfileJITEventListener())    # fully specified
    return (_LLVMCreateOProfileJITEventListener__retval,)


@cython.embedsignature(True)
def LLVMCreatePerfJITEventListener():
    r"""(No short description, might be part of a group.)
    """
    _LLVMCreatePerfJITEventListener__retval = LLVMOpaqueJITEventListener.from_ptr(cexecutionengine.LLVMCreatePerfJITEventListener())    # fully specified
    return (_LLVMCreatePerfJITEventListener__retval,)

__all__ = [
    "LLVMLinkInMCJIT",
    "LLVMLinkInInterpreter",
    "LLVMOpaqueGenericValue",
    "LLVMGenericValueRef",
    "LLVMOpaqueExecutionEngine",
    "LLVMExecutionEngineRef",
    "LLVMOpaqueMCJITMemoryManager",
    "LLVMMCJITMemoryManagerRef",
    "LLVMMCJITCompilerOptions",
    "LLVMCreateGenericValueOfInt",
    "LLVMCreateGenericValueOfPointer",
    "LLVMCreateGenericValueOfFloat",
    "LLVMGenericValueIntWidth",
    "LLVMGenericValueToInt",
    "LLVMGenericValueToPointer",
    "LLVMGenericValueToFloat",
    "LLVMDisposeGenericValue",
    "LLVMCreateExecutionEngineForModule",
    "LLVMCreateInterpreterForModule",
    "LLVMCreateJITCompilerForModule",
    "LLVMInitializeMCJITCompilerOptions",
    "LLVMCreateMCJITCompilerForModule",
    "LLVMDisposeExecutionEngine",
    "LLVMRunStaticConstructors",
    "LLVMRunStaticDestructors",
    "LLVMRunFunctionAsMain",
    "LLVMRunFunction",
    "LLVMFreeMachineCodeForFunction",
    "LLVMAddModule",
    "LLVMRemoveModule",
    "LLVMFindFunction",
    "LLVMRecompileAndRelinkFunction",
    "LLVMGetExecutionEngineTargetData",
    "LLVMGetExecutionEngineTargetMachine",
    "LLVMAddGlobalMapping",
    "LLVMGetPointerToGlobal",
    "LLVMGetGlobalValueAddress",
    "LLVMGetFunctionAddress",
    "LLVMExecutionEngineGetErrMsg",
    "LLVMMemoryManagerAllocateCodeSectionCallback",
    "LLVMMemoryManagerAllocateDataSectionCallback",
    "LLVMMemoryManagerFinalizeMemoryCallback",
    "LLVMMemoryManagerDestroyCallback",
    "LLVMCreateSimpleMCJITMemoryManager",
    "LLVMDisposeMCJITMemoryManager",
    "LLVMCreateGDBRegistrationListener",
    "LLVMCreateIntelJITEventListener",
    "LLVMCreateOProfileJITEventListener",
    "LLVMCreatePerfJITEventListener",
]