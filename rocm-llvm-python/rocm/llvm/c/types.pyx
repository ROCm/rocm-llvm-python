# MIT License
#
# Copyright (c) 2023-2024 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    LLVMMemoryBufferRef:
        alias of `~.LLVMOpaqueMemoryBuffer`

    LLVMContextRef:
        alias of `~.LLVMOpaqueContext`

    LLVMModuleRef:
        alias of `~.LLVMOpaqueModule`

    LLVMTypeRef:
        alias of `~.LLVMOpaqueType`

    LLVMValueRef:
        alias of `~.LLVMOpaqueValue`

    LLVMBasicBlockRef:
        alias of `~.LLVMOpaqueBasicBlock`

    LLVMMetadataRef:
        alias of `~.LLVMOpaqueMetadata`

    LLVMNamedMDNodeRef:
        alias of `~.LLVMOpaqueNamedMDNode`

    LLVMValueMetadataEntry:
        alias of `~.LLVMOpaqueValueMetadataEntry`

    LLVMBuilderRef:
        alias of `~.LLVMOpaqueBuilder`

    LLVMDIBuilderRef:
        alias of `~.LLVMOpaqueDIBuilder`

    LLVMModuleProviderRef:
        alias of `~.LLVMOpaqueModuleProvider`

    LLVMPassManagerRef:
        alias of `~.LLVMOpaquePassManager`

    LLVMPassRegistryRef:
        alias of `~.LLVMOpaquePassRegistry`

    LLVMUseRef:
        alias of `~.LLVMOpaqueUse`

    LLVMAttributeRef:
        alias of `~.LLVMOpaqueAttributeRef`

    LLVMDiagnosticInfoRef:
        alias of `~.LLVMOpaqueDiagnosticInfo`

    LLVMComdatRef:
        alias of `~.LLVMComdat`

    LLVMModuleFlagEntry:
        alias of `~.LLVMOpaqueModuleFlagEntry`

    LLVMJITEventListenerRef:
        alias of `~.LLVMOpaqueJITEventListener`

    LLVMBinaryRef:
        alias of `~.LLVMOpaqueBinary`

"""

import cython
import ctypes
import enum


cdef class LLVMOpaqueMemoryBuffer(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueMemoryBuffer.

    Python wrapper for cdef class ctypes.LLVMOpaqueMemoryBuffer.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueMemoryBuffer* getElementPtr(self):
        return <ctypes.LLVMOpaqueMemoryBuffer*>self._ptr

    @staticmethod
    cdef LLVMOpaqueMemoryBuffer fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueMemoryBuffer`` objects from
        given ``ctypes.LLVMOpaqueMemoryBuffer`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueMemoryBuffer wrapper = LLVMOpaqueMemoryBuffer.__new__(LLVMOpaqueMemoryBuffer)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueMemoryBuffer from a Python object.

        Derives a LLVMOpaqueMemoryBuffer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueMemoryBuffer`` reference, this method
        returns it directly. No new ``LLVMOpaqueMemoryBuffer`` is created in this case.
        """
        return LLVMOpaqueMemoryBuffer.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueMemoryBuffer fromPyobj(object pyobj):
        """Creates a LLVMOpaqueMemoryBuffer from a Python object.

        Derives a LLVMOpaqueMemoryBuffer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueMemoryBuffer`` reference, this method
        returns it directly. No new ``LLVMOpaqueMemoryBuffer`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueMemoryBuffer`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueMemoryBuffer!
        """
        cdef LLVMOpaqueMemoryBuffer wrapper

        if isinstance(pyobj,LLVMOpaqueMemoryBuffer):
            return pyobj
        else:
            wrapper = LLVMOpaqueMemoryBuffer.__new__(LLVMOpaqueMemoryBuffer)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueMemoryBuffer object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMMemoryBufferRef = LLVMOpaqueMemoryBuffer

cdef class LLVMOpaqueContext(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueContext.

    Python wrapper for cdef class ctypes.LLVMOpaqueContext.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueContext* getElementPtr(self):
        return <ctypes.LLVMOpaqueContext*>self._ptr

    @staticmethod
    cdef LLVMOpaqueContext fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueContext`` objects from
        given ``ctypes.LLVMOpaqueContext`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueContext wrapper = LLVMOpaqueContext.__new__(LLVMOpaqueContext)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueContext from a Python object.

        Derives a LLVMOpaqueContext from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueContext`` reference, this method
        returns it directly. No new ``LLVMOpaqueContext`` is created in this case.
        """
        return LLVMOpaqueContext.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueContext fromPyobj(object pyobj):
        """Creates a LLVMOpaqueContext from a Python object.

        Derives a LLVMOpaqueContext from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueContext`` reference, this method
        returns it directly. No new ``LLVMOpaqueContext`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueContext`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueContext!
        """
        cdef LLVMOpaqueContext wrapper

        if isinstance(pyobj,LLVMOpaqueContext):
            return pyobj
        else:
            wrapper = LLVMOpaqueContext.__new__(LLVMOpaqueContext)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueContext object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMContextRef = LLVMOpaqueContext

cdef class LLVMOpaqueModule(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueModule.

    Python wrapper for cdef class ctypes.LLVMOpaqueModule.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueModule* getElementPtr(self):
        return <ctypes.LLVMOpaqueModule*>self._ptr

    @staticmethod
    cdef LLVMOpaqueModule fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueModule`` objects from
        given ``ctypes.LLVMOpaqueModule`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueModule wrapper = LLVMOpaqueModule.__new__(LLVMOpaqueModule)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueModule from a Python object.

        Derives a LLVMOpaqueModule from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueModule`` reference, this method
        returns it directly. No new ``LLVMOpaqueModule`` is created in this case.
        """
        return LLVMOpaqueModule.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueModule fromPyobj(object pyobj):
        """Creates a LLVMOpaqueModule from a Python object.

        Derives a LLVMOpaqueModule from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueModule`` reference, this method
        returns it directly. No new ``LLVMOpaqueModule`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueModule`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueModule!
        """
        cdef LLVMOpaqueModule wrapper

        if isinstance(pyobj,LLVMOpaqueModule):
            return pyobj
        else:
            wrapper = LLVMOpaqueModule.__new__(LLVMOpaqueModule)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueModule object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMModuleRef = LLVMOpaqueModule

cdef class LLVMOpaqueType(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueType.

    Python wrapper for cdef class ctypes.LLVMOpaqueType.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueType* getElementPtr(self):
        return <ctypes.LLVMOpaqueType*>self._ptr

    @staticmethod
    cdef LLVMOpaqueType fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueType`` objects from
        given ``ctypes.LLVMOpaqueType`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueType wrapper = LLVMOpaqueType.__new__(LLVMOpaqueType)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueType from a Python object.

        Derives a LLVMOpaqueType from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueType`` reference, this method
        returns it directly. No new ``LLVMOpaqueType`` is created in this case.
        """
        return LLVMOpaqueType.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueType fromPyobj(object pyobj):
        """Creates a LLVMOpaqueType from a Python object.

        Derives a LLVMOpaqueType from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueType`` reference, this method
        returns it directly. No new ``LLVMOpaqueType`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueType`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueType!
        """
        cdef LLVMOpaqueType wrapper

        if isinstance(pyobj,LLVMOpaqueType):
            return pyobj
        else:
            wrapper = LLVMOpaqueType.__new__(LLVMOpaqueType)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueType object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMTypeRef = LLVMOpaqueType

cdef class LLVMOpaqueValue(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueValue.

    Python wrapper for cdef class ctypes.LLVMOpaqueValue.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueValue* getElementPtr(self):
        return <ctypes.LLVMOpaqueValue*>self._ptr

    @staticmethod
    cdef LLVMOpaqueValue fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueValue`` objects from
        given ``ctypes.LLVMOpaqueValue`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueValue wrapper = LLVMOpaqueValue.__new__(LLVMOpaqueValue)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueValue from a Python object.

        Derives a LLVMOpaqueValue from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueValue`` reference, this method
        returns it directly. No new ``LLVMOpaqueValue`` is created in this case.
        """
        return LLVMOpaqueValue.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueValue fromPyobj(object pyobj):
        """Creates a LLVMOpaqueValue from a Python object.

        Derives a LLVMOpaqueValue from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueValue`` reference, this method
        returns it directly. No new ``LLVMOpaqueValue`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueValue`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueValue!
        """
        cdef LLVMOpaqueValue wrapper

        if isinstance(pyobj,LLVMOpaqueValue):
            return pyobj
        else:
            wrapper = LLVMOpaqueValue.__new__(LLVMOpaqueValue)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueValue object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMValueRef = LLVMOpaqueValue

cdef class LLVMOpaqueBasicBlock(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueBasicBlock.

    Python wrapper for cdef class ctypes.LLVMOpaqueBasicBlock.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueBasicBlock* getElementPtr(self):
        return <ctypes.LLVMOpaqueBasicBlock*>self._ptr

    @staticmethod
    cdef LLVMOpaqueBasicBlock fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueBasicBlock`` objects from
        given ``ctypes.LLVMOpaqueBasicBlock`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueBasicBlock wrapper = LLVMOpaqueBasicBlock.__new__(LLVMOpaqueBasicBlock)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueBasicBlock from a Python object.

        Derives a LLVMOpaqueBasicBlock from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueBasicBlock`` reference, this method
        returns it directly. No new ``LLVMOpaqueBasicBlock`` is created in this case.
        """
        return LLVMOpaqueBasicBlock.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueBasicBlock fromPyobj(object pyobj):
        """Creates a LLVMOpaqueBasicBlock from a Python object.

        Derives a LLVMOpaqueBasicBlock from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueBasicBlock`` reference, this method
        returns it directly. No new ``LLVMOpaqueBasicBlock`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueBasicBlock`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueBasicBlock!
        """
        cdef LLVMOpaqueBasicBlock wrapper

        if isinstance(pyobj,LLVMOpaqueBasicBlock):
            return pyobj
        else:
            wrapper = LLVMOpaqueBasicBlock.__new__(LLVMOpaqueBasicBlock)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueBasicBlock object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMBasicBlockRef = LLVMOpaqueBasicBlock

cdef class LLVMOpaqueMetadata(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueMetadata.

    Python wrapper for cdef class ctypes.LLVMOpaqueMetadata.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueMetadata* getElementPtr(self):
        return <ctypes.LLVMOpaqueMetadata*>self._ptr

    @staticmethod
    cdef LLVMOpaqueMetadata fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueMetadata`` objects from
        given ``ctypes.LLVMOpaqueMetadata`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueMetadata wrapper = LLVMOpaqueMetadata.__new__(LLVMOpaqueMetadata)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueMetadata from a Python object.

        Derives a LLVMOpaqueMetadata from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueMetadata`` reference, this method
        returns it directly. No new ``LLVMOpaqueMetadata`` is created in this case.
        """
        return LLVMOpaqueMetadata.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueMetadata fromPyobj(object pyobj):
        """Creates a LLVMOpaqueMetadata from a Python object.

        Derives a LLVMOpaqueMetadata from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueMetadata`` reference, this method
        returns it directly. No new ``LLVMOpaqueMetadata`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueMetadata`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueMetadata!
        """
        cdef LLVMOpaqueMetadata wrapper

        if isinstance(pyobj,LLVMOpaqueMetadata):
            return pyobj
        else:
            wrapper = LLVMOpaqueMetadata.__new__(LLVMOpaqueMetadata)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueMetadata object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMMetadataRef = LLVMOpaqueMetadata

cdef class LLVMOpaqueNamedMDNode(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueNamedMDNode.

    Python wrapper for cdef class ctypes.LLVMOpaqueNamedMDNode.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueNamedMDNode* getElementPtr(self):
        return <ctypes.LLVMOpaqueNamedMDNode*>self._ptr

    @staticmethod
    cdef LLVMOpaqueNamedMDNode fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueNamedMDNode`` objects from
        given ``ctypes.LLVMOpaqueNamedMDNode`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueNamedMDNode wrapper = LLVMOpaqueNamedMDNode.__new__(LLVMOpaqueNamedMDNode)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueNamedMDNode from a Python object.

        Derives a LLVMOpaqueNamedMDNode from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueNamedMDNode`` reference, this method
        returns it directly. No new ``LLVMOpaqueNamedMDNode`` is created in this case.
        """
        return LLVMOpaqueNamedMDNode.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueNamedMDNode fromPyobj(object pyobj):
        """Creates a LLVMOpaqueNamedMDNode from a Python object.

        Derives a LLVMOpaqueNamedMDNode from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueNamedMDNode`` reference, this method
        returns it directly. No new ``LLVMOpaqueNamedMDNode`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueNamedMDNode`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueNamedMDNode!
        """
        cdef LLVMOpaqueNamedMDNode wrapper

        if isinstance(pyobj,LLVMOpaqueNamedMDNode):
            return pyobj
        else:
            wrapper = LLVMOpaqueNamedMDNode.__new__(LLVMOpaqueNamedMDNode)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueNamedMDNode object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMNamedMDNodeRef = LLVMOpaqueNamedMDNode

cdef class LLVMOpaqueValueMetadataEntry(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueValueMetadataEntry.

    Python wrapper for cdef class ctypes.LLVMOpaqueValueMetadataEntry.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueValueMetadataEntry* getElementPtr(self):
        return <ctypes.LLVMOpaqueValueMetadataEntry*>self._ptr

    @staticmethod
    cdef LLVMOpaqueValueMetadataEntry fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueValueMetadataEntry`` objects from
        given ``ctypes.LLVMOpaqueValueMetadataEntry`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueValueMetadataEntry wrapper = LLVMOpaqueValueMetadataEntry.__new__(LLVMOpaqueValueMetadataEntry)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueValueMetadataEntry from a Python object.

        Derives a LLVMOpaqueValueMetadataEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueValueMetadataEntry`` reference, this method
        returns it directly. No new ``LLVMOpaqueValueMetadataEntry`` is created in this case.
        """
        return LLVMOpaqueValueMetadataEntry.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueValueMetadataEntry fromPyobj(object pyobj):
        """Creates a LLVMOpaqueValueMetadataEntry from a Python object.

        Derives a LLVMOpaqueValueMetadataEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueValueMetadataEntry`` reference, this method
        returns it directly. No new ``LLVMOpaqueValueMetadataEntry`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueValueMetadataEntry`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueValueMetadataEntry!
        """
        cdef LLVMOpaqueValueMetadataEntry wrapper

        if isinstance(pyobj,LLVMOpaqueValueMetadataEntry):
            return pyobj
        else:
            wrapper = LLVMOpaqueValueMetadataEntry.__new__(LLVMOpaqueValueMetadataEntry)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueValueMetadataEntry object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMValueMetadataEntry = LLVMOpaqueValueMetadataEntry

cdef class LLVMOpaqueBuilder(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueBuilder.

    Python wrapper for cdef class ctypes.LLVMOpaqueBuilder.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueBuilder* getElementPtr(self):
        return <ctypes.LLVMOpaqueBuilder*>self._ptr

    @staticmethod
    cdef LLVMOpaqueBuilder fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueBuilder`` objects from
        given ``ctypes.LLVMOpaqueBuilder`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueBuilder wrapper = LLVMOpaqueBuilder.__new__(LLVMOpaqueBuilder)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueBuilder from a Python object.

        Derives a LLVMOpaqueBuilder from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueBuilder`` reference, this method
        returns it directly. No new ``LLVMOpaqueBuilder`` is created in this case.
        """
        return LLVMOpaqueBuilder.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueBuilder fromPyobj(object pyobj):
        """Creates a LLVMOpaqueBuilder from a Python object.

        Derives a LLVMOpaqueBuilder from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueBuilder`` reference, this method
        returns it directly. No new ``LLVMOpaqueBuilder`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueBuilder`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueBuilder!
        """
        cdef LLVMOpaqueBuilder wrapper

        if isinstance(pyobj,LLVMOpaqueBuilder):
            return pyobj
        else:
            wrapper = LLVMOpaqueBuilder.__new__(LLVMOpaqueBuilder)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueBuilder object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMBuilderRef = LLVMOpaqueBuilder

cdef class LLVMOpaqueDIBuilder(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueDIBuilder.

    Python wrapper for cdef class ctypes.LLVMOpaqueDIBuilder.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueDIBuilder* getElementPtr(self):
        return <ctypes.LLVMOpaqueDIBuilder*>self._ptr

    @staticmethod
    cdef LLVMOpaqueDIBuilder fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueDIBuilder`` objects from
        given ``ctypes.LLVMOpaqueDIBuilder`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueDIBuilder wrapper = LLVMOpaqueDIBuilder.__new__(LLVMOpaqueDIBuilder)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueDIBuilder from a Python object.

        Derives a LLVMOpaqueDIBuilder from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueDIBuilder`` reference, this method
        returns it directly. No new ``LLVMOpaqueDIBuilder`` is created in this case.
        """
        return LLVMOpaqueDIBuilder.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueDIBuilder fromPyobj(object pyobj):
        """Creates a LLVMOpaqueDIBuilder from a Python object.

        Derives a LLVMOpaqueDIBuilder from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueDIBuilder`` reference, this method
        returns it directly. No new ``LLVMOpaqueDIBuilder`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueDIBuilder`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueDIBuilder!
        """
        cdef LLVMOpaqueDIBuilder wrapper

        if isinstance(pyobj,LLVMOpaqueDIBuilder):
            return pyobj
        else:
            wrapper = LLVMOpaqueDIBuilder.__new__(LLVMOpaqueDIBuilder)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueDIBuilder object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMDIBuilderRef = LLVMOpaqueDIBuilder

cdef class LLVMOpaqueModuleProvider(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueModuleProvider.

    Python wrapper for cdef class ctypes.LLVMOpaqueModuleProvider.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueModuleProvider* getElementPtr(self):
        return <ctypes.LLVMOpaqueModuleProvider*>self._ptr

    @staticmethod
    cdef LLVMOpaqueModuleProvider fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueModuleProvider`` objects from
        given ``ctypes.LLVMOpaqueModuleProvider`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueModuleProvider wrapper = LLVMOpaqueModuleProvider.__new__(LLVMOpaqueModuleProvider)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueModuleProvider from a Python object.

        Derives a LLVMOpaqueModuleProvider from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueModuleProvider`` reference, this method
        returns it directly. No new ``LLVMOpaqueModuleProvider`` is created in this case.
        """
        return LLVMOpaqueModuleProvider.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueModuleProvider fromPyobj(object pyobj):
        """Creates a LLVMOpaqueModuleProvider from a Python object.

        Derives a LLVMOpaqueModuleProvider from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueModuleProvider`` reference, this method
        returns it directly. No new ``LLVMOpaqueModuleProvider`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueModuleProvider`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueModuleProvider!
        """
        cdef LLVMOpaqueModuleProvider wrapper

        if isinstance(pyobj,LLVMOpaqueModuleProvider):
            return pyobj
        else:
            wrapper = LLVMOpaqueModuleProvider.__new__(LLVMOpaqueModuleProvider)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueModuleProvider object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMModuleProviderRef = LLVMOpaqueModuleProvider

cdef class LLVMOpaquePassManager(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaquePassManager.

    Python wrapper for cdef class ctypes.LLVMOpaquePassManager.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaquePassManager* getElementPtr(self):
        return <ctypes.LLVMOpaquePassManager*>self._ptr

    @staticmethod
    cdef LLVMOpaquePassManager fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaquePassManager`` objects from
        given ``ctypes.LLVMOpaquePassManager`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaquePassManager wrapper = LLVMOpaquePassManager.__new__(LLVMOpaquePassManager)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaquePassManager from a Python object.

        Derives a LLVMOpaquePassManager from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaquePassManager`` reference, this method
        returns it directly. No new ``LLVMOpaquePassManager`` is created in this case.
        """
        return LLVMOpaquePassManager.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaquePassManager fromPyobj(object pyobj):
        """Creates a LLVMOpaquePassManager from a Python object.

        Derives a LLVMOpaquePassManager from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaquePassManager`` reference, this method
        returns it directly. No new ``LLVMOpaquePassManager`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaquePassManager`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaquePassManager!
        """
        cdef LLVMOpaquePassManager wrapper

        if isinstance(pyobj,LLVMOpaquePassManager):
            return pyobj
        else:
            wrapper = LLVMOpaquePassManager.__new__(LLVMOpaquePassManager)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaquePassManager object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMPassManagerRef = LLVMOpaquePassManager

cdef class LLVMOpaquePassRegistry(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaquePassRegistry.

    Python wrapper for cdef class ctypes.LLVMOpaquePassRegistry.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaquePassRegistry* getElementPtr(self):
        return <ctypes.LLVMOpaquePassRegistry*>self._ptr

    @staticmethod
    cdef LLVMOpaquePassRegistry fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaquePassRegistry`` objects from
        given ``ctypes.LLVMOpaquePassRegistry`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaquePassRegistry wrapper = LLVMOpaquePassRegistry.__new__(LLVMOpaquePassRegistry)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaquePassRegistry from a Python object.

        Derives a LLVMOpaquePassRegistry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaquePassRegistry`` reference, this method
        returns it directly. No new ``LLVMOpaquePassRegistry`` is created in this case.
        """
        return LLVMOpaquePassRegistry.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaquePassRegistry fromPyobj(object pyobj):
        """Creates a LLVMOpaquePassRegistry from a Python object.

        Derives a LLVMOpaquePassRegistry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaquePassRegistry`` reference, this method
        returns it directly. No new ``LLVMOpaquePassRegistry`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaquePassRegistry`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaquePassRegistry!
        """
        cdef LLVMOpaquePassRegistry wrapper

        if isinstance(pyobj,LLVMOpaquePassRegistry):
            return pyobj
        else:
            wrapper = LLVMOpaquePassRegistry.__new__(LLVMOpaquePassRegistry)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaquePassRegistry object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMPassRegistryRef = LLVMOpaquePassRegistry

cdef class LLVMOpaqueUse(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueUse.

    Python wrapper for cdef class ctypes.LLVMOpaqueUse.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueUse* getElementPtr(self):
        return <ctypes.LLVMOpaqueUse*>self._ptr

    @staticmethod
    cdef LLVMOpaqueUse fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueUse`` objects from
        given ``ctypes.LLVMOpaqueUse`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueUse wrapper = LLVMOpaqueUse.__new__(LLVMOpaqueUse)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueUse from a Python object.

        Derives a LLVMOpaqueUse from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueUse`` reference, this method
        returns it directly. No new ``LLVMOpaqueUse`` is created in this case.
        """
        return LLVMOpaqueUse.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueUse fromPyobj(object pyobj):
        """Creates a LLVMOpaqueUse from a Python object.

        Derives a LLVMOpaqueUse from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueUse`` reference, this method
        returns it directly. No new ``LLVMOpaqueUse`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueUse`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueUse!
        """
        cdef LLVMOpaqueUse wrapper

        if isinstance(pyobj,LLVMOpaqueUse):
            return pyobj
        else:
            wrapper = LLVMOpaqueUse.__new__(LLVMOpaqueUse)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueUse object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMUseRef = LLVMOpaqueUse

cdef class LLVMOpaqueAttributeRef(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueAttributeRef.

    Python wrapper for cdef class ctypes.LLVMOpaqueAttributeRef.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueAttributeRef* getElementPtr(self):
        return <ctypes.LLVMOpaqueAttributeRef*>self._ptr

    @staticmethod
    cdef LLVMOpaqueAttributeRef fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueAttributeRef`` objects from
        given ``ctypes.LLVMOpaqueAttributeRef`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueAttributeRef wrapper = LLVMOpaqueAttributeRef.__new__(LLVMOpaqueAttributeRef)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueAttributeRef from a Python object.

        Derives a LLVMOpaqueAttributeRef from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueAttributeRef`` reference, this method
        returns it directly. No new ``LLVMOpaqueAttributeRef`` is created in this case.
        """
        return LLVMOpaqueAttributeRef.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueAttributeRef fromPyobj(object pyobj):
        """Creates a LLVMOpaqueAttributeRef from a Python object.

        Derives a LLVMOpaqueAttributeRef from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueAttributeRef`` reference, this method
        returns it directly. No new ``LLVMOpaqueAttributeRef`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueAttributeRef`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueAttributeRef!
        """
        cdef LLVMOpaqueAttributeRef wrapper

        if isinstance(pyobj,LLVMOpaqueAttributeRef):
            return pyobj
        else:
            wrapper = LLVMOpaqueAttributeRef.__new__(LLVMOpaqueAttributeRef)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueAttributeRef object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMAttributeRef = LLVMOpaqueAttributeRef

cdef class LLVMOpaqueDiagnosticInfo(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueDiagnosticInfo.

    Python wrapper for cdef class ctypes.LLVMOpaqueDiagnosticInfo.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueDiagnosticInfo* getElementPtr(self):
        return <ctypes.LLVMOpaqueDiagnosticInfo*>self._ptr

    @staticmethod
    cdef LLVMOpaqueDiagnosticInfo fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueDiagnosticInfo`` objects from
        given ``ctypes.LLVMOpaqueDiagnosticInfo`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueDiagnosticInfo wrapper = LLVMOpaqueDiagnosticInfo.__new__(LLVMOpaqueDiagnosticInfo)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueDiagnosticInfo from a Python object.

        Derives a LLVMOpaqueDiagnosticInfo from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueDiagnosticInfo`` reference, this method
        returns it directly. No new ``LLVMOpaqueDiagnosticInfo`` is created in this case.
        """
        return LLVMOpaqueDiagnosticInfo.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueDiagnosticInfo fromPyobj(object pyobj):
        """Creates a LLVMOpaqueDiagnosticInfo from a Python object.

        Derives a LLVMOpaqueDiagnosticInfo from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueDiagnosticInfo`` reference, this method
        returns it directly. No new ``LLVMOpaqueDiagnosticInfo`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueDiagnosticInfo`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueDiagnosticInfo!
        """
        cdef LLVMOpaqueDiagnosticInfo wrapper

        if isinstance(pyobj,LLVMOpaqueDiagnosticInfo):
            return pyobj
        else:
            wrapper = LLVMOpaqueDiagnosticInfo.__new__(LLVMOpaqueDiagnosticInfo)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueDiagnosticInfo object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMDiagnosticInfoRef = LLVMOpaqueDiagnosticInfo

cdef class LLVMComdat(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMComdat.

    Python wrapper for cdef class ctypes.LLVMComdat.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMComdat* getElementPtr(self):
        return <ctypes.LLVMComdat*>self._ptr

    @staticmethod
    cdef LLVMComdat fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMComdat`` objects from
        given ``ctypes.LLVMComdat`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMComdat wrapper = LLVMComdat.__new__(LLVMComdat)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMComdat from a Python object.

        Derives a LLVMComdat from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMComdat`` reference, this method
        returns it directly. No new ``LLVMComdat`` is created in this case.
        """
        return LLVMComdat.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMComdat fromPyobj(object pyobj):
        """Creates a LLVMComdat from a Python object.

        Derives a LLVMComdat from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMComdat`` reference, this method
        returns it directly. No new ``LLVMComdat`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMComdat`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMComdat!
        """
        cdef LLVMComdat wrapper

        if isinstance(pyobj,LLVMComdat):
            return pyobj
        else:
            wrapper = LLVMComdat.__new__(LLVMComdat)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMComdat object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMComdatRef = LLVMComdat

cdef class LLVMOpaqueModuleFlagEntry(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueModuleFlagEntry.

    Python wrapper for cdef class ctypes.LLVMOpaqueModuleFlagEntry.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueModuleFlagEntry* getElementPtr(self):
        return <ctypes.LLVMOpaqueModuleFlagEntry*>self._ptr

    @staticmethod
    cdef LLVMOpaqueModuleFlagEntry fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueModuleFlagEntry`` objects from
        given ``ctypes.LLVMOpaqueModuleFlagEntry`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueModuleFlagEntry wrapper = LLVMOpaqueModuleFlagEntry.__new__(LLVMOpaqueModuleFlagEntry)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueModuleFlagEntry from a Python object.

        Derives a LLVMOpaqueModuleFlagEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueModuleFlagEntry`` reference, this method
        returns it directly. No new ``LLVMOpaqueModuleFlagEntry`` is created in this case.
        """
        return LLVMOpaqueModuleFlagEntry.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueModuleFlagEntry fromPyobj(object pyobj):
        """Creates a LLVMOpaqueModuleFlagEntry from a Python object.

        Derives a LLVMOpaqueModuleFlagEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueModuleFlagEntry`` reference, this method
        returns it directly. No new ``LLVMOpaqueModuleFlagEntry`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueModuleFlagEntry`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueModuleFlagEntry!
        """
        cdef LLVMOpaqueModuleFlagEntry wrapper

        if isinstance(pyobj,LLVMOpaqueModuleFlagEntry):
            return pyobj
        else:
            wrapper = LLVMOpaqueModuleFlagEntry.__new__(LLVMOpaqueModuleFlagEntry)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueModuleFlagEntry object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMModuleFlagEntry = LLVMOpaqueModuleFlagEntry

cdef class LLVMOpaqueJITEventListener(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueJITEventListener.

    Python wrapper for cdef class ctypes.LLVMOpaqueJITEventListener.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueJITEventListener* getElementPtr(self):
        return <ctypes.LLVMOpaqueJITEventListener*>self._ptr

    @staticmethod
    cdef LLVMOpaqueJITEventListener fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueJITEventListener`` objects from
        given ``ctypes.LLVMOpaqueJITEventListener`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueJITEventListener wrapper = LLVMOpaqueJITEventListener.__new__(LLVMOpaqueJITEventListener)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueJITEventListener from a Python object.

        Derives a LLVMOpaqueJITEventListener from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueJITEventListener`` reference, this method
        returns it directly. No new ``LLVMOpaqueJITEventListener`` is created in this case.
        """
        return LLVMOpaqueJITEventListener.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueJITEventListener fromPyobj(object pyobj):
        """Creates a LLVMOpaqueJITEventListener from a Python object.

        Derives a LLVMOpaqueJITEventListener from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueJITEventListener`` reference, this method
        returns it directly. No new ``LLVMOpaqueJITEventListener`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueJITEventListener`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueJITEventListener!
        """
        cdef LLVMOpaqueJITEventListener wrapper

        if isinstance(pyobj,LLVMOpaqueJITEventListener):
            return pyobj
        else:
            wrapper = LLVMOpaqueJITEventListener.__new__(LLVMOpaqueJITEventListener)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueJITEventListener object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMJITEventListenerRef = LLVMOpaqueJITEventListener

cdef class LLVMOpaqueBinary(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueBinary.

    Python wrapper for cdef class ctypes.LLVMOpaqueBinary.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueBinary* getElementPtr(self):
        return <ctypes.LLVMOpaqueBinary*>self._ptr

    @staticmethod
    cdef LLVMOpaqueBinary fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueBinary`` objects from
        given ``ctypes.LLVMOpaqueBinary`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueBinary wrapper = LLVMOpaqueBinary.__new__(LLVMOpaqueBinary)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a LLVMOpaqueBinary from a Python object.

        Derives a LLVMOpaqueBinary from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueBinary`` reference, this method
        returns it directly. No new ``LLVMOpaqueBinary`` is created in this case.
        """
        return LLVMOpaqueBinary.fromPyobj(pyobj)

    @staticmethod
    cdef LLVMOpaqueBinary fromPyobj(object pyobj):
        """Creates a LLVMOpaqueBinary from a Python object.

        Derives a LLVMOpaqueBinary from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueBinary`` reference, this method
        returns it directly. No new ``LLVMOpaqueBinary`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueBinary`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueBinary!
        """
        cdef LLVMOpaqueBinary wrapper

        if isinstance(pyobj,LLVMOpaqueBinary):
            return pyobj
        else:
            wrapper = LLVMOpaqueBinary.__new__(LLVMOpaqueBinary)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<LLVMOpaqueBinary object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMBinaryRef = LLVMOpaqueBinary

__all__ = [
    "LLVMOpaqueMemoryBuffer",
    "LLVMMemoryBufferRef",
    "LLVMOpaqueContext",
    "LLVMContextRef",
    "LLVMOpaqueModule",
    "LLVMModuleRef",
    "LLVMOpaqueType",
    "LLVMTypeRef",
    "LLVMOpaqueValue",
    "LLVMValueRef",
    "LLVMOpaqueBasicBlock",
    "LLVMBasicBlockRef",
    "LLVMOpaqueMetadata",
    "LLVMMetadataRef",
    "LLVMOpaqueNamedMDNode",
    "LLVMNamedMDNodeRef",
    "LLVMOpaqueValueMetadataEntry",
    "LLVMValueMetadataEntry",
    "LLVMOpaqueBuilder",
    "LLVMBuilderRef",
    "LLVMOpaqueDIBuilder",
    "LLVMDIBuilderRef",
    "LLVMOpaqueModuleProvider",
    "LLVMModuleProviderRef",
    "LLVMOpaquePassManager",
    "LLVMPassManagerRef",
    "LLVMOpaquePassRegistry",
    "LLVMPassRegistryRef",
    "LLVMOpaqueUse",
    "LLVMUseRef",
    "LLVMOpaqueAttributeRef",
    "LLVMAttributeRef",
    "LLVMOpaqueDiagnosticInfo",
    "LLVMDiagnosticInfoRef",
    "LLVMComdat",
    "LLVMComdatRef",
    "LLVMOpaqueModuleFlagEntry",
    "LLVMModuleFlagEntry",
    "LLVMOpaqueJITEventListener",
    "LLVMJITEventListenerRef",
    "LLVMOpaqueBinary",
    "LLVMBinaryRef",
]