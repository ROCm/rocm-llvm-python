# MIT License
# 
# Copyright (c) 2023 Advanced Micro Devices, Inc.
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    LLVMMemoryBufferRef:
        alias of `~.LLVMOpaqueMemoryBuffer`

    LLVMContextRef:
        alias of `~.LLVMOpaqueContext`

    LLVMModuleRef:
        alias of `~.LLVMOpaqueModule`

    LLVMTypeRef:
        alias of `~.LLVMOpaqueType`

    LLVMValueRef:
        alias of `~.LLVMOpaqueValue`

    LLVMBasicBlockRef:
        alias of `~.LLVMOpaqueBasicBlock`

    LLVMMetadataRef:
        alias of `~.LLVMOpaqueMetadata`

    LLVMNamedMDNodeRef:
        alias of `~.LLVMOpaqueNamedMDNode`

    LLVMValueMetadataEntry:
        alias of `~.LLVMOpaqueValueMetadataEntry`

    LLVMBuilderRef:
        alias of `~.LLVMOpaqueBuilder`

    LLVMDIBuilderRef:
        alias of `~.LLVMOpaqueDIBuilder`

    LLVMModuleProviderRef:
        alias of `~.LLVMOpaqueModuleProvider`

    LLVMPassManagerRef:
        alias of `~.LLVMOpaquePassManager`

    LLVMPassRegistryRef:
        alias of `~.LLVMOpaquePassRegistry`

    LLVMUseRef:
        alias of `~.LLVMOpaqueUse`

    LLVMAttributeRef:
        alias of `~.LLVMOpaqueAttributeRef`

    LLVMDiagnosticInfoRef:
        alias of `~.LLVMOpaqueDiagnosticInfo`

    LLVMComdatRef:
        alias of `~.LLVMComdat`

    LLVMModuleFlagEntry:
        alias of `~.LLVMOpaqueModuleFlagEntry`

    LLVMJITEventListenerRef:
        alias of `~.LLVMOpaqueJITEventListener`

    LLVMBinaryRef:
        alias of `~.LLVMOpaqueBinary`

"""

import cython
import ctypes
import enum


cdef class LLVMOpaqueMemoryBuffer(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueMemoryBuffer.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueMemoryBuffer.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueMemoryBuffer* get_element_ptr(self):
        return <ctypes.LLVMOpaqueMemoryBuffer*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueMemoryBuffer from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueMemoryBuffer`` objects from
        given ``ctypes.LLVMOpaqueMemoryBuffer`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueMemoryBuffer wrapper = LLVMOpaqueMemoryBuffer.__new__(LLVMOpaqueMemoryBuffer)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueMemoryBuffer from_pyobj(object pyobj):
        """Derives a LLVMOpaqueMemoryBuffer from a Python object.

        Derives a LLVMOpaqueMemoryBuffer from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueMemoryBuffer`` reference, this method
        returns it directly. No new ``LLVMOpaqueMemoryBuffer`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueMemoryBuffer`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueMemoryBuffer!
        """
        cdef LLVMOpaqueMemoryBuffer wrapper = LLVMOpaqueMemoryBuffer.__new__(LLVMOpaqueMemoryBuffer)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueMemoryBuffer):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueMemoryBuffer object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMMemoryBufferRef = LLVMOpaqueMemoryBuffer

cdef class LLVMOpaqueContext(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueContext.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueContext.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueContext* get_element_ptr(self):
        return <ctypes.LLVMOpaqueContext*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueContext from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueContext`` objects from
        given ``ctypes.LLVMOpaqueContext`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueContext wrapper = LLVMOpaqueContext.__new__(LLVMOpaqueContext)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueContext from_pyobj(object pyobj):
        """Derives a LLVMOpaqueContext from a Python object.

        Derives a LLVMOpaqueContext from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueContext`` reference, this method
        returns it directly. No new ``LLVMOpaqueContext`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueContext`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueContext!
        """
        cdef LLVMOpaqueContext wrapper = LLVMOpaqueContext.__new__(LLVMOpaqueContext)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueContext):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueContext object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMContextRef = LLVMOpaqueContext

cdef class LLVMOpaqueModule(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueModule.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueModule.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueModule* get_element_ptr(self):
        return <ctypes.LLVMOpaqueModule*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueModule from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueModule`` objects from
        given ``ctypes.LLVMOpaqueModule`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueModule wrapper = LLVMOpaqueModule.__new__(LLVMOpaqueModule)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueModule from_pyobj(object pyobj):
        """Derives a LLVMOpaqueModule from a Python object.

        Derives a LLVMOpaqueModule from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueModule`` reference, this method
        returns it directly. No new ``LLVMOpaqueModule`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueModule`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueModule!
        """
        cdef LLVMOpaqueModule wrapper = LLVMOpaqueModule.__new__(LLVMOpaqueModule)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueModule):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueModule object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMModuleRef = LLVMOpaqueModule

cdef class LLVMOpaqueType(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueType.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueType.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueType* get_element_ptr(self):
        return <ctypes.LLVMOpaqueType*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueType from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueType`` objects from
        given ``ctypes.LLVMOpaqueType`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueType wrapper = LLVMOpaqueType.__new__(LLVMOpaqueType)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueType from_pyobj(object pyobj):
        """Derives a LLVMOpaqueType from a Python object.

        Derives a LLVMOpaqueType from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueType`` reference, this method
        returns it directly. No new ``LLVMOpaqueType`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueType`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueType!
        """
        cdef LLVMOpaqueType wrapper = LLVMOpaqueType.__new__(LLVMOpaqueType)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueType):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueType object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMTypeRef = LLVMOpaqueType

cdef class LLVMOpaqueValue(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueValue.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueValue.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueValue* get_element_ptr(self):
        return <ctypes.LLVMOpaqueValue*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueValue from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueValue`` objects from
        given ``ctypes.LLVMOpaqueValue`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueValue wrapper = LLVMOpaqueValue.__new__(LLVMOpaqueValue)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueValue from_pyobj(object pyobj):
        """Derives a LLVMOpaqueValue from a Python object.

        Derives a LLVMOpaqueValue from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueValue`` reference, this method
        returns it directly. No new ``LLVMOpaqueValue`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueValue`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueValue!
        """
        cdef LLVMOpaqueValue wrapper = LLVMOpaqueValue.__new__(LLVMOpaqueValue)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueValue):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueValue object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMValueRef = LLVMOpaqueValue

cdef class LLVMOpaqueBasicBlock(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueBasicBlock.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueBasicBlock.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueBasicBlock* get_element_ptr(self):
        return <ctypes.LLVMOpaqueBasicBlock*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueBasicBlock from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueBasicBlock`` objects from
        given ``ctypes.LLVMOpaqueBasicBlock`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueBasicBlock wrapper = LLVMOpaqueBasicBlock.__new__(LLVMOpaqueBasicBlock)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueBasicBlock from_pyobj(object pyobj):
        """Derives a LLVMOpaqueBasicBlock from a Python object.

        Derives a LLVMOpaqueBasicBlock from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueBasicBlock`` reference, this method
        returns it directly. No new ``LLVMOpaqueBasicBlock`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueBasicBlock`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueBasicBlock!
        """
        cdef LLVMOpaqueBasicBlock wrapper = LLVMOpaqueBasicBlock.__new__(LLVMOpaqueBasicBlock)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueBasicBlock):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueBasicBlock object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMBasicBlockRef = LLVMOpaqueBasicBlock

cdef class LLVMOpaqueMetadata(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueMetadata.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueMetadata.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueMetadata* get_element_ptr(self):
        return <ctypes.LLVMOpaqueMetadata*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueMetadata from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueMetadata`` objects from
        given ``ctypes.LLVMOpaqueMetadata`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueMetadata wrapper = LLVMOpaqueMetadata.__new__(LLVMOpaqueMetadata)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueMetadata from_pyobj(object pyobj):
        """Derives a LLVMOpaqueMetadata from a Python object.

        Derives a LLVMOpaqueMetadata from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueMetadata`` reference, this method
        returns it directly. No new ``LLVMOpaqueMetadata`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueMetadata`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueMetadata!
        """
        cdef LLVMOpaqueMetadata wrapper = LLVMOpaqueMetadata.__new__(LLVMOpaqueMetadata)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueMetadata):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueMetadata object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMMetadataRef = LLVMOpaqueMetadata

cdef class LLVMOpaqueNamedMDNode(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueNamedMDNode.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueNamedMDNode.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueNamedMDNode* get_element_ptr(self):
        return <ctypes.LLVMOpaqueNamedMDNode*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueNamedMDNode from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueNamedMDNode`` objects from
        given ``ctypes.LLVMOpaqueNamedMDNode`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueNamedMDNode wrapper = LLVMOpaqueNamedMDNode.__new__(LLVMOpaqueNamedMDNode)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueNamedMDNode from_pyobj(object pyobj):
        """Derives a LLVMOpaqueNamedMDNode from a Python object.

        Derives a LLVMOpaqueNamedMDNode from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueNamedMDNode`` reference, this method
        returns it directly. No new ``LLVMOpaqueNamedMDNode`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueNamedMDNode`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueNamedMDNode!
        """
        cdef LLVMOpaqueNamedMDNode wrapper = LLVMOpaqueNamedMDNode.__new__(LLVMOpaqueNamedMDNode)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueNamedMDNode):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueNamedMDNode object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMNamedMDNodeRef = LLVMOpaqueNamedMDNode

cdef class LLVMOpaqueValueMetadataEntry(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueValueMetadataEntry.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueValueMetadataEntry.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueValueMetadataEntry* get_element_ptr(self):
        return <ctypes.LLVMOpaqueValueMetadataEntry*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueValueMetadataEntry from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueValueMetadataEntry`` objects from
        given ``ctypes.LLVMOpaqueValueMetadataEntry`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueValueMetadataEntry wrapper = LLVMOpaqueValueMetadataEntry.__new__(LLVMOpaqueValueMetadataEntry)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueValueMetadataEntry from_pyobj(object pyobj):
        """Derives a LLVMOpaqueValueMetadataEntry from a Python object.

        Derives a LLVMOpaqueValueMetadataEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueValueMetadataEntry`` reference, this method
        returns it directly. No new ``LLVMOpaqueValueMetadataEntry`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueValueMetadataEntry`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueValueMetadataEntry!
        """
        cdef LLVMOpaqueValueMetadataEntry wrapper = LLVMOpaqueValueMetadataEntry.__new__(LLVMOpaqueValueMetadataEntry)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueValueMetadataEntry):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueValueMetadataEntry object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMValueMetadataEntry = LLVMOpaqueValueMetadataEntry

cdef class LLVMOpaqueBuilder(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueBuilder.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueBuilder.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueBuilder* get_element_ptr(self):
        return <ctypes.LLVMOpaqueBuilder*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueBuilder from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueBuilder`` objects from
        given ``ctypes.LLVMOpaqueBuilder`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueBuilder wrapper = LLVMOpaqueBuilder.__new__(LLVMOpaqueBuilder)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueBuilder from_pyobj(object pyobj):
        """Derives a LLVMOpaqueBuilder from a Python object.

        Derives a LLVMOpaqueBuilder from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueBuilder`` reference, this method
        returns it directly. No new ``LLVMOpaqueBuilder`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueBuilder`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueBuilder!
        """
        cdef LLVMOpaqueBuilder wrapper = LLVMOpaqueBuilder.__new__(LLVMOpaqueBuilder)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueBuilder):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueBuilder object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMBuilderRef = LLVMOpaqueBuilder

cdef class LLVMOpaqueDIBuilder(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueDIBuilder.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueDIBuilder.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueDIBuilder* get_element_ptr(self):
        return <ctypes.LLVMOpaqueDIBuilder*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueDIBuilder from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueDIBuilder`` objects from
        given ``ctypes.LLVMOpaqueDIBuilder`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueDIBuilder wrapper = LLVMOpaqueDIBuilder.__new__(LLVMOpaqueDIBuilder)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueDIBuilder from_pyobj(object pyobj):
        """Derives a LLVMOpaqueDIBuilder from a Python object.

        Derives a LLVMOpaqueDIBuilder from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueDIBuilder`` reference, this method
        returns it directly. No new ``LLVMOpaqueDIBuilder`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueDIBuilder`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueDIBuilder!
        """
        cdef LLVMOpaqueDIBuilder wrapper = LLVMOpaqueDIBuilder.__new__(LLVMOpaqueDIBuilder)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueDIBuilder):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueDIBuilder object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMDIBuilderRef = LLVMOpaqueDIBuilder

cdef class LLVMOpaqueModuleProvider(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueModuleProvider.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueModuleProvider.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueModuleProvider* get_element_ptr(self):
        return <ctypes.LLVMOpaqueModuleProvider*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueModuleProvider from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueModuleProvider`` objects from
        given ``ctypes.LLVMOpaqueModuleProvider`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueModuleProvider wrapper = LLVMOpaqueModuleProvider.__new__(LLVMOpaqueModuleProvider)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueModuleProvider from_pyobj(object pyobj):
        """Derives a LLVMOpaqueModuleProvider from a Python object.

        Derives a LLVMOpaqueModuleProvider from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueModuleProvider`` reference, this method
        returns it directly. No new ``LLVMOpaqueModuleProvider`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueModuleProvider`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueModuleProvider!
        """
        cdef LLVMOpaqueModuleProvider wrapper = LLVMOpaqueModuleProvider.__new__(LLVMOpaqueModuleProvider)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueModuleProvider):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueModuleProvider object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMModuleProviderRef = LLVMOpaqueModuleProvider

cdef class LLVMOpaquePassManager(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaquePassManager.
    
    Python wrapper for cdef class ctypes.LLVMOpaquePassManager.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaquePassManager* get_element_ptr(self):
        return <ctypes.LLVMOpaquePassManager*>self._ptr
        
    @staticmethod
    cdef LLVMOpaquePassManager from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaquePassManager`` objects from
        given ``ctypes.LLVMOpaquePassManager`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaquePassManager wrapper = LLVMOpaquePassManager.__new__(LLVMOpaquePassManager)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaquePassManager from_pyobj(object pyobj):
        """Derives a LLVMOpaquePassManager from a Python object.

        Derives a LLVMOpaquePassManager from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaquePassManager`` reference, this method
        returns it directly. No new ``LLVMOpaquePassManager`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaquePassManager`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaquePassManager!
        """
        cdef LLVMOpaquePassManager wrapper = LLVMOpaquePassManager.__new__(LLVMOpaquePassManager)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaquePassManager):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaquePassManager object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMPassManagerRef = LLVMOpaquePassManager

cdef class LLVMOpaquePassRegistry(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaquePassRegistry.
    
    Python wrapper for cdef class ctypes.LLVMOpaquePassRegistry.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaquePassRegistry* get_element_ptr(self):
        return <ctypes.LLVMOpaquePassRegistry*>self._ptr
        
    @staticmethod
    cdef LLVMOpaquePassRegistry from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaquePassRegistry`` objects from
        given ``ctypes.LLVMOpaquePassRegistry`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaquePassRegistry wrapper = LLVMOpaquePassRegistry.__new__(LLVMOpaquePassRegistry)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaquePassRegistry from_pyobj(object pyobj):
        """Derives a LLVMOpaquePassRegistry from a Python object.

        Derives a LLVMOpaquePassRegistry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaquePassRegistry`` reference, this method
        returns it directly. No new ``LLVMOpaquePassRegistry`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaquePassRegistry`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaquePassRegistry!
        """
        cdef LLVMOpaquePassRegistry wrapper = LLVMOpaquePassRegistry.__new__(LLVMOpaquePassRegistry)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaquePassRegistry):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaquePassRegistry object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMPassRegistryRef = LLVMOpaquePassRegistry

cdef class LLVMOpaqueUse(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueUse.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueUse.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueUse* get_element_ptr(self):
        return <ctypes.LLVMOpaqueUse*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueUse from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueUse`` objects from
        given ``ctypes.LLVMOpaqueUse`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueUse wrapper = LLVMOpaqueUse.__new__(LLVMOpaqueUse)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueUse from_pyobj(object pyobj):
        """Derives a LLVMOpaqueUse from a Python object.

        Derives a LLVMOpaqueUse from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueUse`` reference, this method
        returns it directly. No new ``LLVMOpaqueUse`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueUse`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueUse!
        """
        cdef LLVMOpaqueUse wrapper = LLVMOpaqueUse.__new__(LLVMOpaqueUse)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueUse):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueUse object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMUseRef = LLVMOpaqueUse

cdef class LLVMOpaqueAttributeRef(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueAttributeRef.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueAttributeRef.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueAttributeRef* get_element_ptr(self):
        return <ctypes.LLVMOpaqueAttributeRef*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueAttributeRef from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueAttributeRef`` objects from
        given ``ctypes.LLVMOpaqueAttributeRef`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueAttributeRef wrapper = LLVMOpaqueAttributeRef.__new__(LLVMOpaqueAttributeRef)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueAttributeRef from_pyobj(object pyobj):
        """Derives a LLVMOpaqueAttributeRef from a Python object.

        Derives a LLVMOpaqueAttributeRef from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueAttributeRef`` reference, this method
        returns it directly. No new ``LLVMOpaqueAttributeRef`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueAttributeRef`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueAttributeRef!
        """
        cdef LLVMOpaqueAttributeRef wrapper = LLVMOpaqueAttributeRef.__new__(LLVMOpaqueAttributeRef)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueAttributeRef):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueAttributeRef object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMAttributeRef = LLVMOpaqueAttributeRef

cdef class LLVMOpaqueDiagnosticInfo(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueDiagnosticInfo.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueDiagnosticInfo.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueDiagnosticInfo* get_element_ptr(self):
        return <ctypes.LLVMOpaqueDiagnosticInfo*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueDiagnosticInfo from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueDiagnosticInfo`` objects from
        given ``ctypes.LLVMOpaqueDiagnosticInfo`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueDiagnosticInfo wrapper = LLVMOpaqueDiagnosticInfo.__new__(LLVMOpaqueDiagnosticInfo)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueDiagnosticInfo from_pyobj(object pyobj):
        """Derives a LLVMOpaqueDiagnosticInfo from a Python object.

        Derives a LLVMOpaqueDiagnosticInfo from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueDiagnosticInfo`` reference, this method
        returns it directly. No new ``LLVMOpaqueDiagnosticInfo`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueDiagnosticInfo`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueDiagnosticInfo!
        """
        cdef LLVMOpaqueDiagnosticInfo wrapper = LLVMOpaqueDiagnosticInfo.__new__(LLVMOpaqueDiagnosticInfo)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueDiagnosticInfo):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueDiagnosticInfo object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMDiagnosticInfoRef = LLVMOpaqueDiagnosticInfo

cdef class LLVMComdat(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMComdat.
    
    Python wrapper for cdef class ctypes.LLVMComdat.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMComdat* get_element_ptr(self):
        return <ctypes.LLVMComdat*>self._ptr
        
    @staticmethod
    cdef LLVMComdat from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMComdat`` objects from
        given ``ctypes.LLVMComdat`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMComdat wrapper = LLVMComdat.__new__(LLVMComdat)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMComdat from_pyobj(object pyobj):
        """Derives a LLVMComdat from a Python object.

        Derives a LLVMComdat from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMComdat`` reference, this method
        returns it directly. No new ``LLVMComdat`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMComdat`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMComdat!
        """
        cdef LLVMComdat wrapper = LLVMComdat.__new__(LLVMComdat)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMComdat):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMComdat object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMComdatRef = LLVMComdat

cdef class LLVMOpaqueModuleFlagEntry(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueModuleFlagEntry.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueModuleFlagEntry.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueModuleFlagEntry* get_element_ptr(self):
        return <ctypes.LLVMOpaqueModuleFlagEntry*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueModuleFlagEntry from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueModuleFlagEntry`` objects from
        given ``ctypes.LLVMOpaqueModuleFlagEntry`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueModuleFlagEntry wrapper = LLVMOpaqueModuleFlagEntry.__new__(LLVMOpaqueModuleFlagEntry)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueModuleFlagEntry from_pyobj(object pyobj):
        """Derives a LLVMOpaqueModuleFlagEntry from a Python object.

        Derives a LLVMOpaqueModuleFlagEntry from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueModuleFlagEntry`` reference, this method
        returns it directly. No new ``LLVMOpaqueModuleFlagEntry`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueModuleFlagEntry`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueModuleFlagEntry!
        """
        cdef LLVMOpaqueModuleFlagEntry wrapper = LLVMOpaqueModuleFlagEntry.__new__(LLVMOpaqueModuleFlagEntry)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueModuleFlagEntry):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueModuleFlagEntry object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMModuleFlagEntry = LLVMOpaqueModuleFlagEntry

cdef class LLVMOpaqueJITEventListener(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueJITEventListener.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueJITEventListener.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueJITEventListener* get_element_ptr(self):
        return <ctypes.LLVMOpaqueJITEventListener*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueJITEventListener from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueJITEventListener`` objects from
        given ``ctypes.LLVMOpaqueJITEventListener`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueJITEventListener wrapper = LLVMOpaqueJITEventListener.__new__(LLVMOpaqueJITEventListener)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueJITEventListener from_pyobj(object pyobj):
        """Derives a LLVMOpaqueJITEventListener from a Python object.

        Derives a LLVMOpaqueJITEventListener from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueJITEventListener`` reference, this method
        returns it directly. No new ``LLVMOpaqueJITEventListener`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueJITEventListener`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueJITEventListener!
        """
        cdef LLVMOpaqueJITEventListener wrapper = LLVMOpaqueJITEventListener.__new__(LLVMOpaqueJITEventListener)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueJITEventListener):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueJITEventListener object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMJITEventListenerRef = LLVMOpaqueJITEventListener

cdef class LLVMOpaqueBinary(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class ctypes.LLVMOpaqueBinary.
    
    Python wrapper for cdef class ctypes.LLVMOpaqueBinary.

    If this type is initialized via its `__init__` method, it allocates a member of the underlying C type and
    destroys it again if the wrapper type is deallocted.

    This type also serves as adapter when appearing as argument type in a function signature.
    In this case, the type can further be initialized from the following Python objects
    that you can pass as argument instead:
    
    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:
      
      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.
      
    * `ctypes.c_void_p`:
      
      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.
    
    
    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self.ptr_owner = False
        self._py_buffer_acquired = False

    cdef ctypes.LLVMOpaqueBinary* get_element_ptr(self):
        return <ctypes.LLVMOpaqueBinary*>self._ptr
        
    @staticmethod
    cdef LLVMOpaqueBinary from_ptr(void* ptr, bint owner=False):
        """Factory function to create ``LLVMOpaqueBinary`` objects from
        given ``ctypes.LLVMOpaqueBinary`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef LLVMOpaqueBinary wrapper = LLVMOpaqueBinary.__new__(LLVMOpaqueBinary)
        wrapper._ptr = ptr
        wrapper.ptr_owner = owner
        return wrapper

    @staticmethod
    cdef LLVMOpaqueBinary from_pyobj(object pyobj):
        """Derives a LLVMOpaqueBinary from a Python object.

        Derives a LLVMOpaqueBinary from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``LLVMOpaqueBinary`` reference, this method
        returns it directly. No new ``LLVMOpaqueBinary`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `LLVMOpaqueBinary`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of LLVMOpaqueBinary!
        """
        cdef LLVMOpaqueBinary wrapper = LLVMOpaqueBinary.__new__(LLVMOpaqueBinary)
        cdef dict cuda_array_interface = getattr(pyobj, "__cuda_array_interface__", None)

        if pyobj is None:
            wrapper._ptr = NULL
        elif isinstance(pyobj,LLVMOpaqueBinary):
            return pyobj
        elif isinstance(pyobj,int):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj)
        elif isinstance(pyobj,ctypes.c_void_p):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(pyobj.value) if pyobj.value != None else NULL
        elif cpython.buffer.PyObject_CheckBuffer(pyobj):
            err = cpython.buffer.PyObject_GetBuffer( 
                pyobj,
                &wrapper._py_buffer, 
                cpython.buffer.PyBUF_SIMPLE | cpython.buffer.PyBUF_ANY_CONTIGUOUS
            )
            if err == -1:
                raise RuntimeError("failed to create simple, contiguous Py_buffer from Python object")
            wrapper._py_buffer_acquired = True
            wrapper._ptr = wrapper._py_buffer.buf
        elif isinstance(pyobj,rocm.llvm._util.types.Pointer):
            wrapper._ptr = cpython.long.PyLong_AsVoidPtr(int(pyobj))
        else:
            raise TypeError(f"unsupported input type: '{str(type(pyobj))}'")
        return wrapper
    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
    
    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)
    def __repr__(self):
        return f"<LLVMOpaqueBinary object, self.ptr={int(self)}>"
    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with 
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))
    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


LLVMBinaryRef = LLVMOpaqueBinary

__all__ = [
    "LLVMOpaqueMemoryBuffer",
    "LLVMMemoryBufferRef",
    "LLVMOpaqueContext",
    "LLVMContextRef",
    "LLVMOpaqueModule",
    "LLVMModuleRef",
    "LLVMOpaqueType",
    "LLVMTypeRef",
    "LLVMOpaqueValue",
    "LLVMValueRef",
    "LLVMOpaqueBasicBlock",
    "LLVMBasicBlockRef",
    "LLVMOpaqueMetadata",
    "LLVMMetadataRef",
    "LLVMOpaqueNamedMDNode",
    "LLVMNamedMDNodeRef",
    "LLVMOpaqueValueMetadataEntry",
    "LLVMValueMetadataEntry",
    "LLVMOpaqueBuilder",
    "LLVMBuilderRef",
    "LLVMOpaqueDIBuilder",
    "LLVMDIBuilderRef",
    "LLVMOpaqueModuleProvider",
    "LLVMModuleProviderRef",
    "LLVMOpaquePassManager",
    "LLVMPassManagerRef",
    "LLVMOpaquePassRegistry",
    "LLVMPassRegistryRef",
    "LLVMOpaqueUse",
    "LLVMUseRef",
    "LLVMOpaqueAttributeRef",
    "LLVMAttributeRef",
    "LLVMOpaqueDiagnosticInfo",
    "LLVMDiagnosticInfoRef",
    "LLVMComdat",
    "LLVMComdatRef",
    "LLVMOpaqueModuleFlagEntry",
    "LLVMModuleFlagEntry",
    "LLVMOpaqueJITEventListener",
    "LLVMJITEventListenerRef",
    "LLVMOpaqueBinary",
    "LLVMBinaryRef",
]