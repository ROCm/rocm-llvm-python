# MIT License
#
# Copyright (c) 2021-2025 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    AMD_COMGR_INTERFACE_VERSION_MAJOR (`~.int`):
        Macro constant.

    AMD_COMGR_INTERFACE_VERSION_MINOR (`~.int`):
        Macro constant.

    amd_comgr_status_t:
        alias of `~.amd_comgr_status_s`

    amd_comgr_language_t:
        alias of `~.amd_comgr_language_s`

    amd_comgr_data_kind_t:
        alias of `~.amd_comgr_data_kind_s`

    amd_comgr_data_t:
        alias of `~.amd_comgr_data_s`

    amd_comgr_data_set_t:
        alias of `~.amd_comgr_data_set_s`

    amd_comgr_action_info_t:
        alias of `~.amd_comgr_action_info_s`

    amd_comgr_metadata_node_t:
        alias of `~.amd_comgr_metadata_node_s`

    amd_comgr_symbol_t:
        alias of `~.amd_comgr_symbol_s`

    amd_comgr_disassembly_info_t:
        alias of `~.amd_comgr_disassembly_info_s`

    amd_comgr_symbolizer_info_t:
        alias of `~.amd_comgr_symbolizer_info_s`

    amd_comgr_action_kind_t:
        alias of `~.amd_comgr_action_kind_s`

    amd_comgr_metadata_kind_t:
        alias of `~.amd_comgr_metadata_kind_s`

    amd_comgr_symbol_type_t:
        alias of `~.amd_comgr_symbol_type_s`

    amd_comgr_symbol_info_t:
        alias of `~.amd_comgr_symbol_info_s`

    amd_comgr_code_object_info_t:
        alias of `~.code_object_info_s`

"""

import cython
import ctypes
import enum
AMD_COMGR_INTERFACE_VERSION_MAJOR = camd_comgr.AMD_COMGR_INTERFACE_VERSION_MAJOR

AMD_COMGR_INTERFACE_VERSION_MINOR = camd_comgr.AMD_COMGR_INTERFACE_VERSION_MINOR

class _amd_comgr_status_s__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class amd_comgr_status_s(_amd_comgr_status_s__Base):
    """Status codes.

    Attributes:
        AMD_COMGR_STATUS_SUCCESS:
            The function has been executed successfully.
        AMD_COMGR_STATUS_ERROR:
            A generic error has occurred.
        AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT:
            One of the actual arguments does not meet a precondition stated in the documentation of the corresponding formal argument. This includes both invalid Action types, and invalid arguments to valid Action types.
        AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES:
            Failed to allocate the necessary resources.
    """
    AMD_COMGR_STATUS_SUCCESS = camd_comgr.AMD_COMGR_STATUS_SUCCESS
    AMD_COMGR_STATUS_ERROR = camd_comgr.AMD_COMGR_STATUS_ERROR
    AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT = camd_comgr.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT
    AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES = camd_comgr.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


amd_comgr_status_t = amd_comgr_status_s

class _amd_comgr_language_s__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class amd_comgr_language_s(_amd_comgr_language_s__Base):
    """The source languages supported by the compiler.

    Attributes:
        AMD_COMGR_LANGUAGE_NONE:
            No high level language.
        AMD_COMGR_LANGUAGE_OPENCL_1_2:
            OpenCL 1.2.
        AMD_COMGR_LANGUAGE_OPENCL_2_0:
            OpenCL 2.0.
        AMD_COMGR_LANGUAGE_HC:
            AMD Hetrogeneous C++ (HC).
        AMD_COMGR_LANGUAGE_HIP:
            HIP.
        AMD_COMGR_LANGUAGE_LLVM_IR:
            LLVM IR, either textual (.ll) or bitcode (.bc) format.
        AMD_COMGR_LANGUAGE_LAST:
            Marker for last valid language.
    """
    AMD_COMGR_LANGUAGE_NONE = camd_comgr.AMD_COMGR_LANGUAGE_NONE
    AMD_COMGR_LANGUAGE_OPENCL_1_2 = camd_comgr.AMD_COMGR_LANGUAGE_OPENCL_1_2
    AMD_COMGR_LANGUAGE_OPENCL_2_0 = camd_comgr.AMD_COMGR_LANGUAGE_OPENCL_2_0
    AMD_COMGR_LANGUAGE_HC = camd_comgr.AMD_COMGR_LANGUAGE_HC
    AMD_COMGR_LANGUAGE_HIP = camd_comgr.AMD_COMGR_LANGUAGE_HIP
    AMD_COMGR_LANGUAGE_LLVM_IR = camd_comgr.AMD_COMGR_LANGUAGE_LLVM_IR
    AMD_COMGR_LANGUAGE_LAST = camd_comgr.AMD_COMGR_LANGUAGE_LAST
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


amd_comgr_language_t = amd_comgr_language_s

@cython.embedsignature(True)
def amd_comgr_status_string(object status):
    r"""Query additional information about a status code.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    status is an invalid status code, or ``status_string`` is NULL.

    Args:
        status (`~.amd_comgr_status_s`) -- *IN*:
            Status code.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.rocm.llvm._util.types.CStr`/`~.object`:
                A NUL-terminated string that describes
                the error status.
    """
    if not isinstance(status,_amd_comgr_status_s__Base):
        raise TypeError("argument 'status' must be of type '_amd_comgr_status_s__Base'")                    
    status_string = rocm.llvm._util.types.CStr.fromPtr(NULL)
    _amd_comgr_status_string__retval = amd_comgr_status_s(camd_comgr.amd_comgr_status_string(status.value,
        <const char **>&status_string._ptr))
    return (_amd_comgr_status_string__retval,None if status_string._ptr == NULL else status_string)


@cython.embedsignature(True)
def amd_comgr_get_version():
    r"""Get the version of the code object manager interface
    supported.

    An interface is backwards compatible with an implementation with an
    equal major version, and a greater than or equal minor version.

    Returns:
        A `~.tuple` of size 3 that contains (in that order):

        * `~.amd_comgr_status_s`:
                Always returns `~.amd_comgr_status_s.AMD_COMGR_STATUS_SUCCESS`.
        * `~.int`:
                Major version number.
        * `~.int`:
                Minor version number.
    """
    cdef unsigned long major
    cdef unsigned long minor
    camd_comgr.amd_comgr_get_version(&major,&minor)
    return (amd_comgr_status_s.AMD_COMGR_STATUS_SUCCESS,major,minor)


class _amd_comgr_data_kind_s__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class amd_comgr_data_kind_s(_amd_comgr_data_kind_s__Base):
    """The kinds of data supported.

    Attributes:
        AMD_COMGR_DATA_KIND_UNDEF:
            No data is available.
        AMD_COMGR_DATA_KIND_SOURCE:
            The data is a textual main source.
        AMD_COMGR_DATA_KIND_INCLUDE:
            The data is a textual source that is included in the main source or other include source.
        AMD_COMGR_DATA_KIND_PRECOMPILED_HEADER:
            The data is a precompiled-header source that is included in the main source or other include source.
        AMD_COMGR_DATA_KIND_DIAGNOSTIC:
            The data is a diagnostic output.
        AMD_COMGR_DATA_KIND_LOG:
            The data is a textual log output.
        AMD_COMGR_DATA_KIND_BC:
            The data is compiler LLVM IR bit code for a specific isa.
        AMD_COMGR_DATA_KIND_RELOCATABLE:
            The data is a relocatable machine code object for a specific isa.
        AMD_COMGR_DATA_KIND_EXECUTABLE:
            The data is an executable machine code object for a specific isa. An executable is the kind of code object that can be loaded and executed.
        AMD_COMGR_DATA_KIND_BYTES:
            The data is a block of bytes.
        AMD_COMGR_DATA_KIND_FATBIN:
            The data is a fat binary (clang-offload-bundler output).
        AMD_COMGR_DATA_KIND_AR:
            The data is an archive.
        AMD_COMGR_DATA_KIND_BC_BUNDLE:
            The data is a bitcode bundle.
        AMD_COMGR_DATA_KIND_AR_BUNDLE:
            The data is an archive bundle.
        AMD_COMGR_DATA_KIND_OBJ_BUNDLE:
            The data is an object file bundle.
        AMD_COMGR_DATA_KIND_LAST:
            Marker for last valid data kind.
    """
    AMD_COMGR_DATA_KIND_UNDEF = camd_comgr.AMD_COMGR_DATA_KIND_UNDEF
    AMD_COMGR_DATA_KIND_SOURCE = camd_comgr.AMD_COMGR_DATA_KIND_SOURCE
    AMD_COMGR_DATA_KIND_INCLUDE = camd_comgr.AMD_COMGR_DATA_KIND_INCLUDE
    AMD_COMGR_DATA_KIND_PRECOMPILED_HEADER = camd_comgr.AMD_COMGR_DATA_KIND_PRECOMPILED_HEADER
    AMD_COMGR_DATA_KIND_DIAGNOSTIC = camd_comgr.AMD_COMGR_DATA_KIND_DIAGNOSTIC
    AMD_COMGR_DATA_KIND_LOG = camd_comgr.AMD_COMGR_DATA_KIND_LOG
    AMD_COMGR_DATA_KIND_BC = camd_comgr.AMD_COMGR_DATA_KIND_BC
    AMD_COMGR_DATA_KIND_RELOCATABLE = camd_comgr.AMD_COMGR_DATA_KIND_RELOCATABLE
    AMD_COMGR_DATA_KIND_EXECUTABLE = camd_comgr.AMD_COMGR_DATA_KIND_EXECUTABLE
    AMD_COMGR_DATA_KIND_BYTES = camd_comgr.AMD_COMGR_DATA_KIND_BYTES
    AMD_COMGR_DATA_KIND_FATBIN = camd_comgr.AMD_COMGR_DATA_KIND_FATBIN
    AMD_COMGR_DATA_KIND_AR = camd_comgr.AMD_COMGR_DATA_KIND_AR
    AMD_COMGR_DATA_KIND_BC_BUNDLE = camd_comgr.AMD_COMGR_DATA_KIND_BC_BUNDLE
    AMD_COMGR_DATA_KIND_AR_BUNDLE = camd_comgr.AMD_COMGR_DATA_KIND_AR_BUNDLE
    AMD_COMGR_DATA_KIND_OBJ_BUNDLE = camd_comgr.AMD_COMGR_DATA_KIND_OBJ_BUNDLE
    AMD_COMGR_DATA_KIND_LAST = camd_comgr.AMD_COMGR_DATA_KIND_LAST
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


amd_comgr_data_kind_t = amd_comgr_data_kind_s

cdef class amd_comgr_data_s(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_data_s.

    Python wrapper for cdef class camd_comgr.amd_comgr_data_s.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_data_s* getElementPtr(self):
        return <camd_comgr.amd_comgr_data_s*>self._ptr

    @staticmethod
    cdef amd_comgr_data_s fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_data_s`` objects from
        given ``camd_comgr.amd_comgr_data_s`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_data_s wrapper = amd_comgr_data_s.__new__(amd_comgr_data_s)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_data_s from a Python object.

        Derives a amd_comgr_data_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_data_s`` reference, this method
        returns it directly. No new ``amd_comgr_data_s`` is created in this case.
        """
        return amd_comgr_data_s.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_data_s fromPyobj(object pyobj):
        """Creates a amd_comgr_data_s from a Python object.

        Derives a amd_comgr_data_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_data_s`` reference, this method
        returns it directly. No new ``amd_comgr_data_s`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_data_s`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_data_s!
        """
        cdef amd_comgr_data_s wrapper

        if isinstance(pyobj,amd_comgr_data_s):
            return pyobj
        else:
            wrapper = amd_comgr_data_s.__new__(amd_comgr_data_s)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(camd_comgr.amd_comgr_data_s))
        string.memset(<void*>ptr[0], 0, sizeof(camd_comgr.amd_comgr_data_s))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef amd_comgr_data_s new():
        """Factory function to create amd_comgr_data_s objects with
        newly allocated camd_comgr.amd_comgr_data_s"""
        cdef void* ptr
        amd_comgr_data_s.__allocate(&ptr)
        return amd_comgr_data_s.fromPtr(ptr, owner=True)

    @staticmethod
    cdef amd_comgr_data_s fromValue(camd_comgr.amd_comgr_data_s other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = amd_comgr_data_s.new()
        string.memcpy(wrapper._ptr, &other, sizeof(camd_comgr.amd_comgr_data_s))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(camd_comgr.amd_comgr_data_s)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_data_s object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type amd_comgr_data_s.

        Constructor for type amd_comgr_data_s.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        amd_comgr_data_s.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_handle(self, i):
        """Get value ``handle`` of ``(<camd_comgr.amd_comgr_data_s*>self._ptr)[i]``.
        """
        return (<camd_comgr.amd_comgr_data_s*>self._ptr)[i].handle
    def set_handle(self, i, unsigned long value):
        """Set value ``handle`` of ``(<camd_comgr.amd_comgr_data_s*>self._ptr)[i]``.
        """
        (<camd_comgr.amd_comgr_data_s*>self._ptr)[i].handle = value
    @property
    def handle(self):
        """(undocumented)"""
        return self.get_handle(0)
    @handle.setter
    def handle(self, unsigned long value):
        self.set_handle(0,value)

    @staticmethod
    def PROPERTIES():
        return ["handle"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


amd_comgr_data_t = amd_comgr_data_s

cdef class amd_comgr_data_set_s(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_data_set_s.

    Python wrapper for cdef class camd_comgr.amd_comgr_data_set_s.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_data_set_s* getElementPtr(self):
        return <camd_comgr.amd_comgr_data_set_s*>self._ptr

    @staticmethod
    cdef amd_comgr_data_set_s fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_data_set_s`` objects from
        given ``camd_comgr.amd_comgr_data_set_s`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_data_set_s wrapper = amd_comgr_data_set_s.__new__(amd_comgr_data_set_s)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_data_set_s from a Python object.

        Derives a amd_comgr_data_set_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_data_set_s`` reference, this method
        returns it directly. No new ``amd_comgr_data_set_s`` is created in this case.
        """
        return amd_comgr_data_set_s.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_data_set_s fromPyobj(object pyobj):
        """Creates a amd_comgr_data_set_s from a Python object.

        Derives a amd_comgr_data_set_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_data_set_s`` reference, this method
        returns it directly. No new ``amd_comgr_data_set_s`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_data_set_s`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_data_set_s!
        """
        cdef amd_comgr_data_set_s wrapper

        if isinstance(pyobj,amd_comgr_data_set_s):
            return pyobj
        else:
            wrapper = amd_comgr_data_set_s.__new__(amd_comgr_data_set_s)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(camd_comgr.amd_comgr_data_set_s))
        string.memset(<void*>ptr[0], 0, sizeof(camd_comgr.amd_comgr_data_set_s))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef amd_comgr_data_set_s new():
        """Factory function to create amd_comgr_data_set_s objects with
        newly allocated camd_comgr.amd_comgr_data_set_s"""
        cdef void* ptr
        amd_comgr_data_set_s.__allocate(&ptr)
        return amd_comgr_data_set_s.fromPtr(ptr, owner=True)

    @staticmethod
    cdef amd_comgr_data_set_s fromValue(camd_comgr.amd_comgr_data_set_s other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = amd_comgr_data_set_s.new()
        string.memcpy(wrapper._ptr, &other, sizeof(camd_comgr.amd_comgr_data_set_s))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(camd_comgr.amd_comgr_data_set_s)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_data_set_s object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type amd_comgr_data_set_s.

        Constructor for type amd_comgr_data_set_s.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        amd_comgr_data_set_s.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_handle(self, i):
        """Get value ``handle`` of ``(<camd_comgr.amd_comgr_data_set_s*>self._ptr)[i]``.
        """
        return (<camd_comgr.amd_comgr_data_set_s*>self._ptr)[i].handle
    def set_handle(self, i, unsigned long value):
        """Set value ``handle`` of ``(<camd_comgr.amd_comgr_data_set_s*>self._ptr)[i]``.
        """
        (<camd_comgr.amd_comgr_data_set_s*>self._ptr)[i].handle = value
    @property
    def handle(self):
        """(undocumented)"""
        return self.get_handle(0)
    @handle.setter
    def handle(self, unsigned long value):
        self.set_handle(0,value)

    @staticmethod
    def PROPERTIES():
        return ["handle"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


amd_comgr_data_set_t = amd_comgr_data_set_s

cdef class amd_comgr_action_info_s(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_action_info_s.

    Python wrapper for cdef class camd_comgr.amd_comgr_action_info_s.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_action_info_s* getElementPtr(self):
        return <camd_comgr.amd_comgr_action_info_s*>self._ptr

    @staticmethod
    cdef amd_comgr_action_info_s fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_action_info_s`` objects from
        given ``camd_comgr.amd_comgr_action_info_s`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_action_info_s wrapper = amd_comgr_action_info_s.__new__(amd_comgr_action_info_s)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_action_info_s from a Python object.

        Derives a amd_comgr_action_info_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_action_info_s`` reference, this method
        returns it directly. No new ``amd_comgr_action_info_s`` is created in this case.
        """
        return amd_comgr_action_info_s.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_action_info_s fromPyobj(object pyobj):
        """Creates a amd_comgr_action_info_s from a Python object.

        Derives a amd_comgr_action_info_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_action_info_s`` reference, this method
        returns it directly. No new ``amd_comgr_action_info_s`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_action_info_s`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_action_info_s!
        """
        cdef amd_comgr_action_info_s wrapper

        if isinstance(pyobj,amd_comgr_action_info_s):
            return pyobj
        else:
            wrapper = amd_comgr_action_info_s.__new__(amd_comgr_action_info_s)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(camd_comgr.amd_comgr_action_info_s))
        string.memset(<void*>ptr[0], 0, sizeof(camd_comgr.amd_comgr_action_info_s))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef amd_comgr_action_info_s new():
        """Factory function to create amd_comgr_action_info_s objects with
        newly allocated camd_comgr.amd_comgr_action_info_s"""
        cdef void* ptr
        amd_comgr_action_info_s.__allocate(&ptr)
        return amd_comgr_action_info_s.fromPtr(ptr, owner=True)

    @staticmethod
    cdef amd_comgr_action_info_s fromValue(camd_comgr.amd_comgr_action_info_s other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = amd_comgr_action_info_s.new()
        string.memcpy(wrapper._ptr, &other, sizeof(camd_comgr.amd_comgr_action_info_s))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(camd_comgr.amd_comgr_action_info_s)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_action_info_s object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type amd_comgr_action_info_s.

        Constructor for type amd_comgr_action_info_s.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        amd_comgr_action_info_s.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_handle(self, i):
        """Get value ``handle`` of ``(<camd_comgr.amd_comgr_action_info_s*>self._ptr)[i]``.
        """
        return (<camd_comgr.amd_comgr_action_info_s*>self._ptr)[i].handle
    def set_handle(self, i, unsigned long value):
        """Set value ``handle`` of ``(<camd_comgr.amd_comgr_action_info_s*>self._ptr)[i]``.
        """
        (<camd_comgr.amd_comgr_action_info_s*>self._ptr)[i].handle = value
    @property
    def handle(self):
        """(undocumented)"""
        return self.get_handle(0)
    @handle.setter
    def handle(self, unsigned long value):
        self.set_handle(0,value)

    @staticmethod
    def PROPERTIES():
        return ["handle"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


amd_comgr_action_info_t = amd_comgr_action_info_s

cdef class amd_comgr_metadata_node_s(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_metadata_node_s.

    Python wrapper for cdef class camd_comgr.amd_comgr_metadata_node_s.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_metadata_node_s* getElementPtr(self):
        return <camd_comgr.amd_comgr_metadata_node_s*>self._ptr

    @staticmethod
    cdef amd_comgr_metadata_node_s fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_metadata_node_s`` objects from
        given ``camd_comgr.amd_comgr_metadata_node_s`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_metadata_node_s wrapper = amd_comgr_metadata_node_s.__new__(amd_comgr_metadata_node_s)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_metadata_node_s from a Python object.

        Derives a amd_comgr_metadata_node_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_metadata_node_s`` reference, this method
        returns it directly. No new ``amd_comgr_metadata_node_s`` is created in this case.
        """
        return amd_comgr_metadata_node_s.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_metadata_node_s fromPyobj(object pyobj):
        """Creates a amd_comgr_metadata_node_s from a Python object.

        Derives a amd_comgr_metadata_node_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_metadata_node_s`` reference, this method
        returns it directly. No new ``amd_comgr_metadata_node_s`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_metadata_node_s`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_metadata_node_s!
        """
        cdef amd_comgr_metadata_node_s wrapper

        if isinstance(pyobj,amd_comgr_metadata_node_s):
            return pyobj
        else:
            wrapper = amd_comgr_metadata_node_s.__new__(amd_comgr_metadata_node_s)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(camd_comgr.amd_comgr_metadata_node_s))
        string.memset(<void*>ptr[0], 0, sizeof(camd_comgr.amd_comgr_metadata_node_s))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef amd_comgr_metadata_node_s new():
        """Factory function to create amd_comgr_metadata_node_s objects with
        newly allocated camd_comgr.amd_comgr_metadata_node_s"""
        cdef void* ptr
        amd_comgr_metadata_node_s.__allocate(&ptr)
        return amd_comgr_metadata_node_s.fromPtr(ptr, owner=True)

    @staticmethod
    cdef amd_comgr_metadata_node_s fromValue(camd_comgr.amd_comgr_metadata_node_s other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = amd_comgr_metadata_node_s.new()
        string.memcpy(wrapper._ptr, &other, sizeof(camd_comgr.amd_comgr_metadata_node_s))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(camd_comgr.amd_comgr_metadata_node_s)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_metadata_node_s object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type amd_comgr_metadata_node_s.

        Constructor for type amd_comgr_metadata_node_s.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        amd_comgr_metadata_node_s.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_handle(self, i):
        """Get value ``handle`` of ``(<camd_comgr.amd_comgr_metadata_node_s*>self._ptr)[i]``.
        """
        return (<camd_comgr.amd_comgr_metadata_node_s*>self._ptr)[i].handle
    def set_handle(self, i, unsigned long value):
        """Set value ``handle`` of ``(<camd_comgr.amd_comgr_metadata_node_s*>self._ptr)[i]``.
        """
        (<camd_comgr.amd_comgr_metadata_node_s*>self._ptr)[i].handle = value
    @property
    def handle(self):
        """(undocumented)"""
        return self.get_handle(0)
    @handle.setter
    def handle(self, unsigned long value):
        self.set_handle(0,value)

    @staticmethod
    def PROPERTIES():
        return ["handle"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


amd_comgr_metadata_node_t = amd_comgr_metadata_node_s

cdef class amd_comgr_symbol_s(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_symbol_s.

    Python wrapper for cdef class camd_comgr.amd_comgr_symbol_s.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_symbol_s* getElementPtr(self):
        return <camd_comgr.amd_comgr_symbol_s*>self._ptr

    @staticmethod
    cdef amd_comgr_symbol_s fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_symbol_s`` objects from
        given ``camd_comgr.amd_comgr_symbol_s`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_symbol_s wrapper = amd_comgr_symbol_s.__new__(amd_comgr_symbol_s)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_symbol_s from a Python object.

        Derives a amd_comgr_symbol_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_symbol_s`` reference, this method
        returns it directly. No new ``amd_comgr_symbol_s`` is created in this case.
        """
        return amd_comgr_symbol_s.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_symbol_s fromPyobj(object pyobj):
        """Creates a amd_comgr_symbol_s from a Python object.

        Derives a amd_comgr_symbol_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_symbol_s`` reference, this method
        returns it directly. No new ``amd_comgr_symbol_s`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_symbol_s`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_symbol_s!
        """
        cdef amd_comgr_symbol_s wrapper

        if isinstance(pyobj,amd_comgr_symbol_s):
            return pyobj
        else:
            wrapper = amd_comgr_symbol_s.__new__(amd_comgr_symbol_s)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(camd_comgr.amd_comgr_symbol_s))
        string.memset(<void*>ptr[0], 0, sizeof(camd_comgr.amd_comgr_symbol_s))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef amd_comgr_symbol_s new():
        """Factory function to create amd_comgr_symbol_s objects with
        newly allocated camd_comgr.amd_comgr_symbol_s"""
        cdef void* ptr
        amd_comgr_symbol_s.__allocate(&ptr)
        return amd_comgr_symbol_s.fromPtr(ptr, owner=True)

    @staticmethod
    cdef amd_comgr_symbol_s fromValue(camd_comgr.amd_comgr_symbol_s other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = amd_comgr_symbol_s.new()
        string.memcpy(wrapper._ptr, &other, sizeof(camd_comgr.amd_comgr_symbol_s))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(camd_comgr.amd_comgr_symbol_s)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_symbol_s object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type amd_comgr_symbol_s.

        Constructor for type amd_comgr_symbol_s.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        amd_comgr_symbol_s.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_handle(self, i):
        """Get value ``handle`` of ``(<camd_comgr.amd_comgr_symbol_s*>self._ptr)[i]``.
        """
        return (<camd_comgr.amd_comgr_symbol_s*>self._ptr)[i].handle
    def set_handle(self, i, unsigned long value):
        """Set value ``handle`` of ``(<camd_comgr.amd_comgr_symbol_s*>self._ptr)[i]``.
        """
        (<camd_comgr.amd_comgr_symbol_s*>self._ptr)[i].handle = value
    @property
    def handle(self):
        """(undocumented)"""
        return self.get_handle(0)
    @handle.setter
    def handle(self, unsigned long value):
        self.set_handle(0,value)

    @staticmethod
    def PROPERTIES():
        return ["handle"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


amd_comgr_symbol_t = amd_comgr_symbol_s

cdef class amd_comgr_disassembly_info_s(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_disassembly_info_s.

    Python wrapper for cdef class camd_comgr.amd_comgr_disassembly_info_s.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_disassembly_info_s* getElementPtr(self):
        return <camd_comgr.amd_comgr_disassembly_info_s*>self._ptr

    @staticmethod
    cdef amd_comgr_disassembly_info_s fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_disassembly_info_s`` objects from
        given ``camd_comgr.amd_comgr_disassembly_info_s`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_disassembly_info_s wrapper = amd_comgr_disassembly_info_s.__new__(amd_comgr_disassembly_info_s)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_disassembly_info_s from a Python object.

        Derives a amd_comgr_disassembly_info_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_disassembly_info_s`` reference, this method
        returns it directly. No new ``amd_comgr_disassembly_info_s`` is created in this case.
        """
        return amd_comgr_disassembly_info_s.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_disassembly_info_s fromPyobj(object pyobj):
        """Creates a amd_comgr_disassembly_info_s from a Python object.

        Derives a amd_comgr_disassembly_info_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_disassembly_info_s`` reference, this method
        returns it directly. No new ``amd_comgr_disassembly_info_s`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_disassembly_info_s`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_disassembly_info_s!
        """
        cdef amd_comgr_disassembly_info_s wrapper

        if isinstance(pyobj,amd_comgr_disassembly_info_s):
            return pyobj
        else:
            wrapper = amd_comgr_disassembly_info_s.__new__(amd_comgr_disassembly_info_s)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(camd_comgr.amd_comgr_disassembly_info_s))
        string.memset(<void*>ptr[0], 0, sizeof(camd_comgr.amd_comgr_disassembly_info_s))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef amd_comgr_disassembly_info_s new():
        """Factory function to create amd_comgr_disassembly_info_s objects with
        newly allocated camd_comgr.amd_comgr_disassembly_info_s"""
        cdef void* ptr
        amd_comgr_disassembly_info_s.__allocate(&ptr)
        return amd_comgr_disassembly_info_s.fromPtr(ptr, owner=True)

    @staticmethod
    cdef amd_comgr_disassembly_info_s fromValue(camd_comgr.amd_comgr_disassembly_info_s other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = amd_comgr_disassembly_info_s.new()
        string.memcpy(wrapper._ptr, &other, sizeof(camd_comgr.amd_comgr_disassembly_info_s))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(camd_comgr.amd_comgr_disassembly_info_s)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_disassembly_info_s object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type amd_comgr_disassembly_info_s.

        Constructor for type amd_comgr_disassembly_info_s.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        amd_comgr_disassembly_info_s.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_handle(self, i):
        """Get value ``handle`` of ``(<camd_comgr.amd_comgr_disassembly_info_s*>self._ptr)[i]``.
        """
        return (<camd_comgr.amd_comgr_disassembly_info_s*>self._ptr)[i].handle
    def set_handle(self, i, unsigned long value):
        """Set value ``handle`` of ``(<camd_comgr.amd_comgr_disassembly_info_s*>self._ptr)[i]``.
        """
        (<camd_comgr.amd_comgr_disassembly_info_s*>self._ptr)[i].handle = value
    @property
    def handle(self):
        """(undocumented)"""
        return self.get_handle(0)
    @handle.setter
    def handle(self, unsigned long value):
        self.set_handle(0,value)

    @staticmethod
    def PROPERTIES():
        return ["handle"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


amd_comgr_disassembly_info_t = amd_comgr_disassembly_info_s

cdef class amd_comgr_symbolizer_info_s(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_symbolizer_info_s.

    Python wrapper for cdef class camd_comgr.amd_comgr_symbolizer_info_s.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_symbolizer_info_s* getElementPtr(self):
        return <camd_comgr.amd_comgr_symbolizer_info_s*>self._ptr

    @staticmethod
    cdef amd_comgr_symbolizer_info_s fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_symbolizer_info_s`` objects from
        given ``camd_comgr.amd_comgr_symbolizer_info_s`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_symbolizer_info_s wrapper = amd_comgr_symbolizer_info_s.__new__(amd_comgr_symbolizer_info_s)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_symbolizer_info_s from a Python object.

        Derives a amd_comgr_symbolizer_info_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_symbolizer_info_s`` reference, this method
        returns it directly. No new ``amd_comgr_symbolizer_info_s`` is created in this case.
        """
        return amd_comgr_symbolizer_info_s.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_symbolizer_info_s fromPyobj(object pyobj):
        """Creates a amd_comgr_symbolizer_info_s from a Python object.

        Derives a amd_comgr_symbolizer_info_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_symbolizer_info_s`` reference, this method
        returns it directly. No new ``amd_comgr_symbolizer_info_s`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_symbolizer_info_s`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_symbolizer_info_s!
        """
        cdef amd_comgr_symbolizer_info_s wrapper

        if isinstance(pyobj,amd_comgr_symbolizer_info_s):
            return pyobj
        else:
            wrapper = amd_comgr_symbolizer_info_s.__new__(amd_comgr_symbolizer_info_s)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(camd_comgr.amd_comgr_symbolizer_info_s))
        string.memset(<void*>ptr[0], 0, sizeof(camd_comgr.amd_comgr_symbolizer_info_s))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef amd_comgr_symbolizer_info_s new():
        """Factory function to create amd_comgr_symbolizer_info_s objects with
        newly allocated camd_comgr.amd_comgr_symbolizer_info_s"""
        cdef void* ptr
        amd_comgr_symbolizer_info_s.__allocate(&ptr)
        return amd_comgr_symbolizer_info_s.fromPtr(ptr, owner=True)

    @staticmethod
    cdef amd_comgr_symbolizer_info_s fromValue(camd_comgr.amd_comgr_symbolizer_info_s other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = amd_comgr_symbolizer_info_s.new()
        string.memcpy(wrapper._ptr, &other, sizeof(camd_comgr.amd_comgr_symbolizer_info_s))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(camd_comgr.amd_comgr_symbolizer_info_s)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_symbolizer_info_s object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type amd_comgr_symbolizer_info_s.

        Constructor for type amd_comgr_symbolizer_info_s.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        amd_comgr_symbolizer_info_s.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_handle(self, i):
        """Get value ``handle`` of ``(<camd_comgr.amd_comgr_symbolizer_info_s*>self._ptr)[i]``.
        """
        return (<camd_comgr.amd_comgr_symbolizer_info_s*>self._ptr)[i].handle
    def set_handle(self, i, unsigned long value):
        """Set value ``handle`` of ``(<camd_comgr.amd_comgr_symbolizer_info_s*>self._ptr)[i]``.
        """
        (<camd_comgr.amd_comgr_symbolizer_info_s*>self._ptr)[i].handle = value
    @property
    def handle(self):
        """(undocumented)"""
        return self.get_handle(0)
    @handle.setter
    def handle(self, unsigned long value):
        self.set_handle(0,value)

    @staticmethod
    def PROPERTIES():
        return ["handle"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


amd_comgr_symbolizer_info_t = amd_comgr_symbolizer_info_s

@cython.embedsignature(True)
def amd_comgr_get_isa_count():
    r"""Return the number of isa names supported by this version of
    the code object manager library.

    The isa name specifies the instruction set architecture that should
    be used in the actions that involve machine code generation or
    inspection.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    count is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update action info object as out of resources.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`:
                The number of isa names supported.
    """
    cdef unsigned long count
    _amd_comgr_get_isa_count__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_isa_count(&count))
    return (_amd_comgr_get_isa_count__retval,count)


@cython.embedsignature(True)
def amd_comgr_get_isa_name(unsigned long index):
    r"""Return the Nth isa name supported by this version of the
    code object manager library.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    index is greater than the number of isa name supported by this
    version of the code object manager library. ``isa_name`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update action info object as out of resources.

    Args:
        index (`~.int`) -- *IN*:
            The index of the isa name to be returned. The
            first isa name is index 0.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.rocm.llvm._util.types.CStr`/`~.object`:
                A null terminated string that is the isa name
                being requested.
    """
    isa_name = rocm.llvm._util.types.CStr.fromPtr(NULL)
    _amd_comgr_get_isa_name__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_isa_name(index,
        <const char **>&isa_name._ptr))
    return (_amd_comgr_get_isa_name__retval,None if isa_name._ptr == NULL else isa_name)


@cython.embedsignature(True)
def amd_comgr_get_isa_metadata(object isa_name):
    r"""Get a handle to the metadata of an isa name.

    The structure of the returned metadata is isa name specific and versioned
    with details specified in
    https://llvm.org/docs/AMDGPUUsage.html`~.code`-object-metadata.
    It can include information about the
    limits for resources such as registers and memory addressing.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    name is NULL or is not an isa name supported by this version of the
    code object manager library. ``metadata`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        isa_name (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *IN*:
            The isa name to query.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.amd_comgr_metadata_node_s`:
                A handle to the metadata of the isa name. If
                the isa name has no metadata then the returned handle has a kind of
                ``AMD_COMGR_METADATA_KIND_NULL.`` The handle must be destroyed
                using ``amd_comgr_destroy_metadata.``
    """
    metadata = amd_comgr_metadata_node_s.new()
    _amd_comgr_get_isa_metadata__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_isa_metadata(
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(isa_name)._ptr,<camd_comgr.amd_comgr_metadata_node_s*>metadata._ptr))
    return (_amd_comgr_get_isa_metadata__retval,metadata)


@cython.embedsignature(True)
def amd_comgr_create_data(object kind):
    r"""Create a data object that can hold data of a specified kind.

    Data objects are reference counted and are destroyed when the
    reference count reaches 0. When a data object is created its
    reference count is 1, it has 0 bytes of data, it has an empty name,
    and it has no metadata.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    kind is an invalid data kind, or @p
    AMD_COMGR_DATA_KIND_UNDEF. ``data`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to create the data object as out of resources.

    Args:
        kind (`~.amd_comgr_data_kind_s`) -- *IN*:
            The kind of data the object is intended to hold.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.amd_comgr_data_s`:
                A handle to the data object created. Its reference
                count is set to 1.
    """
    if not isinstance(kind,_amd_comgr_data_kind_s__Base):
        raise TypeError("argument 'kind' must be of type '_amd_comgr_data_kind_s__Base'")                    
    data = amd_comgr_data_s.new()
    _amd_comgr_create_data__retval = amd_comgr_status_s(camd_comgr.amd_comgr_create_data(kind.value,<camd_comgr.amd_comgr_data_s*>data._ptr))
    return (_amd_comgr_create_data__retval,data)


@cython.embedsignature(True)
def amd_comgr_release_data(object data):
    r"""Indicate that no longer using a data object handle.

    The reference count of the associated data object is
    decremented. If it reaches 0 it is destroyed.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    data is an invalid data object, or has kind @p
    AMD_COMGR_DATA_KIND_UNDEF.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            The data object to release.
    """
    _amd_comgr_release_data__retval = amd_comgr_status_s(camd_comgr.amd_comgr_release_data(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0]))
    return (_amd_comgr_release_data__retval,)


@cython.embedsignature(True)
def amd_comgr_get_data_kind(object data):
    r"""Get the kind of the data object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    data is an invalid data object. ``kind`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to create the data object as out of resources.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            The data object to query.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.amd_comgr_data_kind_s`:
                The kind of data the object.
    """
    cdef camd_comgr.amd_comgr_data_kind_s kind
    _amd_comgr_get_data_kind__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_data_kind(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],&kind))
    return (_amd_comgr_get_data_kind__retval,amd_comgr_data_kind_s(kind))


@cython.embedsignature(True)
def amd_comgr_set_data(object data, unsigned long size, object bytes):
    r"""Set the data content of a data object to the specified
    bytes.

    Any previous value of the data object is overwritten. Any metadata
    associated with the data object is also replaced which invalidates
    all metadata handles to the old metadata.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    data is an invalid data object, or has kind @p
    AMD_COMGR_DATA_KIND_UNDEF.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            The data object to update.

        size (`~.int`) -- *IN*:
            The number of bytes in the data specified by ``bytes.``

        bytes (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *IN*:
            The bytes to set the data object to. The bytes are
            copied into the data object and can be freed after the call.
    """
    _amd_comgr_set_data__retval = amd_comgr_status_s(camd_comgr.amd_comgr_set_data(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],size,
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(bytes)._ptr))
    return (_amd_comgr_set_data__retval,)


@cython.embedsignature(True)
def amd_comgr_set_data_from_file_slice(object data, int file_descriptor, unsigned long offset, unsigned long size):
    r"""For the given open posix file descriptor, map a slice of the
    file into the data object. The slice is specified by ``offset`` and ``size.``
    Internally this API calls amd_comgr_set_data and resets data object's
    current state.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The operation is successful.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data`` is an invalid or
    the map operation failed.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN,OUT*:
            The data object to update.

        file_descriptor (`~.int`) -- *IN*:
            The native file descriptor for an open file.
            The ``file_descriptor`` must not be passed into a system I/O function
            by any other thread while this function is executing.  The offset in
            the file descriptor may be updated based on the requested size and
            underlying platform. The ``file_descriptor`` may be closed immediately
            after this function returns.

        offset (`~.int`) -- *IN*:
            position relative to the start of the file
            specifying the beginning of the slice in ``file_descriptor.``

        size (`~.int`) -- *IN*:
            Size in bytes of the slice.
    """
    _amd_comgr_set_data_from_file_slice__retval = amd_comgr_status_s(camd_comgr.amd_comgr_set_data_from_file_slice(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],file_descriptor,offset,size))
    return (_amd_comgr_set_data_from_file_slice__retval,)


@cython.embedsignature(True)
def amd_comgr_set_data_name(object data, object name):
    r"""Set the name associated with a data object.

    When compiling, the full name of an include directive is used to
    reference the contents of the include data object with the same
    name. The name may also be used for other data objects in log and
    diagnostic output.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    data is an invalid data object, or has kind @p
    AMD_COMGR_DATA_KIND_UNDEF.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            The data object to update.

        name (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *IN*:
            A null terminated string that specifies the name to
            use for the data object. If NULL then the name is set to the empty
            string.
    """
    _amd_comgr_set_data_name__retval = amd_comgr_status_s(camd_comgr.amd_comgr_set_data_name(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(name)._ptr))
    return (_amd_comgr_set_data_name__retval,)


@cython.embedsignature(True)
def amd_comgr_get_data(object data, object size, object bytes):
    r"""Get the data contents, and/or the size of the data
    associated with a data object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    data is an invalid data object, or has kind @p
    AMD_COMGR_DATA_KIND_UNDEF. ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            The data object to query.

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            On entry, the size of ``bytes.`` On return, if ``bytes``
            is NULL, set to the size of the data object contents.

        bytes (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *OUT*:
            If not NULL, then the first ``size`` bytes of the
            data object contents is copied. If NULL, no data is copied, and
            only ``size`` is updated (useful in order to find the size of buffer
            required to copy the data).
    """
    _amd_comgr_get_data__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_data(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr,
        <char *>rocm.llvm._util.types.CStr.fromPyobj(bytes)._ptr))
    return (_amd_comgr_get_data__retval,)


@cython.embedsignature(True)
def amd_comgr_get_data_name(object data, object size, object name):
    r"""Get the data object name and/or name length.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    data is an invalid data object, or has kind @p
    AMD_COMGR_DATA_KIND_UNDEF. ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            The data object to query.

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            On entry, the size of ``name.`` On return, the size of
            the data object name including the terminating null character.

        name (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *OUT*:
            If not NULL, then the first ``size`` characters of the
            data object name are copied. If ``name`` is NULL, only ``size`` is updated
            (useful in order to find the size of buffer required to copy the name).
    """
    _amd_comgr_get_data_name__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_data_name(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr,
        <char *>rocm.llvm._util.types.CStr.fromPyobj(name)._ptr))
    return (_amd_comgr_get_data_name__retval,)


@cython.embedsignature(True)
def amd_comgr_get_data_isa_name(object data, object size, object isa_name):
    r"""Get the data object isa name and/or isa name length.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    data is an invalid data object, has kind @p
    AMD_COMGR_DATA_KIND_UNDEF, or is not an isa specific
    kind. ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            The data object to query.

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            On entry, the size of ``isa_name.`` On return, if @p
            isa_name is NULL, set to the size of the isa name including the terminating
            null character.

        isa_name (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *OUT*:
            If not NULL, then the first ``size`` characters
            of the isa name are copied. If NULL, no isa name is copied, and
            only ``size`` is updated (useful in order to find the size of buffer
            required to copy the isa name).
    """
    _amd_comgr_get_data_isa_name__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_data_isa_name(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr,
        <char *>rocm.llvm._util.types.CStr.fromPyobj(isa_name)._ptr))
    return (_amd_comgr_get_data_isa_name__retval,)


cdef class amd_comgr_create_symbolizer_info_anon_funptr_0(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_create_symbolizer_info_anon_funptr_0.

    Python wrapper for cdef class camd_comgr.amd_comgr_create_symbolizer_info_anon_funptr_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_create_symbolizer_info_anon_funptr_0 getElementPtr(self):
        return <camd_comgr.amd_comgr_create_symbolizer_info_anon_funptr_0>self._ptr

    @staticmethod
    cdef amd_comgr_create_symbolizer_info_anon_funptr_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_create_symbolizer_info_anon_funptr_0`` objects from
        given ``camd_comgr.amd_comgr_create_symbolizer_info_anon_funptr_0`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_create_symbolizer_info_anon_funptr_0 wrapper = amd_comgr_create_symbolizer_info_anon_funptr_0.__new__(amd_comgr_create_symbolizer_info_anon_funptr_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_create_symbolizer_info_anon_funptr_0 from a Python object.

        Derives a amd_comgr_create_symbolizer_info_anon_funptr_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_create_symbolizer_info_anon_funptr_0`` reference, this method
        returns it directly. No new ``amd_comgr_create_symbolizer_info_anon_funptr_0`` is created in this case.
        """
        return amd_comgr_create_symbolizer_info_anon_funptr_0.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_create_symbolizer_info_anon_funptr_0 fromPyobj(object pyobj):
        """Creates a amd_comgr_create_symbolizer_info_anon_funptr_0 from a Python object.

        Derives a amd_comgr_create_symbolizer_info_anon_funptr_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_create_symbolizer_info_anon_funptr_0`` reference, this method
        returns it directly. No new ``amd_comgr_create_symbolizer_info_anon_funptr_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_create_symbolizer_info_anon_funptr_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_create_symbolizer_info_anon_funptr_0!
        """
        cdef amd_comgr_create_symbolizer_info_anon_funptr_0 wrapper

        if isinstance(pyobj,amd_comgr_create_symbolizer_info_anon_funptr_0):
            return pyobj
        else:
            wrapper = amd_comgr_create_symbolizer_info_anon_funptr_0.__new__(amd_comgr_create_symbolizer_info_anon_funptr_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_create_symbolizer_info_anon_funptr_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def amd_comgr_create_symbolizer_info(object code_object, object print_symbol_callback):
    r"""Create a symbolizer info object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` if ``code_object`` is
    invalid or ``print_symbol_callback`` is null.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to create ``symbolizer_info`` as out of resources.

    Args:
        code_object (`~.amd_comgr_data_s`) -- *IN*:
            A data object denoting a code object for which
            symbolization should be performed. The kind of this object must be
            `~.AMD_COMGR_DATA_KIND_RELOCATABLE`, `~.AMD_COMGR_DATA_KIND_EXECUTABLE`,
            or `~.AMD_COMGR_DATA_KIND_BYTES`.

        print_symbol_callback (`~.amd_comgr_create_symbolizer_info_anon_funptr_0`/`~.object`) -- *IN*:
            Function called by a successfull
            symbolize query. ``symbol`` is a null-terminated string containing the
            symbolization of the address and ``user_data`` is an arbitary user data.
            The callback does not own ``symbol,`` and it cannot be referenced once
            the callback returns.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.amd_comgr_symbolizer_info_s`:
                A handle to the symbolizer info object created.
    """
    symbolizer_info = amd_comgr_symbolizer_info_s.new()
    _amd_comgr_create_symbolizer_info__retval = amd_comgr_status_s(camd_comgr.amd_comgr_create_symbolizer_info(
        amd_comgr_data_s.fromPyobj(code_object).getElementPtr()[0],
        amd_comgr_create_symbolizer_info_anon_funptr_0.fromPyobj(print_symbol_callback).getElementPtr(),<camd_comgr.amd_comgr_symbolizer_info_s*>symbolizer_info._ptr))
    return (_amd_comgr_create_symbolizer_info__retval,symbolizer_info)


@cython.embedsignature(True)
def amd_comgr_destroy_symbolizer_info(object symbolizer_info):
    r"""Destroy symbolizer info object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` on successful execution.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` if @p
    symbolizer_info is invalid.

    Args:
        symbolizer_info (`~.amd_comgr_symbolizer_info_s`) -- *IN*:
            A handle to symbolizer info object to destroy.
    """
    _amd_comgr_destroy_symbolizer_info__retval = amd_comgr_status_s(camd_comgr.amd_comgr_destroy_symbolizer_info(
        amd_comgr_symbolizer_info_s.fromPyobj(symbolizer_info).getElementPtr()[0]))
    return (_amd_comgr_destroy_symbolizer_info__retval,)


@cython.embedsignature(True)
def amd_comgr_symbolize(object symbolizer_info, unsigned long address, _Bool is_code, object user_data):
    r"""Symbolize an address.

    The ``address`` is symbolized using the symbol definitions of the
    ``code_object`` specified when the ``symbolizer_info`` was created.
    The ``print_symbol_callback`` callback function specified when the
    ``symbolizer_info`` was created is called passing the
    symbolization result as ``symbol`` and ``user_data`` value.

    If symbolization is not possible `~.AMD_COMGR_STATUS_SUCCESS` is returned and
    the string passed to the ``symbol`` argument of the ``print_symbol_callback``
    specified when the ``symbolizer_info`` was created contains the text
    "<invalid>" or "??". This is consistent with `llvm-symbolizer` utility.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    symbolizer_info is an invalid data object.

    Args:
        symbolizer_info (`~.amd_comgr_symbolizer_info_s`) -- *IN*:
            A handle to symbolizer info object which should be
            used to symbolize the ``address.``

        address (`~.int`) -- *IN*:
            An unrelocated ELF address to which symbolization
            query should be performed.

        is_code (`~.bint`) -- *IN*:
            if true, the symbolizer symbolize the address as code
            and the symbolization result contains filename, function name, line number
            and column number, else the symbolizer symbolize the address as data and
            the symbolizaion result contains symbol name, symbol's starting address
            and symbol size.

        user_data (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN*:
            Arbitrary user-data passed to ``print_symbol_callback``
            callback as described for ``symbolizer_info`` argument.
    """
    _amd_comgr_symbolize__retval = amd_comgr_status_s(camd_comgr.amd_comgr_symbolize(
        amd_comgr_symbolizer_info_s.fromPyobj(symbolizer_info).getElementPtr()[0],address,is_code,
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(user_data)._ptr))
    return (_amd_comgr_symbolize__retval,)


@cython.embedsignature(True)
def amd_comgr_get_data_metadata(object data):
    r"""Get a handle to the metadata of a data object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    data is an invalid data object, or has kind @p
    AMD_COMGR_DATA_KIND_UNDEF. ``metadata`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            The data object to query.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.amd_comgr_metadata_node_s`:
                A handle to the metadata of the data
                object. If the data object has no metadata then the returned handle
                has a kind of ``AMD_COMGR_METADATA_KIND_NULL.`` The
                handle must be destroyed using ``amd_comgr_destroy_metadata.``
    """
    metadata = amd_comgr_metadata_node_s.new()
    _amd_comgr_get_data_metadata__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_data_metadata(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],<camd_comgr.amd_comgr_metadata_node_s*>metadata._ptr))
    return (_amd_comgr_get_data_metadata__retval,metadata)


@cython.embedsignature(True)
def amd_comgr_destroy_metadata(object metadata):
    r"""Destroy a metadata handle.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``metadata`` is an invalid
    metadata handle.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to update metadata
    handle as out of resources.

    Args:
        metadata (`~.amd_comgr_metadata_node_s`) -- *IN*:
            A metadata handle to destroy.
    """
    _amd_comgr_destroy_metadata__retval = amd_comgr_status_s(camd_comgr.amd_comgr_destroy_metadata(
        amd_comgr_metadata_node_s.fromPyobj(metadata).getElementPtr()[0]))
    return (_amd_comgr_destroy_metadata__retval,)


@cython.embedsignature(True)
def amd_comgr_create_data_set():
    r"""Create a data set object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data_set`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to create the data
    set object as out of resources.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.amd_comgr_data_set_s`:
                A handle to the data set created. Initially it
                contains no data objects.
    """
    data_set = amd_comgr_data_set_s.new()
    _amd_comgr_create_data_set__retval = amd_comgr_status_s(camd_comgr.amd_comgr_create_data_set(<camd_comgr.amd_comgr_data_set_s*>data_set._ptr))
    return (_amd_comgr_create_data_set__retval,data_set)


@cython.embedsignature(True)
def amd_comgr_destroy_data_set(object data_set):
    r"""Destroy a data set object.

    The reference counts of any associated data objects are decremented. Any
    handles to the data set object become invalid.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data_set`` is an invalid
    data set object.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to update data set
    object as out of resources.

    Args:
        data_set (`~.amd_comgr_data_set_s`) -- *IN*:
            A handle to the data set object to destroy.
    """
    _amd_comgr_destroy_data_set__retval = amd_comgr_status_s(camd_comgr.amd_comgr_destroy_data_set(
        amd_comgr_data_set_s.fromPyobj(data_set).getElementPtr()[0]))
    return (_amd_comgr_destroy_data_set__retval,)


@cython.embedsignature(True)
def amd_comgr_data_set_add(object data_set, object data):
    r"""Add a data object to a data set object if it is not already added.

    The reference count of the data object is incremented.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data_set`` is an invalid
    data set object. ``data`` is an invalid data object; has undef kind; has
    include kind but does not have a name.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to update data set
    object as out of resources.

    Args:
        data_set (`~.amd_comgr_data_set_s`) -- *IN*:
            A handle to the data set object to be updated.

        data (`~.amd_comgr_data_s`) -- *IN*:
            A handle to the data object to be added. If ``data_set``
            already has the specified handle present, then it is not added. The order
            that data objects are added is preserved.
    """
    _amd_comgr_data_set_add__retval = amd_comgr_status_s(camd_comgr.amd_comgr_data_set_add(
        amd_comgr_data_set_s.fromPyobj(data_set).getElementPtr()[0],
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0]))
    return (_amd_comgr_data_set_add__retval,)


@cython.embedsignature(True)
def amd_comgr_data_set_remove(object data_set, object data_kind):
    r"""Remove all data objects of a specified kind from a data set object.

    The reference count of the removed data objects is decremented.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data_set`` is an invalid
    data set object. ``data_kind`` is an invalid data kind.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to update data set
    object as out of resources.

    Args:
        data_set (`~.amd_comgr_data_set_s`) -- *IN*:
            A handle to the data set object to be updated.

        data_kind (`~.amd_comgr_data_kind_s`) -- *IN*:
            The data kind of the data objects to be removed. If @p
            AMD_COMGR_DATA_KIND_UNDEF is specified then all data objects are removed.
    """
    if not isinstance(data_kind,_amd_comgr_data_kind_s__Base):
        raise TypeError("argument 'data_kind' must be of type '_amd_comgr_data_kind_s__Base'")
    _amd_comgr_data_set_remove__retval = amd_comgr_status_s(camd_comgr.amd_comgr_data_set_remove(
        amd_comgr_data_set_s.fromPyobj(data_set).getElementPtr()[0],data_kind.value))
    return (_amd_comgr_data_set_remove__retval,)


@cython.embedsignature(True)
def amd_comgr_action_data_count(object data_set, object data_kind):
    r"""Return the number of data objects of a specified data kind that are
    added to a data set object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data_set`` is an invalid
    data set object. ``data_kind`` is an invalid data kind or @p
    AMD_COMGR_DATA_KIND_UNDEF. ``count`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to query data set
    object as out of resources.

    Args:
        data_set (`~.amd_comgr_data_set_s`) -- *IN*:
            A handle to the data set object to be queried.

        data_kind (`~.amd_comgr_data_kind_s`) -- *IN*:
            The data kind of the data objects to be counted.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`:
                The number of data objects of data kind ``data_kind.``
    """
    if not isinstance(data_kind,_amd_comgr_data_kind_s__Base):
        raise TypeError("argument 'data_kind' must be of type '_amd_comgr_data_kind_s__Base'")                    
    cdef unsigned long count
    _amd_comgr_action_data_count__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_data_count(
        amd_comgr_data_set_s.fromPyobj(data_set).getElementPtr()[0],data_kind.value,&count))
    return (_amd_comgr_action_data_count__retval,count)


@cython.embedsignature(True)
def amd_comgr_action_data_get_data(object data_set, object data_kind, unsigned long index):
    r"""Return the Nth data object of a specified data kind that is added to a
    data set object.

    The reference count of the returned data object is incremented.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data_set`` is an invalid
    data set object. ``data_kind`` is an invalid data kind or @p
    AMD_COMGR_DATA_KIND_UNDEF. ``index`` is greater than the number of data
    objects of kind ``data_kind.`` ``data`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to query data set
    object as out of resources.

    Args:
        data_set (`~.amd_comgr_data_set_s`) -- *IN*:
            A handle to the data set object to be queried.

        data_kind (`~.amd_comgr_data_kind_s`) -- *IN*:
            The data kind of the data object to be returned.

        index (`~.int`) -- *IN*:
            The index of the data object of data kind @data_kind to be
            returned. The first data object is index 0. The order of data objects matches
            the order that they were added to the data set object.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.amd_comgr_data_s`:
                The data object being requested.
    """
    if not isinstance(data_kind,_amd_comgr_data_kind_s__Base):
        raise TypeError("argument 'data_kind' must be of type '_amd_comgr_data_kind_s__Base'")                    
    data = amd_comgr_data_s.new()
    _amd_comgr_action_data_get_data__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_data_get_data(
        amd_comgr_data_set_s.fromPyobj(data_set).getElementPtr()[0],data_kind.value,index,<camd_comgr.amd_comgr_data_s*>data._ptr))
    return (_amd_comgr_action_data_get_data__retval,data)


@cython.embedsignature(True)
def amd_comgr_create_action_info():
    r"""Create an action info object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to create the action info object as out of resources.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.amd_comgr_action_info_s`:
                A handle to the action info object created.
    """
    action_info = amd_comgr_action_info_s.new()
    _amd_comgr_create_action_info__retval = amd_comgr_status_s(camd_comgr.amd_comgr_create_action_info(<camd_comgr.amd_comgr_action_info_s*>action_info._ptr))
    return (_amd_comgr_create_action_info__retval,action_info)


@cython.embedsignature(True)
def amd_comgr_destroy_action_info(object action_info):
    r"""Destroy an action info object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update action info object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            A handle to the action info object to destroy.
    """
    _amd_comgr_destroy_action_info__retval = amd_comgr_status_s(camd_comgr.amd_comgr_destroy_action_info(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0]))
    return (_amd_comgr_destroy_action_info__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_set_isa_name(object action_info, object isa_name):
    r"""Set the isa name of an action info object.

    When an action info object is created it has no isa name. Some
    actions require that the action info object has an isa name
    defined.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object. ``isa_name`` is not an
    isa name supported by this version of the code object manager
    library.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update action info object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            A handle to the action info object to be
            updated.

        isa_name (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *IN*:
            A null terminated string that is the isa name. If NULL
            or the empty string then the isa name is cleared. The isa name is defined as
            the Code Object Target Identification string, described at
            https://llvm.org/docs/AMDGPUUsage.html`~.code`-object-target-identification
    """
    _amd_comgr_action_info_set_isa_name__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_set_isa_name(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(isa_name)._ptr))
    return (_amd_comgr_action_info_set_isa_name__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_get_isa_name(object action_info, object size, object isa_name):
    r"""Get the isa name and/or isa name length.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object. ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            The action info object to query.

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            On entry, the size of ``isa_name.`` On return, if @p
            isa_name is NULL, set to the size of the isa name including the terminating
            null character.

        isa_name (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *OUT*:
            If not NULL, then the first ``size`` characters of the
            isa name are copied into ``isa_name.`` If the isa name is not set then an
            empty string is copied into ``isa_name.`` If NULL, no name is copied, and
            only ``size`` is updated (useful in order to find the size of buffer required
            to copy the name).
    """
    _amd_comgr_action_info_get_isa_name__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_get_isa_name(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr,
        <char *>rocm.llvm._util.types.CStr.fromPyobj(isa_name)._ptr))
    return (_amd_comgr_action_info_get_isa_name__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_set_language(object action_info, object language):
    r"""Set the source language of an action info object.

    When an action info object is created it has no language defined
    which is represented by @p
    AMD_COMGR_LANGUAGE_NONE. Some actions require that
    the action info object has a source language defined.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object. ``language`` is an
    invalid language.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update action info object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            A handle to the action info object to be
            updated.

        language (`~.amd_comgr_language_s`) -- *IN*:
            The language to set. If @p
            AMD_COMGR_LANGUAGE_NONE then the language is cleared.
    """
    if not isinstance(language,_amd_comgr_language_s__Base):
        raise TypeError("argument 'language' must be of type '_amd_comgr_language_s__Base'")
    _amd_comgr_action_info_set_language__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_set_language(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],language.value))
    return (_amd_comgr_action_info_set_language__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_get_language(object action_info, object language):
    r"""Get the language for an action info object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object. ``language`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            The action info object to query.

        language (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *OUT*:
            The language of the action info opject. @p
            AMD_COMGR_LANGUAGE_NONE if not defined,
    """
    _amd_comgr_action_info_get_language__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_get_language(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],
        <camd_comgr.amd_comgr_language_s *>rocm.llvm._util.types.Pointer.fromPyobj(language)._ptr))
    return (_amd_comgr_action_info_get_language__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_set_options(object action_info, object options):
    r"""Set the options string of an action info object.

    When an action info object is created it has an empty options string.

    This overrides any option strings or arrays previously set by calls to this
    function or ``amd_comgr_action_info_set_option_list.``

    An ``action_info`` object which had its options set with this function can
    only have its option inspected with ``amd_comgr_action_info_get_options.``

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update action info object as out of resources.

    Deprecated:
        since 1.3

    See:
        `~.amd_comgr_action_info_set_option_list`

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            A handle to the action info object to be
            updated.

        options (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *IN*:
            A null terminated string that is the options. If
            NULL or the empty string then the options are cleared.
    """
    _amd_comgr_action_info_set_options__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_set_options(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(options)._ptr))
    return (_amd_comgr_action_info_set_options__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_get_options(object action_info, object size, object options):
    r"""Get the options string and/or options strings length of an action
    info object.

    The ``action_info`` object must have had its options set with @p
    amd_comgr_action_info_set_options.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` The options of ``action_info`` were not set
    with ``amd_comgr_action_info_set_options.``

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object. ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Deprecated:
        since 1.3

    See:
        `~.amd_comgr_action_info_get_option_list_count` `~.and`
        `~.amd_comgr_action_info_get_option_list_item`

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            The action info object to query.

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            On entry, the size of ``options.`` On return, if @p
            options is NULL, set to the size of the options including the terminating
            null character.

        options (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *OUT*:
            If not NULL, then the first ``size`` characters of
            the options are copied. If the options are not set then an empty
            string is copied. If NULL, options is not copied, and only ``size``
            is updated (useful inorder to find the size of buffer required to
            copy the options).
    """
    _amd_comgr_action_info_get_options__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_get_options(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr,
        <char *>rocm.llvm._util.types.CStr.fromPyobj(options)._ptr))
    return (_amd_comgr_action_info_get_options__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_set_option_list(object action_info, object options, unsigned long count):
    r"""Set the options array of an action info object.

    This overrides any option strings or arrays previously set by calls to this
    function or ``amd_comgr_action_info_set_options.``

    An ``action_info`` object which had its options set with this function can
    only have its option inspected with @p
    amd_comgr_action_info_get_option_list_count and @p
    amd_comgr_action_info_get_option_list_item.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``action_info`` is an
    invalid action info object, or ``options`` is NULL and ``count`` is non-zero.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to update action
    info object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            A handle to the action info object to be updated.

        options (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN*:
            An array of null terminated strings. May be NULL if @p
            count is zero, which will result in an empty options array.

        count (`~.int`) -- *IN*:
            The number of null terminated strings in ``options.``
    """
    _amd_comgr_action_info_set_option_list__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_set_option_list(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],
        <const char **>rocm.llvm._util.types.Pointer.fromPyobj(options)._ptr,count))
    return (_amd_comgr_action_info_set_option_list__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_get_option_list_count(object action_info):
    r"""Return the number of options in the options array.

    The ``action_info`` object must have had its options set with @p
    amd_comgr_action_info_set_option_list.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` The options of ``action_info`` were never
    set, or not set with ``amd_comgr_action_info_set_option_list.``

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``action_info`` is an
    invalid action info object, or ``count`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to query the data
    object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            The action info object to query.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`:
                The number of options in the options array.
    """
    cdef unsigned long count
    _amd_comgr_action_info_get_option_list_count__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_get_option_list_count(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],&count))
    return (_amd_comgr_action_info_get_option_list_count__retval,count)


@cython.embedsignature(True)
def amd_comgr_action_info_get_option_list_item(object action_info, unsigned long index, object size, object option):
    r"""Return the Nth option string in the options array and/or that
    option's length.

    The ``action_info`` object must have had its options set with @p
    amd_comgr_action_info_set_option_list.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` The options of ``action_info`` were never
    set, or not set with ``amd_comgr_action_info_set_option_list.``

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``action_info`` is an
    invalid action info object, ``index`` is invalid, or ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to query the data
    object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            The action info object to query.

        index (`~.int`) -- *IN*:
            The index of the option to be returned. The first option
            index is 0. The order is the same as the options when they were added in @p
            amd_comgr_action_info_set_options.

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            On entry, the size of ``option.`` On return, if @option
            is NULL, set to the size of the Nth option string including the terminating
            null character.

        option (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *OUT*:
            If not NULL, then the first ``size`` characters of the Nth
            option string are copied into ``option.`` If NULL, no option string is
            copied, and only ``size`` is updated (useful in order to find the size of
            buffer required to copy the option string).
    """
    _amd_comgr_action_info_get_option_list_item__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_get_option_list_item(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],index,
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr,
        <char *>rocm.llvm._util.types.CStr.fromPyobj(option)._ptr))
    return (_amd_comgr_action_info_get_option_list_item__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_set_bundle_entry_ids(object action_info, object bundle_entry_ids, unsigned long count):
    r"""Set the bundle entry IDs of an action info object.

    When an action info object is created it has no bundle entry IDs. Some
    actions require that the action info object has bundle entry IDs
    defined.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object. ``contains`` an invalid
    bundle ID not supported by this version of the code object manager
    library.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update action info object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            A handle to the action info object to be
            updated.

        bundle_entry_ids (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN*:
            An array of strings containing one or more
            bundle entry ID strings. If NULL then the bundle entry ID strings are
            cleared. These IDs are described at
            https://clang.llvm.org/docs/ClangOffloadBundler.html`~.bundle`-entry-id

        count (`~.int`):
            (undocumented)
    """
    _amd_comgr_action_info_set_bundle_entry_ids__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_set_bundle_entry_ids(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],
        <const char **>rocm.llvm._util.types.Pointer.fromPyobj(bundle_entry_ids)._ptr,count))
    return (_amd_comgr_action_info_set_bundle_entry_ids__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_get_bundle_entry_id_count(object action_info, object count):
    r"""Get number of bundle entry IDs

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object. ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            The action info object to query.

        count (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *OUT*:
            The number of bundle entry IDs availible. This value
            can be used as an upper bound to the Index provided to the corresponding
            amd_comgr_get_bundle_entry_id() call.
    """
    _amd_comgr_action_info_get_bundle_entry_id_count__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_get_bundle_entry_id_count(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(count)._ptr))
    return (_amd_comgr_action_info_get_bundle_entry_id_count__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_get_bundle_entry_id(object action_info, unsigned long index, object size, object bundle_entry_id):
    r"""Fetch the Nth specific bundle entry ID or that ID's length.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object. ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            The action info object to query.

        index (`~.int`) -- *IN*:
            The index of the bundle entry ID to be returned.

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            For out, the size of ``bundle_entry_id.`` For in,
            if @bundle_entry_id is NULL, set to the size of the Nth ID string including
            the terminating null character.

        bundle_entry_id (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *OUT*:
            If not NULL, then the first ``size`` characters of
            the Nth bundle entry ID string are copied into ``bundle_entry_id.`` If NULL,
            no bundle entry ID is copied, and only ``size`` is updated (useful in order
            to find the size of the buffer requried to copy the bundle_entry_id string).
    """
    _amd_comgr_action_info_get_bundle_entry_id__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_get_bundle_entry_id(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],index,
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr,
        <char *>rocm.llvm._util.types.CStr.fromPyobj(bundle_entry_id)._ptr))
    return (_amd_comgr_action_info_get_bundle_entry_id__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_set_working_directory_path(object action_info, object path):
    r"""Set the working directory of an action info object.

    When an action info object is created it has an empty working
    directory. Some actions use the working directory to resolve
    relative file paths.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update action info object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            A handle to the action info object to be
            updated.

        path (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *IN*:
            A null terminated string that is the working
            directory path. If NULL or the empty string then the working
            directory is cleared.
    """
    _amd_comgr_action_info_set_working_directory_path__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_set_working_directory_path(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr))
    return (_amd_comgr_action_info_set_working_directory_path__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_get_working_directory_path(object action_info, object size, object path):
    r"""Get the working directory path and/or working directory path
    length of an action info object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object. ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            The action info object to query.

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            On entry, the size of ``path.`` On return, if ``path`` is
            NULL, set to the size of the working directory path including the
            terminating null character.

        path (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *OUT*:
            If not NULL, then the first ``size`` characters of
            the working directory path is copied. If the working directory path
            is not set then an empty string is copied. If NULL, the working
            directory path is not copied, and only ``size`` is updated (useful
            in order to find the size of buffer required to copy the working
            directory path).
    """
    _amd_comgr_action_info_get_working_directory_path__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_get_working_directory_path(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr,
        <char *>rocm.llvm._util.types.CStr.fromPyobj(path)._ptr))
    return (_amd_comgr_action_info_get_working_directory_path__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_set_logging(object action_info, _Bool logging):
    r"""Set whether logging is enabled for an action info object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update action info object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            A handle to the action info object to be
            updated.

        logging (`~.bint`) -- *IN*:
            Whether logging should be enabled or disable.
    """
    _amd_comgr_action_info_set_logging__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_set_logging(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],logging))
    return (_amd_comgr_action_info_set_logging__retval,)


@cython.embedsignature(True)
def amd_comgr_action_info_get_logging(object action_info, object logging):
    r"""Get whether logging is enabled for an action info object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    action_info is an invalid action info object. ``logging`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        action_info (`~.amd_comgr_action_info_s`) -- *IN*:
            The action info object to query.

        logging (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *OUT*:
            Whether logging is enabled.
    """
    _amd_comgr_action_info_get_logging__retval = amd_comgr_status_s(camd_comgr.amd_comgr_action_info_get_logging(
        amd_comgr_action_info_s.fromPyobj(action_info).getElementPtr()[0],
        <_Bool *>rocm.llvm._util.types.Pointer.fromPyobj(logging)._ptr))
    return (_amd_comgr_action_info_get_logging__retval,)


class _amd_comgr_action_kind_s__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class amd_comgr_action_kind_s(_amd_comgr_action_kind_s__Base):
    """The kinds of actions that can be performed.

    Attributes:
        AMD_COMGR_ACTION_SOURCE_TO_PREPROCESSOR:
            Preprocess each source data object in input in order. For each successful preprocessor invocation, add a source data object to result. Resolve any include source names using the names of include data objects in input. Resolve any include relative path names using the working directory path in info. Preprocess the source for the language in info.
        AMD_COMGR_ACTION_ADD_PRECOMPILED_HEADERS:
            Copy all existing data objects in input to output, then add the device-specific and language-specific precompiled headers required for compilation.
        AMD_COMGR_ACTION_COMPILE_SOURCE_TO_BC:
            Compile each source data object in input in order. For each successful compilation add a bc data object to result. Resolve any include source names using the names of include data objects in input. Resolve any include relative path names using the working directory path in info. Produce bc for isa name in info. Compile the source for the language in info.
        AMD_COMGR_ACTION_ADD_DEVICE_LIBRARIES:
            Copy all existing data objects in input to output, then add the device-specific and language-specific bitcode libraries required for compilation.
        AMD_COMGR_ACTION_LINK_BC_TO_BC:
            Link a collection of bitcodes, bundled bitcodes, and bundled bitcode archives in into a single composite (unbundled) bitcode . Any device library bc data object must be explicitly added to input if needed.
        AMD_COMGR_ACTION_OPTIMIZE_BC_TO_BC:
            Optimize each bc data object in input and create an optimized bc data object to result.
        AMD_COMGR_ACTION_CODEGEN_BC_TO_RELOCATABLE:
            Perform code generation for each bc data object in input in order. For each successful code generation add a relocatable data object to result.
        AMD_COMGR_ACTION_CODEGEN_BC_TO_ASSEMBLY:
            Perform code generation for each bc data object in input in order. For each successful code generation add an assembly source data object to result.
        AMD_COMGR_ACTION_LINK_RELOCATABLE_TO_RELOCATABLE:
            Link each relocatable data object in input together and add the linked relocatable data object to result. Any device library relocatable data object must be explicitly added to input if needed.
        AMD_COMGR_ACTION_LINK_RELOCATABLE_TO_EXECUTABLE:
            Link each relocatable data object in input together and add the linked executable data object to result. Any device library relocatable data object must be explicitly added to input if needed.
        AMD_COMGR_ACTION_ASSEMBLE_SOURCE_TO_RELOCATABLE:
            Assemble each source data object in input in order into machine code. For each successful assembly add a relocatable data object to result. Resolve any include source names using the names of include data objects in input. Resolve any include relative path names using the working directory path in info. Produce relocatable for isa name in info.
        AMD_COMGR_ACTION_DISASSEMBLE_RELOCATABLE_TO_SOURCE:
            Disassemble each relocatable data object in input in order. For each successful disassembly add a source data object to result.
        AMD_COMGR_ACTION_DISASSEMBLE_EXECUTABLE_TO_SOURCE:
            Disassemble each executable data object in input in order. For each successful disassembly add a source data object to result.
        AMD_COMGR_ACTION_DISASSEMBLE_BYTES_TO_SOURCE:
            Disassemble each bytes data object in input in order. For each successful disassembly add a source data object to result. Only simple assembly language commands are generate that corresponf to raw bytes are supported, not any directives that control the code object layout, or symbolic branch targets or names.
        AMD_COMGR_ACTION_COMPILE_SOURCE_TO_FATBIN:
            Compile each source data object in input in order. For each successful compilation add a fat binary to result. Resolve any include source names using the names of include data objects in input. Resolve any include relative path names using the working directory path in info. Produce fat binary for isa name in info. Compile the source for the language in info.
        AMD_COMGR_ACTION_COMPILE_SOURCE_WITH_DEVICE_LIBS_TO_BC:
            Compile each source data object in input in order. For each successful compilation add a bc data object to result. Resolve any include source names using the names of include data objects in input. Resolve any include relative path names using the working directory path in info. Produce bc for isa name in info. Compile the source for the language in info. Link against the device-specific and language-specific bitcode device libraries required for compilation.
        AMD_COMGR_ACTION_COMPILE_SOURCE_TO_RELOCATABLE:
            Compile a single source data object in input in order. For each successful compilation add a relocatable data object to result. Resolve any include source names using the names of include data objects in input. Resolve any include relative path names using the working directory path in info. Produce relocatable for hip name in info. Compile the source for the language in info. Link against the device-specific and language-specific bitcode device libraries required for compilation. Currently only supports HIP language.
        AMD_COMGR_ACTION_COMPILE_SOURCE_TO_EXECUTABLE:
            Compile each source data object in input and create a single executabele in result. Resolve any include source names using the names of include data objects in input. Resolve any include relative path names using the working directory path in info. Produce executable for isa name in info. Compile the source for the language in info. Link against the device-specific and language-specific bitcode device libraries required for compilation.
        AMD_COMGR_ACTION_UNBUNDLE:
            Unbundle each source data object in input. These objects can be bitcode bundles, or an archive containing bitcode bundles. For each successful unbundling, add a bc object or archive object to result, depending on the corresponding input.
        AMD_COMGR_ACTION_LAST:
            Marker for last valid action kind.
    """
    AMD_COMGR_ACTION_SOURCE_TO_PREPROCESSOR = camd_comgr.AMD_COMGR_ACTION_SOURCE_TO_PREPROCESSOR
    AMD_COMGR_ACTION_ADD_PRECOMPILED_HEADERS = camd_comgr.AMD_COMGR_ACTION_ADD_PRECOMPILED_HEADERS
    AMD_COMGR_ACTION_COMPILE_SOURCE_TO_BC = camd_comgr.AMD_COMGR_ACTION_COMPILE_SOURCE_TO_BC
    AMD_COMGR_ACTION_ADD_DEVICE_LIBRARIES = camd_comgr.AMD_COMGR_ACTION_ADD_DEVICE_LIBRARIES
    AMD_COMGR_ACTION_LINK_BC_TO_BC = camd_comgr.AMD_COMGR_ACTION_LINK_BC_TO_BC
    AMD_COMGR_ACTION_OPTIMIZE_BC_TO_BC = camd_comgr.AMD_COMGR_ACTION_OPTIMIZE_BC_TO_BC
    AMD_COMGR_ACTION_CODEGEN_BC_TO_RELOCATABLE = camd_comgr.AMD_COMGR_ACTION_CODEGEN_BC_TO_RELOCATABLE
    AMD_COMGR_ACTION_CODEGEN_BC_TO_ASSEMBLY = camd_comgr.AMD_COMGR_ACTION_CODEGEN_BC_TO_ASSEMBLY
    AMD_COMGR_ACTION_LINK_RELOCATABLE_TO_RELOCATABLE = camd_comgr.AMD_COMGR_ACTION_LINK_RELOCATABLE_TO_RELOCATABLE
    AMD_COMGR_ACTION_LINK_RELOCATABLE_TO_EXECUTABLE = camd_comgr.AMD_COMGR_ACTION_LINK_RELOCATABLE_TO_EXECUTABLE
    AMD_COMGR_ACTION_ASSEMBLE_SOURCE_TO_RELOCATABLE = camd_comgr.AMD_COMGR_ACTION_ASSEMBLE_SOURCE_TO_RELOCATABLE
    AMD_COMGR_ACTION_DISASSEMBLE_RELOCATABLE_TO_SOURCE = camd_comgr.AMD_COMGR_ACTION_DISASSEMBLE_RELOCATABLE_TO_SOURCE
    AMD_COMGR_ACTION_DISASSEMBLE_EXECUTABLE_TO_SOURCE = camd_comgr.AMD_COMGR_ACTION_DISASSEMBLE_EXECUTABLE_TO_SOURCE
    AMD_COMGR_ACTION_DISASSEMBLE_BYTES_TO_SOURCE = camd_comgr.AMD_COMGR_ACTION_DISASSEMBLE_BYTES_TO_SOURCE
    AMD_COMGR_ACTION_COMPILE_SOURCE_TO_FATBIN = camd_comgr.AMD_COMGR_ACTION_COMPILE_SOURCE_TO_FATBIN
    AMD_COMGR_ACTION_COMPILE_SOURCE_WITH_DEVICE_LIBS_TO_BC = camd_comgr.AMD_COMGR_ACTION_COMPILE_SOURCE_WITH_DEVICE_LIBS_TO_BC
    AMD_COMGR_ACTION_COMPILE_SOURCE_TO_RELOCATABLE = camd_comgr.AMD_COMGR_ACTION_COMPILE_SOURCE_TO_RELOCATABLE
    AMD_COMGR_ACTION_COMPILE_SOURCE_TO_EXECUTABLE = camd_comgr.AMD_COMGR_ACTION_COMPILE_SOURCE_TO_EXECUTABLE
    AMD_COMGR_ACTION_UNBUNDLE = camd_comgr.AMD_COMGR_ACTION_UNBUNDLE
    AMD_COMGR_ACTION_LAST = camd_comgr.AMD_COMGR_ACTION_LAST
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


amd_comgr_action_kind_t = amd_comgr_action_kind_s

@cython.embedsignature(True)
def amd_comgr_do_action(object kind, object info, object input, object result):
    r"""Perform an action.

    Each action ignores any data objects in ``input`` that it does not
    use. If logging is enabled in @info then ``result`` will have a log
    data object added. Any diagnostic data objects produced by the
    action will be added to ``result.`` See the description of each
    action in ``amd_comgr_action_kind_t.``

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` An error was
    reported when executing the action.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    kind is an invalid action kind. ``input_data`` or ``result_data`` are
    invalid action data object handles. See the description of each
    action in ``amd_comgr_action_kind_t`` for other
    conditions that result in this status.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        kind (`~.amd_comgr_action_kind_s`) -- *IN*:
            The action to perform.

        info (`~.amd_comgr_action_info_s`) -- *IN*:
            The action info to use when performing the action.

        input (`~.amd_comgr_data_set_s`) -- *IN*:
            The input data objects to the ``kind`` action.

        result (`~.amd_comgr_data_set_s`) -- *OUT*:
            Any data objects are removed before performing
            the action which then adds all data objects produced by the action.
    """
    if not isinstance(kind,_amd_comgr_action_kind_s__Base):
        raise TypeError("argument 'kind' must be of type '_amd_comgr_action_kind_s__Base'")
    _amd_comgr_do_action__retval = amd_comgr_status_s(camd_comgr.amd_comgr_do_action(kind.value,
        amd_comgr_action_info_s.fromPyobj(info).getElementPtr()[0],
        amd_comgr_data_set_s.fromPyobj(input).getElementPtr()[0],
        amd_comgr_data_set_s.fromPyobj(result).getElementPtr()[0]))
    return (_amd_comgr_do_action__retval,)


class _amd_comgr_metadata_kind_s__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class amd_comgr_metadata_kind_s(_amd_comgr_metadata_kind_s__Base):
    """The kinds of metadata nodes.

    Attributes:
        AMD_COMGR_METADATA_KIND_NULL:
            The NULL metadata handle.
        AMD_COMGR_METADATA_KIND_STRING:
            A sting value.
        AMD_COMGR_METADATA_KIND_MAP:
            A map that consists of a set of key and value pairs.
        AMD_COMGR_METADATA_KIND_LIST:
            A list that consists of a sequence of values.
        AMD_COMGR_METADATA_KIND_LAST:
            Marker for last valid metadata kind.
    """
    AMD_COMGR_METADATA_KIND_NULL = camd_comgr.AMD_COMGR_METADATA_KIND_NULL
    AMD_COMGR_METADATA_KIND_STRING = camd_comgr.AMD_COMGR_METADATA_KIND_STRING
    AMD_COMGR_METADATA_KIND_MAP = camd_comgr.AMD_COMGR_METADATA_KIND_MAP
    AMD_COMGR_METADATA_KIND_LIST = camd_comgr.AMD_COMGR_METADATA_KIND_LIST
    AMD_COMGR_METADATA_KIND_LAST = camd_comgr.AMD_COMGR_METADATA_KIND_LAST
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


amd_comgr_metadata_kind_t = amd_comgr_metadata_kind_s

@cython.embedsignature(True)
def amd_comgr_get_metadata_kind(object metadata):
    r"""Get the kind of the metadata node.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    metadata is an invalid metadata node. ``kind`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to create the data object as out of resources.

    Args:
        metadata (`~.amd_comgr_metadata_node_s`) -- *IN*:
            The metadata node to query.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.amd_comgr_metadata_kind_s`:
                The kind of the metadata node.
    """
    cdef camd_comgr.amd_comgr_metadata_kind_s kind
    _amd_comgr_get_metadata_kind__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_metadata_kind(
        amd_comgr_metadata_node_s.fromPyobj(metadata).getElementPtr()[0],&kind))
    return (_amd_comgr_get_metadata_kind__retval,amd_comgr_metadata_kind_s(kind))


@cython.embedsignature(True)
def amd_comgr_get_metadata_string(object metadata, object size, object string):
    r"""Get the string and/or string length from a metadata string
    node.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    metadata is an invalid metadata node, or does not have kind @p
    AMD_COMGR_METADATA_KIND_STRING. ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        metadata (`~.amd_comgr_metadata_node_s`) -- *IN*:
            The metadata node to query.

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            On entry, the size of ``string.`` On return, if @p
            string is NULL, set to the size of the string including the terminating null
            character.

        string (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *OUT*:
            If not NULL, then the first ``size`` characters
            of the string are copied. If NULL, no string is copied, and only @p
            size is updated (useful in order to find the size of buffer required
            to copy the string).
    """
    _amd_comgr_get_metadata_string__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_metadata_string(
        amd_comgr_metadata_node_s.fromPyobj(metadata).getElementPtr()[0],
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr,
        <char *>rocm.llvm._util.types.CStr.fromPyobj(string)._ptr))
    return (_amd_comgr_get_metadata_string__retval,)


@cython.embedsignature(True)
def amd_comgr_get_metadata_map_size(object metadata):
    r"""Get the map size from a metadata map node.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    metadata is an invalid metadata node, or not of kind @p
    AMD_COMGR_METADATA_KIND_MAP. ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        metadata (`~.amd_comgr_metadata_node_s`) -- *IN*:
            The metadata node to query.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`:
                The number of entries in the map.
    """
    cdef unsigned long size
    _amd_comgr_get_metadata_map_size__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_metadata_map_size(
        amd_comgr_metadata_node_s.fromPyobj(metadata).getElementPtr()[0],&size))
    return (_amd_comgr_get_metadata_map_size__retval,size)


cdef class amd_comgr_iterate_map_metadata_anon_funptr_0(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_iterate_map_metadata_anon_funptr_0.

    Python wrapper for cdef class camd_comgr.amd_comgr_iterate_map_metadata_anon_funptr_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_iterate_map_metadata_anon_funptr_0 getElementPtr(self):
        return <camd_comgr.amd_comgr_iterate_map_metadata_anon_funptr_0>self._ptr

    @staticmethod
    cdef amd_comgr_iterate_map_metadata_anon_funptr_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_iterate_map_metadata_anon_funptr_0`` objects from
        given ``camd_comgr.amd_comgr_iterate_map_metadata_anon_funptr_0`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_iterate_map_metadata_anon_funptr_0 wrapper = amd_comgr_iterate_map_metadata_anon_funptr_0.__new__(amd_comgr_iterate_map_metadata_anon_funptr_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_iterate_map_metadata_anon_funptr_0 from a Python object.

        Derives a amd_comgr_iterate_map_metadata_anon_funptr_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_iterate_map_metadata_anon_funptr_0`` reference, this method
        returns it directly. No new ``amd_comgr_iterate_map_metadata_anon_funptr_0`` is created in this case.
        """
        return amd_comgr_iterate_map_metadata_anon_funptr_0.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_iterate_map_metadata_anon_funptr_0 fromPyobj(object pyobj):
        """Creates a amd_comgr_iterate_map_metadata_anon_funptr_0 from a Python object.

        Derives a amd_comgr_iterate_map_metadata_anon_funptr_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_iterate_map_metadata_anon_funptr_0`` reference, this method
        returns it directly. No new ``amd_comgr_iterate_map_metadata_anon_funptr_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_iterate_map_metadata_anon_funptr_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_iterate_map_metadata_anon_funptr_0!
        """
        cdef amd_comgr_iterate_map_metadata_anon_funptr_0 wrapper

        if isinstance(pyobj,amd_comgr_iterate_map_metadata_anon_funptr_0):
            return pyobj
        else:
            wrapper = amd_comgr_iterate_map_metadata_anon_funptr_0.__new__(amd_comgr_iterate_map_metadata_anon_funptr_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_iterate_map_metadata_anon_funptr_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def amd_comgr_iterate_map_metadata(object metadata, object callback, object user_data):
    r"""Iterate over the elements a metadata map node.

    Warning:
        The metadata nodes which are passed to the callback are not owned
        by the callback, and are freed just after the callback returns. The callback
        must not save any references to its parameters between iterations.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` An error was
    reported by ``callback.``

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    metadata is an invalid metadata node, or not of kind @p
    AMD_COMGR_METADATA_KIND_MAP. ``callback`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to iterate the metadata as out of resources.

    Args:
        metadata (`~.amd_comgr_metadata_node_s`) -- *IN*:
            The metadata node to query.

        callback (`~.amd_comgr_iterate_map_metadata_anon_funptr_0`/`~.object`) -- *IN*:
            The function to call for each entry in the map. The
            entry's key is passed in ``key,`` the entry's value is passed in ``value,`` and
            ``user_data`` is passed as ``user_data.`` If the function returns with a status
            other than ``AMD_COMGR_STATUS_SUCCESS`` then iteration is stopped.

        user_data (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN*:
            The value to pass to each invocation of @p
            callback. Allows context to be passed into the call back function.
    """
    _amd_comgr_iterate_map_metadata__retval = amd_comgr_status_s(camd_comgr.amd_comgr_iterate_map_metadata(
        amd_comgr_metadata_node_s.fromPyobj(metadata).getElementPtr()[0],
        amd_comgr_iterate_map_metadata_anon_funptr_0.fromPyobj(callback).getElementPtr(),
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(user_data)._ptr))
    return (_amd_comgr_iterate_map_metadata__retval,)


@cython.embedsignature(True)
def amd_comgr_metadata_lookup(object metadata, object key):
    r"""Use a string key to lookup an element of a metadata map
    node and return the entry value.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` The map has no entry
    with a string key with the value ``key.``

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    metadata is an invalid metadata node, or not of kind @p
    AMD_COMGR_METADATA_KIND_MAP. ``key`` or ``value`` is
    NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to lookup metadata as out of resources.

    Args:
        metadata (`~.amd_comgr_metadata_node_s`) -- *IN*:
            The metadata node to query.

        key (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *IN*:
            A null terminated string that is the key to lookup.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.amd_comgr_metadata_node_s`:
                The metadata node of the ``key`` element of the
                ``metadata`` map metadata node. The handle must be destroyed
                using ``amd_comgr_destroy_metadata.``
    """
    value = amd_comgr_metadata_node_s.new()
    _amd_comgr_metadata_lookup__retval = amd_comgr_status_s(camd_comgr.amd_comgr_metadata_lookup(
        amd_comgr_metadata_node_s.fromPyobj(metadata).getElementPtr()[0],
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(key)._ptr,<camd_comgr.amd_comgr_metadata_node_s*>value._ptr))
    return (_amd_comgr_metadata_lookup__retval,value)


@cython.embedsignature(True)
def amd_comgr_get_metadata_list_size(object metadata):
    r"""Get the list size from a metadata list node.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    metadata is an invalid metadata node, or does nopt have kind @p
    AMD_COMGR_METADATA_KIND_LIST. ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update the data object as out of resources.

    Args:
        metadata (`~.amd_comgr_metadata_node_s`) -- *IN*:
            The metadata node to query.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.int`:
                The number of entries in the list.
    """
    cdef unsigned long size
    _amd_comgr_get_metadata_list_size__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_metadata_list_size(
        amd_comgr_metadata_node_s.fromPyobj(metadata).getElementPtr()[0],&size))
    return (_amd_comgr_get_metadata_list_size__retval,size)


@cython.embedsignature(True)
def amd_comgr_index_list_metadata(object metadata, unsigned long index):
    r"""Return the Nth metadata node of a list metadata node.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` @p
    metadata is an invalid metadata node or not of kind @p
    AMD_COMGR_METADATA_INFO_LIST. ``index`` is greater
    than the number of list elements. ``value`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to update action data object as out of resources.

    Args:
        metadata (`~.amd_comgr_metadata_node_s`) -- *IN*:
            The metadata node to query.

        index (`~.int`) -- *IN*:
            The index being requested. The first list element
            is index 0.

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.amd_comgr_metadata_node_s`:
                The metadata node of the ``index`` element of the
                ``metadata`` list metadata node. The handle must be destroyed
                using ``amd_comgr_destroy_metadata.``
    """
    value = amd_comgr_metadata_node_s.new()
    _amd_comgr_index_list_metadata__retval = amd_comgr_status_s(camd_comgr.amd_comgr_index_list_metadata(
        amd_comgr_metadata_node_s.fromPyobj(metadata).getElementPtr()[0],index,<camd_comgr.amd_comgr_metadata_node_s*>value._ptr))
    return (_amd_comgr_index_list_metadata__retval,value)


cdef class amd_comgr_iterate_symbols_anon_funptr_0(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_iterate_symbols_anon_funptr_0.

    Python wrapper for cdef class camd_comgr.amd_comgr_iterate_symbols_anon_funptr_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_iterate_symbols_anon_funptr_0 getElementPtr(self):
        return <camd_comgr.amd_comgr_iterate_symbols_anon_funptr_0>self._ptr

    @staticmethod
    cdef amd_comgr_iterate_symbols_anon_funptr_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_iterate_symbols_anon_funptr_0`` objects from
        given ``camd_comgr.amd_comgr_iterate_symbols_anon_funptr_0`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_iterate_symbols_anon_funptr_0 wrapper = amd_comgr_iterate_symbols_anon_funptr_0.__new__(amd_comgr_iterate_symbols_anon_funptr_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_iterate_symbols_anon_funptr_0 from a Python object.

        Derives a amd_comgr_iterate_symbols_anon_funptr_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_iterate_symbols_anon_funptr_0`` reference, this method
        returns it directly. No new ``amd_comgr_iterate_symbols_anon_funptr_0`` is created in this case.
        """
        return amd_comgr_iterate_symbols_anon_funptr_0.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_iterate_symbols_anon_funptr_0 fromPyobj(object pyobj):
        """Creates a amd_comgr_iterate_symbols_anon_funptr_0 from a Python object.

        Derives a amd_comgr_iterate_symbols_anon_funptr_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_iterate_symbols_anon_funptr_0`` reference, this method
        returns it directly. No new ``amd_comgr_iterate_symbols_anon_funptr_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_iterate_symbols_anon_funptr_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_iterate_symbols_anon_funptr_0!
        """
        cdef amd_comgr_iterate_symbols_anon_funptr_0 wrapper

        if isinstance(pyobj,amd_comgr_iterate_symbols_anon_funptr_0):
            return pyobj
        else:
            wrapper = amd_comgr_iterate_symbols_anon_funptr_0.__new__(amd_comgr_iterate_symbols_anon_funptr_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_iterate_symbols_anon_funptr_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def amd_comgr_iterate_symbols(object data, object callback, object user_data):
    r"""Iterate over the symbols of a machine code object.

    For a AMD_COMGR_DATA_KIND_RELOCATABLE the symbols in the ELF symtab section
    are iterated. For a AMD_COMGR_DATA_KIND_EXECUTABLE the symbols in the ELF
    dynsymtab are iterated.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` An error was
    reported by ``callback.``

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data`` is an invalid data
    object, or not of kind ``AMD_COMGR_DATA_KIND_RELOCATABLE`` or
    AMD_COMGR_DATA_KIND_EXECUTABLE. ``callback`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to iterate the data object as out of resources.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            The data object to query.

        callback (`~.amd_comgr_iterate_symbols_anon_funptr_0`/`~.object`) -- *IN*:
            The function to call for each symbol in the machine code
            data object. The symbol handle is passed in ``symbol`` and ``user_data`` is
            passed as ``user_data.`` If the function returns with a status other than @p
            AMD_COMGR_STATUS_SUCCESS then iteration is stopped.

        user_data (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN*:
            The value to pass to each invocation of @p
            callback. Allows context to be passed into the call back function.
    """
    _amd_comgr_iterate_symbols__retval = amd_comgr_status_s(camd_comgr.amd_comgr_iterate_symbols(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],
        amd_comgr_iterate_symbols_anon_funptr_0.fromPyobj(callback).getElementPtr(),
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(user_data)._ptr))
    return (_amd_comgr_iterate_symbols__retval,)


@cython.embedsignature(True)
def amd_comgr_symbol_lookup(object data, object name, object symbol):
    r"""Lookup a symbol in a machine code object by name.

    For a AMD_COMGR_DATA_KIND_RELOCATABLE the symbols in the ELF symtab section
    are inspected. For a AMD_COMGR_DATA_KIND_EXECUTABLE the symbols in the ELF
    dynsymtab are inspected.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` The machine code object has no symbol
    with ``name.``

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data`` is an invalid data
    object, or not of kind ``AMD_COMGR_DATA_KIND_RELOCATABLE`` or
    AMD_COMGR_DATA_KIND_EXECUTABLE.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to lookup symbol as out of resources.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            The data object to query.

        name (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *IN*:
            A null terminated string that is the symbol name to lookup.

        symbol (`~.amd_comgr_symbol_s`/`~.object`) -- *OUT*:
            The symbol with the ``name.``
    """
    _amd_comgr_symbol_lookup__retval = amd_comgr_status_s(camd_comgr.amd_comgr_symbol_lookup(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(name)._ptr,
        amd_comgr_symbol_s.fromPyobj(symbol).getElementPtr()))
    return (_amd_comgr_symbol_lookup__retval,)


class _amd_comgr_symbol_type_s__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class amd_comgr_symbol_type_s(_amd_comgr_symbol_type_s__Base):
    """Machine code object symbol type.

    Attributes:
        AMD_COMGR_SYMBOL_TYPE_UNKNOWN:
            The symbol's type is unknown.
        AMD_COMGR_SYMBOL_TYPE_NOTYPE:
            The symbol's type is not specified.
        AMD_COMGR_SYMBOL_TYPE_OBJECT:
            The symbol is associated with a data object, such as a variable, an array, and so on.
        AMD_COMGR_SYMBOL_TYPE_FUNC:
            The symbol is associated with a function or other executable code.
        AMD_COMGR_SYMBOL_TYPE_SECTION:
            The symbol is associated with a section. Symbol table entries of this type exist primarily for relocation.
        AMD_COMGR_SYMBOL_TYPE_FILE:
            Conventionally, the symbol's name gives the name of the source file associated with the object file.
        AMD_COMGR_SYMBOL_TYPE_COMMON:
            The symbol labels an uninitialized common block.
        AMD_COMGR_SYMBOL_TYPE_AMDGPU_HSA_KERNEL:
            The symbol is associated with an AMDGPU Code Object V2 kernel function.
    """
    AMD_COMGR_SYMBOL_TYPE_UNKNOWN = camd_comgr.AMD_COMGR_SYMBOL_TYPE_UNKNOWN
    AMD_COMGR_SYMBOL_TYPE_NOTYPE = camd_comgr.AMD_COMGR_SYMBOL_TYPE_NOTYPE
    AMD_COMGR_SYMBOL_TYPE_OBJECT = camd_comgr.AMD_COMGR_SYMBOL_TYPE_OBJECT
    AMD_COMGR_SYMBOL_TYPE_FUNC = camd_comgr.AMD_COMGR_SYMBOL_TYPE_FUNC
    AMD_COMGR_SYMBOL_TYPE_SECTION = camd_comgr.AMD_COMGR_SYMBOL_TYPE_SECTION
    AMD_COMGR_SYMBOL_TYPE_FILE = camd_comgr.AMD_COMGR_SYMBOL_TYPE_FILE
    AMD_COMGR_SYMBOL_TYPE_COMMON = camd_comgr.AMD_COMGR_SYMBOL_TYPE_COMMON
    AMD_COMGR_SYMBOL_TYPE_AMDGPU_HSA_KERNEL = camd_comgr.AMD_COMGR_SYMBOL_TYPE_AMDGPU_HSA_KERNEL
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_int


amd_comgr_symbol_type_t = amd_comgr_symbol_type_s

class _amd_comgr_symbol_info_s__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class amd_comgr_symbol_info_s(_amd_comgr_symbol_info_s__Base):
    """Machine code object symbol attributes.

    Attributes:
        AMD_COMGR_SYMBOL_INFO_NAME_LENGTH:
            The length of the symbol name in bytes. Does not include the NUL terminator. The type of this attribute is uint64_t.
        AMD_COMGR_SYMBOL_INFO_NAME:
            The name of the symbol. The type of this attribute is character array with the length equal to the value of the AMD_COMGR_SYMBOL_INFO_NAME_LENGTH attribute plus 1 for a NUL terminator.
        AMD_COMGR_SYMBOL_INFO_TYPE:
            The kind of the symbol. The type of this attribute is amd_comgr_symbol_type_t.
        AMD_COMGR_SYMBOL_INFO_SIZE:
            Size of the variable. The value of this attribute is undefined if the symbol is not a variable. The type of this attribute is uint64_t.
        AMD_COMGR_SYMBOL_INFO_IS_UNDEFINED:
            Indicates whether the symbol is undefined. The type of this attribute is bool.
        AMD_COMGR_SYMBOL_INFO_VALUE:
            The value of the symbol. The type of this attribute is uint64_t.
        AMD_COMGR_SYMBOL_INFO_LAST:
            Marker for last valid symbol info.
    """
    AMD_COMGR_SYMBOL_INFO_NAME_LENGTH = camd_comgr.AMD_COMGR_SYMBOL_INFO_NAME_LENGTH
    AMD_COMGR_SYMBOL_INFO_NAME = camd_comgr.AMD_COMGR_SYMBOL_INFO_NAME
    AMD_COMGR_SYMBOL_INFO_TYPE = camd_comgr.AMD_COMGR_SYMBOL_INFO_TYPE
    AMD_COMGR_SYMBOL_INFO_SIZE = camd_comgr.AMD_COMGR_SYMBOL_INFO_SIZE
    AMD_COMGR_SYMBOL_INFO_IS_UNDEFINED = camd_comgr.AMD_COMGR_SYMBOL_INFO_IS_UNDEFINED
    AMD_COMGR_SYMBOL_INFO_VALUE = camd_comgr.AMD_COMGR_SYMBOL_INFO_VALUE
    AMD_COMGR_SYMBOL_INFO_LAST = camd_comgr.AMD_COMGR_SYMBOL_INFO_LAST
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


amd_comgr_symbol_info_t = amd_comgr_symbol_info_s

@cython.embedsignature(True)
def amd_comgr_symbol_get_info(object symbol, object attribute, object value):
    r"""Query information about a machine code object symbol.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has
    been executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` The ``symbol`` does not have the requested @p
    attribute.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``symbol`` is an invalid
    symbol. ``attribute`` is an invalid value. ``value`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES`
    Unable to query symbol as out of resources.

    Args:
        symbol (`~.amd_comgr_symbol_s`) -- *IN*:
            The symbol to query.

        attribute (`~.amd_comgr_symbol_info_s`) -- *IN*:
            Attribute to query.

        value (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *OUT*:
            Pointer to an application-allocated buffer where to store
            the value of the attribute. If the buffer passed by the application is not
            large enough to hold the value of attribute, the behavior is undefined. The
            type of value returned is specified by ``amd_comgr_symbol_info_t.``
    """
    if not isinstance(attribute,_amd_comgr_symbol_info_s__Base):
        raise TypeError("argument 'attribute' must be of type '_amd_comgr_symbol_info_s__Base'")
    _amd_comgr_symbol_get_info__retval = amd_comgr_status_s(camd_comgr.amd_comgr_symbol_get_info(
        amd_comgr_symbol_s.fromPyobj(symbol).getElementPtr()[0],attribute.value,
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(value)._ptr))
    return (_amd_comgr_symbol_get_info__retval,)


cdef class amd_comgr_create_disassembly_info_anon_funptr_0(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_0.

    Python wrapper for cdef class camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_0.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_0 getElementPtr(self):
        return <camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_0>self._ptr

    @staticmethod
    cdef amd_comgr_create_disassembly_info_anon_funptr_0 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_create_disassembly_info_anon_funptr_0`` objects from
        given ``camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_0`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_create_disassembly_info_anon_funptr_0 wrapper = amd_comgr_create_disassembly_info_anon_funptr_0.__new__(amd_comgr_create_disassembly_info_anon_funptr_0)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_create_disassembly_info_anon_funptr_0 from a Python object.

        Derives a amd_comgr_create_disassembly_info_anon_funptr_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_create_disassembly_info_anon_funptr_0`` reference, this method
        returns it directly. No new ``amd_comgr_create_disassembly_info_anon_funptr_0`` is created in this case.
        """
        return amd_comgr_create_disassembly_info_anon_funptr_0.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_create_disassembly_info_anon_funptr_0 fromPyobj(object pyobj):
        """Creates a amd_comgr_create_disassembly_info_anon_funptr_0 from a Python object.

        Derives a amd_comgr_create_disassembly_info_anon_funptr_0 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_create_disassembly_info_anon_funptr_0`` reference, this method
        returns it directly. No new ``amd_comgr_create_disassembly_info_anon_funptr_0`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_create_disassembly_info_anon_funptr_0`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_create_disassembly_info_anon_funptr_0!
        """
        cdef amd_comgr_create_disassembly_info_anon_funptr_0 wrapper

        if isinstance(pyobj,amd_comgr_create_disassembly_info_anon_funptr_0):
            return pyobj
        else:
            wrapper = amd_comgr_create_disassembly_info_anon_funptr_0.__new__(amd_comgr_create_disassembly_info_anon_funptr_0)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_create_disassembly_info_anon_funptr_0 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class amd_comgr_create_disassembly_info_anon_funptr_1(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_1.

    Python wrapper for cdef class camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_1.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_1 getElementPtr(self):
        return <camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_1>self._ptr

    @staticmethod
    cdef amd_comgr_create_disassembly_info_anon_funptr_1 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_create_disassembly_info_anon_funptr_1`` objects from
        given ``camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_1`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_create_disassembly_info_anon_funptr_1 wrapper = amd_comgr_create_disassembly_info_anon_funptr_1.__new__(amd_comgr_create_disassembly_info_anon_funptr_1)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_create_disassembly_info_anon_funptr_1 from a Python object.

        Derives a amd_comgr_create_disassembly_info_anon_funptr_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_create_disassembly_info_anon_funptr_1`` reference, this method
        returns it directly. No new ``amd_comgr_create_disassembly_info_anon_funptr_1`` is created in this case.
        """
        return amd_comgr_create_disassembly_info_anon_funptr_1.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_create_disassembly_info_anon_funptr_1 fromPyobj(object pyobj):
        """Creates a amd_comgr_create_disassembly_info_anon_funptr_1 from a Python object.

        Derives a amd_comgr_create_disassembly_info_anon_funptr_1 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_create_disassembly_info_anon_funptr_1`` reference, this method
        returns it directly. No new ``amd_comgr_create_disassembly_info_anon_funptr_1`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_create_disassembly_info_anon_funptr_1`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_create_disassembly_info_anon_funptr_1!
        """
        cdef amd_comgr_create_disassembly_info_anon_funptr_1 wrapper

        if isinstance(pyobj,amd_comgr_create_disassembly_info_anon_funptr_1):
            return pyobj
        else:
            wrapper = amd_comgr_create_disassembly_info_anon_funptr_1.__new__(amd_comgr_create_disassembly_info_anon_funptr_1)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_create_disassembly_info_anon_funptr_1 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


cdef class amd_comgr_create_disassembly_info_anon_funptr_2(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_2.

    Python wrapper for cdef class camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_2.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_2 getElementPtr(self):
        return <camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_2>self._ptr

    @staticmethod
    cdef amd_comgr_create_disassembly_info_anon_funptr_2 fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``amd_comgr_create_disassembly_info_anon_funptr_2`` objects from
        given ``camd_comgr.amd_comgr_create_disassembly_info_anon_funptr_2`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef amd_comgr_create_disassembly_info_anon_funptr_2 wrapper = amd_comgr_create_disassembly_info_anon_funptr_2.__new__(amd_comgr_create_disassembly_info_anon_funptr_2)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a amd_comgr_create_disassembly_info_anon_funptr_2 from a Python object.

        Derives a amd_comgr_create_disassembly_info_anon_funptr_2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_create_disassembly_info_anon_funptr_2`` reference, this method
        returns it directly. No new ``amd_comgr_create_disassembly_info_anon_funptr_2`` is created in this case.
        """
        return amd_comgr_create_disassembly_info_anon_funptr_2.fromPyobj(pyobj)

    @staticmethod
    cdef amd_comgr_create_disassembly_info_anon_funptr_2 fromPyobj(object pyobj):
        """Creates a amd_comgr_create_disassembly_info_anon_funptr_2 from a Python object.

        Derives a amd_comgr_create_disassembly_info_anon_funptr_2 from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``amd_comgr_create_disassembly_info_anon_funptr_2`` reference, this method
        returns it directly. No new ``amd_comgr_create_disassembly_info_anon_funptr_2`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `amd_comgr_create_disassembly_info_anon_funptr_2`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of amd_comgr_create_disassembly_info_anon_funptr_2!
        """
        cdef amd_comgr_create_disassembly_info_anon_funptr_2 wrapper

        if isinstance(pyobj,amd_comgr_create_disassembly_info_anon_funptr_2):
            return pyobj
        else:
            wrapper = amd_comgr_create_disassembly_info_anon_funptr_2.__new__(amd_comgr_create_disassembly_info_anon_funptr_2)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<amd_comgr_create_disassembly_info_anon_funptr_2 object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))


@cython.embedsignature(True)
def amd_comgr_create_disassembly_info(object isa_name, object read_memory_callback, object print_instruction_callback, object print_address_annotation_callback):
    r"""Create a disassembly info object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The disassembly info object was created.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``isa_name`` is NULL or
    invalid; or ``read_memory_callback,`` ``print_instruction_callback,``
    or ``print_address_annotation_callback`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to create the
    disassembly info object as out of resources.

    Args:
        isa_name (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *IN*:
            A null terminated string that is the isa name of the
            target to disassemble for. The isa name is defined as the Code Object Target
            Identification string, described at
            https://llvm.org/docs/AMDGPUUsage.html`~.code`-object-target-identification

        read_memory_callback (`~.amd_comgr_create_disassembly_info_anon_funptr_0`/`~.object`) -- *IN*:
            Function called to request ``size`` bytes
            from the program address space at ``from`` be read into ``to.`` The requested
            ``size`` is never zero. Returns the number of bytes which could be read, with
            the guarantee that no additional bytes will be available in any subsequent
            call.

        print_instruction_callback (`~.amd_comgr_create_disassembly_info_anon_funptr_1`/`~.object`) -- *IN*:
            Function called after a successful
            disassembly. ``instruction`` is a null terminated string containing the
            disassembled instruction. The callback does not own ``instruction,`` and it
            cannot be referenced once the callback returns.

        print_address_annotation_callback (`~.amd_comgr_create_disassembly_info_anon_funptr_2`/`~.object`) -- *IN*:
            Function called after @c
            print_instruction_callback returns, once for each instruction operand which
            was resolved to an absolute address. ``address`` is the absolute address in
            the program address space. It is intended to append a symbolic
            form of the address, perhaps as a comment, after the instruction disassembly
            produced by ``print_instruction_callback.``

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * `~.amd_comgr_disassembly_info_s`:
                A handle to the disassembly info object
                created.
    """
    disassembly_info = amd_comgr_disassembly_info_s.new()
    _amd_comgr_create_disassembly_info__retval = amd_comgr_status_s(camd_comgr.amd_comgr_create_disassembly_info(
        <const char *>rocm.llvm._util.types.CStr.fromPyobj(isa_name)._ptr,
        amd_comgr_create_disassembly_info_anon_funptr_0.fromPyobj(read_memory_callback).getElementPtr(),
        amd_comgr_create_disassembly_info_anon_funptr_1.fromPyobj(print_instruction_callback).getElementPtr(),
        amd_comgr_create_disassembly_info_anon_funptr_2.fromPyobj(print_address_annotation_callback).getElementPtr(),<camd_comgr.amd_comgr_disassembly_info_s*>disassembly_info._ptr))
    return (_amd_comgr_create_disassembly_info__retval,disassembly_info)


@cython.embedsignature(True)
def amd_comgr_destroy_disassembly_info(object disassembly_info):
    r"""Destroy a disassembly info object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The disassembly info object was
    destroyed.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``disassembly_info`` is an
    invalid disassembly info object.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to destroy the
    disassembly info object as out of resources.

    Args:
        disassembly_info (`~.amd_comgr_disassembly_info_s`) -- *IN*:
            A handle to the disassembly info object to
            destroy.
    """
    _amd_comgr_destroy_disassembly_info__retval = amd_comgr_status_s(camd_comgr.amd_comgr_destroy_disassembly_info(
        amd_comgr_disassembly_info_s.fromPyobj(disassembly_info).getElementPtr()[0]))
    return (_amd_comgr_destroy_disassembly_info__retval,)


@cython.embedsignature(True)
def amd_comgr_disassemble_instruction(object disassembly_info, unsigned long address, object user_data, object size):
    r"""Disassemble a single instruction.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The disassembly was successful.

    @retval `~.AMD_COMGR_STATUS_ERROR` The disassembly failed.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``disassembly_info`` is
    invalid or ``size`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Unable to disassemble the
    instruction as out of resources.

    Args:
        disassembly_info (`~.amd_comgr_disassembly_info_s`):
            (undocumented)

        address (`~.int`) -- *IN*:
            The address of the first byte of the instruction in the
            program address space.

        user_data (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN*:
            Arbitrary user-data passed to each callback function
            during disassembly.

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *OUT*:
            The number of bytes consumed to decode the
            instruction, or consumed while failing to decode an invalid instruction.
    """
    _amd_comgr_disassemble_instruction__retval = amd_comgr_status_s(camd_comgr.amd_comgr_disassemble_instruction(
        amd_comgr_disassembly_info_s.fromPyobj(disassembly_info).getElementPtr()[0],address,
        <void *>rocm.llvm._util.types.Pointer.fromPyobj(user_data)._ptr,
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr))
    return (_amd_comgr_disassemble_instruction__retval,)


@cython.embedsignature(True)
def amd_comgr_demangle_symbol_name(object mangled_symbol_name, object demangled_symbol_name):
    r"""Demangle a symbol name.

    Note:
        If the ``mangled_symbol_name`` cannot be demangled, it will be copied
        without changes to the ``demangled_symbol_name`` and AMD_COMGR_STATUS_SUCCESS
        is returned.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``mangled_symbol_name`` is
    an invalid data object or not of kind ``AMD_COMGR_DATA_KIND_BYTES`` or
    ``demangled_symbol_name`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES` Out of resources.

    Args:
        mangled_symbol_name (`~.amd_comgr_data_s`) -- *IN*:
            A data object of kind @p
            AMD_COMGR_DATA_KIND_BYTES containing the mangled symbol name.

        demangled_symbol_name (`~.amd_comgr_data_s`/`~.object`) -- *OUT*:
            A handle to the data object of kind @p
            AMD_COMGR_DATA_KIND_BYTES created and set to contain the demangled symbol
            name in case of successful completion. The handle must be released using
            ``amd_comgr_release_data.`` ``demangled_symbol_name`` is not updated for
            an error case.
    """
    _amd_comgr_demangle_symbol_name__retval = amd_comgr_status_s(camd_comgr.amd_comgr_demangle_symbol_name(
        amd_comgr_data_s.fromPyobj(mangled_symbol_name).getElementPtr()[0],
        amd_comgr_data_s.fromPyobj(demangled_symbol_name).getElementPtr()))
    return (_amd_comgr_demangle_symbol_name__retval,)


@cython.embedsignature(True)
def amd_comgr_populate_mangled_names(object data, object count):
    r"""Fetch mangled symbol names from a code object.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data`` is
    an invalid data object or not of kind ``AMD_COMGR_DATA_KIND_EXECUTABLE`` or
    ``AMD_COMGR_DATA_KIND_BC.``

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            A data object of kind @p
            AMD_COMGR_DATA_KIND_EXECUTABLE or ``AMD_COMGR_DATA_KIND_BC``

        count (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *OUT*:
            The number of mangled names retrieved. This value
            can be used as an upper bound to the Index provided to the corresponding
            amd_comgr_get_mangled_name() call.
    """
    _amd_comgr_populate_mangled_names__retval = amd_comgr_status_s(camd_comgr.amd_comgr_populate_mangled_names(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(count)._ptr))
    return (_amd_comgr_populate_mangled_names__retval,)


@cython.embedsignature(True)
def amd_comgr_get_mangled_name(object data, unsigned long index, object size, object mangled_name):
    r"""Fetch the Nth specific mangled name from a set of populated names or
    that name's length.

    The ``data`` must have had its mangled names populated with @p
    amd_comgr_populate_mangled_names.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` ``data`` has not been used to
    populate a set of mangled names, or index is greater than the count of
    mangled names for that data object

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            A data object of kind @p
            AMD_COMGR_DATA_KIND_EXECUTABLE or ``AMD_COMGR_DATA_KIND_BC`` used to
            identify which set of mangled names to retrive from.

        index (`~.int`) -- *IN*:
            The index of the mangled name to be returned.

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            For out, the size of ``mangled_name.`` For in,
            if @mangled_name is NULL, set to the size of the Nth option string including
            the terminating null character.

        mangled_name (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *OUT*:
            If not NULL, then the first ``size`` characters of
            the Nth mangled name string are copied into ``mangled_name.`` If NULL, no
            mangled name string is copied, and only ``size`` is updated (useful in order
            to find the size of the buffer requried to copy the mangled_name string).
    """
    _amd_comgr_get_mangled_name__retval = amd_comgr_status_s(camd_comgr.amd_comgr_get_mangled_name(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],index,
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr,
        <char *>rocm.llvm._util.types.CStr.fromPyobj(mangled_name)._ptr))
    return (_amd_comgr_get_mangled_name__retval,)


@cython.embedsignature(True)
def amd_comgr_populate_name_expression_map(object data, object count):
    r"""Populate a name expression map from a given code object.

    Used to map stub names *__amdgcn_name_expr_* in bitcodes and code
    objects generated by hip runtime to an associated (unmangled) name
    expression and (mangled) symbol name.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data`` is
    an invalid data object or not of kind ``AMD_COMGR_DATA_KIND_EXECUTABLE`` or
    ``AMD_COMGR_DATA_KIND_BC.``

    @retval `~.AMD_COMGR_STATUS_ERROR` LLVM API failure, which should be
    accompanied by an LLVM error message to stderr

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            A data object of kind @p
            AMD_COMGR_DATA_KIND_EXECUTABLE or ``AMD_COMGR_DATA_KIND_BC``

        count (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *OUT*:
            The number of name expressions mapped. This value
            can be used as an upper bound to the Index provided to the corresponding
            amd_comgr_map_name_expression_to_symbol_name() call.
    """
    _amd_comgr_populate_name_expression_map__retval = amd_comgr_status_s(camd_comgr.amd_comgr_populate_name_expression_map(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(count)._ptr))
    return (_amd_comgr_populate_name_expression_map__retval,)


@cython.embedsignature(True)
def amd_comgr_map_name_expression_to_symbol_name(object data, object size, object name_expression, object symbol_name):
    r"""Fetch a related symbol name for a given name expression;
    or that name's length.

    The ``data`` must have had its name expression map populated with @p
    amd_comgr_populate_name_expression_map.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function executed successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` ``data`` object is not valid (NULL or not of
    type bitcode or code object)

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``name_expression`` is not
    present in the name expression map.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            A data object of kind @p
            AMD_COMGR_DATA_KIND_EXECUTABLE or ``AMD_COMGR_DATA_KIND_BC`` used to
            identify which map of name expressions to retrieve from.

        size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *IN,OUT*:
            For out, the size of ``symbol_name.`` For in,
            if @symbol_name is NULL, set to the size of the Nth option string including
            the terminating null character.

        name_expression (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *IN*:
            A character array of a name expression. This name
            is used as the key to the name expression map in order to locate the desired
            @symbol_name.

        symbol_name (`~.rocm.llvm._util.types.CStr`/`~.object`) -- *OUT*:
            If not NULL, then the first ``size`` characters of
            the symbol name string mapped from @name_expression are copied into @p
            symbol_name. If NULL, no symbol name string is copied, and only ``size`` is
            updated (useful in order to find the size of the buffer required to copy the
            symbol_name string).
    """
    _amd_comgr_map_name_expression_to_symbol_name__retval = amd_comgr_status_s(camd_comgr.amd_comgr_map_name_expression_to_symbol_name(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(size)._ptr,
        <char *>rocm.llvm._util.types.CStr.fromPyobj(name_expression)._ptr,
        <char *>rocm.llvm._util.types.CStr.fromPyobj(symbol_name)._ptr))
    return (_amd_comgr_map_name_expression_to_symbol_name__retval,)


cdef class code_object_info_s(rocm.llvm._util.types.Pointer):
    """Python wrapper for cdef class camd_comgr.code_object_info_s.

    Python wrapper for cdef class camd_comgr.code_object_info_s.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `rocm.llvm._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef camd_comgr.code_object_info_s* getElementPtr(self):
        return <camd_comgr.code_object_info_s*>self._ptr

    @staticmethod
    cdef code_object_info_s fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``code_object_info_s`` objects from
        given ``camd_comgr.code_object_info_s`` pointer.

        Setting ``owner`` flag to ``True`` causes
        the extension type to free the structure pointed to by ``ptr``
        when the wrapper object is deallocated.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef code_object_info_s wrapper = code_object_info_s.__new__(code_object_info_s)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a code_object_info_s from a Python object.

        Derives a code_object_info_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``code_object_info_s`` reference, this method
        returns it directly. No new ``code_object_info_s`` is created in this case.
        """
        return code_object_info_s.fromPyobj(pyobj)

    @staticmethod
    cdef code_object_info_s fromPyobj(object pyobj):
        """Creates a code_object_info_s from a Python object.

        Derives a code_object_info_s from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``code_object_info_s`` reference, this method
        returns it directly. No new ``code_object_info_s`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `rocm.llvm._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `code_object_info_s`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of code_object_info_s!
        """
        cdef code_object_info_s wrapper

        if isinstance(pyobj,code_object_info_s):
            return pyobj
        else:
            wrapper = code_object_info_s.__new__(code_object_info_s)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)
        # De-allocate if not null and flag is set
        if self._ptr is not NULL and self._is_ptr_owner is True:
            stdlib.free(self._ptr)
            self._ptr = NULL

    @staticmethod
    cdef __allocate(void** ptr):
        ptr[0] = stdlib.malloc(sizeof(camd_comgr.code_object_info_s))
        string.memset(<void*>ptr[0], 0, sizeof(camd_comgr.code_object_info_s))

        if ptr[0] is NULL:
            raise MemoryError

    @staticmethod
    cdef code_object_info_s new():
        """Factory function to create code_object_info_s objects with
        newly allocated camd_comgr.code_object_info_s"""
        cdef void* ptr
        code_object_info_s.__allocate(&ptr)
        return code_object_info_s.fromPtr(ptr, owner=True)

    @staticmethod
    cdef code_object_info_s fromValue(camd_comgr.code_object_info_s other):
        """Allocate new C type and copy from ``other``.
        """
        wrapper = code_object_info_s.new()
        string.memcpy(wrapper._ptr, &other, sizeof(camd_comgr.code_object_info_s))
        return wrapper

    def c_sizeof(self):
        """Returns the size of the underlying C type in bytes.
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return sizeof(camd_comgr.code_object_info_s)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<code_object_info_s object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    def __init__(self,*args,**kwargs):
        """Constructor type code_object_info_s.

        Constructor for type code_object_info_s.

        Args:
            *args:
                Positional arguments. Initialize all or a subset of the member variables
                according to their order of declaration.
            **kwargs:
                Can be used to initialize member variables at construction,
                Just pass an argument expression of the form <member>=<value>
                per member that you want to initialize.
        """
        code_object_info_s.__allocate(&self._ptr)
        self._is_ptr_owner = True
        attribs = self.PROPERTIES()
        used_attribs = set()
        if len(args) > len(attribs):
            raise ValueError("More positional arguments specified than this type has properties.")
        for i,v in enumerate(args):
            setattr(self,attribs[i],v)
            used_attribs.add(attribs[i])
        valid_names = ", ".join(["'"+p+"'" for p in attribs])
        for k,v in kwargs.items():
            if k in used_attribs:
                raise KeyError(f"argument '{k}' has already been specified as positional argument.")
            elif k not in attribs:
                raise KeyError(f"'{k}' is no valid property name. Valid names: {valid_names}")
            setattr(self,k,v)
    def get_isa(self, i):
        """Get value ``isa`` of ``(<camd_comgr.code_object_info_s*>self._ptr)[i]``.
        """
        return (<camd_comgr.code_object_info_s*>self._ptr)[i].isa
    def set_isa(self, i, const char * value):
        """Set value ``isa`` of ``(<camd_comgr.code_object_info_s*>self._ptr)[i]``.
        """
        (<camd_comgr.code_object_info_s*>self._ptr)[i].isa = value
    @property
    def isa(self):
        """ISA name representing the code object."""
        return self.get_isa(0)
    @isa.setter
    def isa(self, const char * value):
        self.set_isa(0,value)

    def get_size(self, i):
        """Get value ``size`` of ``(<camd_comgr.code_object_info_s*>self._ptr)[i]``.
        """
        return (<camd_comgr.code_object_info_s*>self._ptr)[i].size
    def set_size(self, i, unsigned long value):
        """Set value ``size`` of ``(<camd_comgr.code_object_info_s*>self._ptr)[i]``.
        """
        (<camd_comgr.code_object_info_s*>self._ptr)[i].size = value
    @property
    def size(self):
        """The size of the code object."""
        return self.get_size(0)
    @size.setter
    def size(self, unsigned long value):
        self.set_size(0,value)

    def get_offset(self, i):
        """Get value ``offset`` of ``(<camd_comgr.code_object_info_s*>self._ptr)[i]``.
        """
        return (<camd_comgr.code_object_info_s*>self._ptr)[i].offset
    def set_offset(self, i, unsigned long value):
        """Set value ``offset`` of ``(<camd_comgr.code_object_info_s*>self._ptr)[i]``.
        """
        (<camd_comgr.code_object_info_s*>self._ptr)[i].offset = value
    @property
    def offset(self):
        """(undocumented)"""
        return self.get_offset(0)
    @offset.setter
    def offset(self, unsigned long value):
        self.set_offset(0,value)

    @staticmethod
    def PROPERTIES():
        return ["isa","size","offset"]

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


amd_comgr_code_object_info_t = code_object_info_s

@cython.embedsignature(True)
def amd_comgr_lookup_code_object(object data, object info_list, unsigned long info_list_size):
    r"""(No short description, might be part of a group.)

    @ brief Given a bundled code object and list of target id strings, extract
    correponding code object information.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` The code object bundle header is incorrect
    or reading bundle entries failed.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data`` is not of
    kind AMD_COMGR_DATA_KIND_FATBIN, or AMD_COMGR_DATA_KIND_BYTES or
    AMD_COMGR_DATA_KIND_EXECUTABLE or either ``info_list`` is NULL.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` if the ``data`` has
    invalid data.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            The data object for bundled code object. This should be
            of kind AMD_COMGR_DATA_KIND_FATBIN or AMD_COMGR_DATA_KIND_EXECUTABLE or
            AMD_COMGR_DATA_KIND_BYTES. The API interprets the data object of kind
            AMD_COMGR_DATA_KIND_FATBIN as a clang offload bundle and of kind
            AMD_COMGR_DATA_KIND_EXECUTABLE as an executable shared object. For a data
            object of type AMD_COMGR_DATA_KIND_BYTES the API first inspects the data
            passed to determine if it is a fatbin or an executable and performs
            the lookup.

        info_list (`~.code_object_info_s`/`~.object`) -- *IN,OUT*:
            A list of code object information structure
            initialized with null terminated target id strings. If the target id
            is matched in the code object bundle the corresponding code object
            information is updated with offset and size of the code object. If the
            target id is not found the offset and size are set to 0.

        info_list_size (`~.int`):
            (undocumented)
    """
    _amd_comgr_lookup_code_object__retval = amd_comgr_status_s(camd_comgr.amd_comgr_lookup_code_object(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],
        code_object_info_s.fromPyobj(info_list).getElementPtr(),info_list_size))
    return (_amd_comgr_lookup_code_object__retval,)


@cython.embedsignature(True)
def amd_comgr_map_elf_virtual_address_to_code_object_offset(object data, unsigned long elf_virtual_address, object code_object_offset, object slice_size, object nobits):
    r"""(No short description, might be part of a group.)

    @ brief Given a code object and an ELF virtual address, map the ELF virtual
    address to a code object offset. Also, determine if the ELF virtual address
    maps to an offset in a data region that is defined by the ELF file, but that
    does not occupy bytes in the ELF file. This is typically true of offsets that
    that refer to runtime or heap allocated memory. For ELF files with defined
    sections, these data regions are referred to as NOBITS or .bss sections.

    For bits regions: the size in bytes, starting from the provided virtual
    address up to either the end of the segment, or the start of a NOBITS region.
    In this case, slice size represents the number of contiguous readable
    addresses following the provided address.

    @retval `~.AMD_COMGR_STATUS_SUCCESS` The function has been executed
    successfully.

    @retval `~.AMD_COMGR_STATUS_ERROR` The provided code object has an invalid
    header due to a mismatch in magic, class, data, version, abi, type, or
    machine.

    @retval `~.AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT` ``data`` is not of
    kind AMD_COMGR_DATA_KIND_EXECUTABLE or invalid, or that the provided @p
    elf_virtual_address is not within the ranges covered by the object's
    load-type program headers.

    Args:
        data (`~.amd_comgr_data_s`) -- *IN*:
            The data object to be inspected for the given ELF virtual
            address. This should be of kind AMD_COMGR_DATA_KIND_EXECUTABLE.

        elf_virtual_address (`~.int`) -- *IN*:
            The address used to calculate the code object
            offset.

        code_object_offset (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *OUT*:
            The code object offset returned to the caller
            based on the given ELF virtual address.

        slice_size (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *OUT*:
            For nobits regions: the size in bytes, starting from
            the provided virtual address up to the end of the segment. In this case, the
            slice size represents the number of contiguous unreadable addresses following
            the provided address.

        nobits (`~.rocm.llvm._util.types.Pointer`/`~.object`) -- *OUT*:
            Set to true if the code object offset points to a location
            in a data region that does not occupy bytes in the ELF file, as described
            above.
    """
    _amd_comgr_map_elf_virtual_address_to_code_object_offset__retval = amd_comgr_status_s(camd_comgr.amd_comgr_map_elf_virtual_address_to_code_object_offset(
        amd_comgr_data_s.fromPyobj(data).getElementPtr()[0],elf_virtual_address,
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(code_object_offset)._ptr,
        <unsigned long *>rocm.llvm._util.types.Pointer.fromPyobj(slice_size)._ptr,
        <_Bool *>rocm.llvm._util.types.Pointer.fromPyobj(nobits)._ptr))
    return (_amd_comgr_map_elf_virtual_address_to_code_object_offset__retval,)

__all__ = [
    "AMD_COMGR_INTERFACE_VERSION_MAJOR",
    "AMD_COMGR_INTERFACE_VERSION_MINOR",
    "_amd_comgr_status_s__Base",
    "amd_comgr_status_s",
    "amd_comgr_status_t",
    "_amd_comgr_language_s__Base",
    "amd_comgr_language_s",
    "amd_comgr_language_t",
    "amd_comgr_status_string",
    "amd_comgr_get_version",
    "_amd_comgr_data_kind_s__Base",
    "amd_comgr_data_kind_s",
    "amd_comgr_data_kind_t",
    "amd_comgr_data_s",
    "amd_comgr_data_t",
    "amd_comgr_data_set_s",
    "amd_comgr_data_set_t",
    "amd_comgr_action_info_s",
    "amd_comgr_action_info_t",
    "amd_comgr_metadata_node_s",
    "amd_comgr_metadata_node_t",
    "amd_comgr_symbol_s",
    "amd_comgr_symbol_t",
    "amd_comgr_disassembly_info_s",
    "amd_comgr_disassembly_info_t",
    "amd_comgr_symbolizer_info_s",
    "amd_comgr_symbolizer_info_t",
    "amd_comgr_get_isa_count",
    "amd_comgr_get_isa_name",
    "amd_comgr_get_isa_metadata",
    "amd_comgr_create_data",
    "amd_comgr_release_data",
    "amd_comgr_get_data_kind",
    "amd_comgr_set_data",
    "amd_comgr_set_data_from_file_slice",
    "amd_comgr_set_data_name",
    "amd_comgr_get_data",
    "amd_comgr_get_data_name",
    "amd_comgr_get_data_isa_name",
    "amd_comgr_create_symbolizer_info_anon_funptr_0",
    "amd_comgr_create_symbolizer_info",
    "amd_comgr_destroy_symbolizer_info",
    "amd_comgr_symbolize",
    "amd_comgr_get_data_metadata",
    "amd_comgr_destroy_metadata",
    "amd_comgr_create_data_set",
    "amd_comgr_destroy_data_set",
    "amd_comgr_data_set_add",
    "amd_comgr_data_set_remove",
    "amd_comgr_action_data_count",
    "amd_comgr_action_data_get_data",
    "amd_comgr_create_action_info",
    "amd_comgr_destroy_action_info",
    "amd_comgr_action_info_set_isa_name",
    "amd_comgr_action_info_get_isa_name",
    "amd_comgr_action_info_set_language",
    "amd_comgr_action_info_get_language",
    "amd_comgr_action_info_set_options",
    "amd_comgr_action_info_get_options",
    "amd_comgr_action_info_set_option_list",
    "amd_comgr_action_info_get_option_list_count",
    "amd_comgr_action_info_get_option_list_item",
    "amd_comgr_action_info_set_bundle_entry_ids",
    "amd_comgr_action_info_get_bundle_entry_id_count",
    "amd_comgr_action_info_get_bundle_entry_id",
    "amd_comgr_action_info_set_working_directory_path",
    "amd_comgr_action_info_get_working_directory_path",
    "amd_comgr_action_info_set_logging",
    "amd_comgr_action_info_get_logging",
    "_amd_comgr_action_kind_s__Base",
    "amd_comgr_action_kind_s",
    "amd_comgr_action_kind_t",
    "amd_comgr_do_action",
    "_amd_comgr_metadata_kind_s__Base",
    "amd_comgr_metadata_kind_s",
    "amd_comgr_metadata_kind_t",
    "amd_comgr_get_metadata_kind",
    "amd_comgr_get_metadata_string",
    "amd_comgr_get_metadata_map_size",
    "amd_comgr_iterate_map_metadata_anon_funptr_0",
    "amd_comgr_iterate_map_metadata",
    "amd_comgr_metadata_lookup",
    "amd_comgr_get_metadata_list_size",
    "amd_comgr_index_list_metadata",
    "amd_comgr_iterate_symbols_anon_funptr_0",
    "amd_comgr_iterate_symbols",
    "amd_comgr_symbol_lookup",
    "_amd_comgr_symbol_type_s__Base",
    "amd_comgr_symbol_type_s",
    "amd_comgr_symbol_type_t",
    "_amd_comgr_symbol_info_s__Base",
    "amd_comgr_symbol_info_s",
    "amd_comgr_symbol_info_t",
    "amd_comgr_symbol_get_info",
    "amd_comgr_create_disassembly_info_anon_funptr_0",
    "amd_comgr_create_disassembly_info_anon_funptr_1",
    "amd_comgr_create_disassembly_info_anon_funptr_2",
    "amd_comgr_create_disassembly_info",
    "amd_comgr_destroy_disassembly_info",
    "amd_comgr_disassemble_instruction",
    "amd_comgr_demangle_symbol_name",
    "amd_comgr_populate_mangled_names",
    "amd_comgr_get_mangled_name",
    "amd_comgr_populate_name_expression_map",
    "amd_comgr_map_name_expression_to_symbol_name",
    "code_object_info_s",
    "amd_comgr_code_object_info_t",
    "amd_comgr_lookup_code_object",
    "amd_comgr_map_elf_virtual_address_to_code_object_offset",
]